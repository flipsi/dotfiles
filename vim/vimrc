"  Author:  Philipp Moers
"           soziflip@gmail.com
"           github.com/sflip/dotfiles
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins.
" I use   VUNDLE    to manage my plugins.
" It seems to be best package manager for me. For a discussion see here:
"       http://quyennguyen.com/code/Sync-Vim-With-Github-and-Vundle/
"       http://lepture.com/en/2012/vundle-vs-pathogen

" I install vundle like this:
"
"       git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install some of the vim configuration files and from inside vim I call
" :PluginInstall on each host to let vundle handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a KEYMAP SECTION
"                           where characters are bound.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:                             "
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (' ')
"                           - text edit leader is minus ('-')
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash (fish makes problems with vundle)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
" (TODO: current implementation is very simple and should be improved)
function! ComputeMyMode()
    if isdirectory(expand("~/.vim/bundle/vundle"))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc source $MYVIMRC
    autocmd BufWritePost vimrc AirlineRefresh
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


if s:MyMode == 'mastery'


    " start vundle
    filetype off
    set rtp+=~/.vim/bundle/vundle/
    "call vundle#rc()
    call vundle#begin()



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let Vundle manage Vundle (required!) {{{

Plugin 'gmarik/vundle'

" package control mappings from vundle itself
nnoremap <Leader>pl :PluginList<CR>
nnoremap <Leader>pi :PluginInstall<CR>
nnoremap <Leader>pc :PluginClean<CR>
nnoremap <Leader>pu :PluginUpdate<CR>
nnoremap <Leader>ps :PluginSearch<Space>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plugin 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" colorschemes
Plugin 'flazz/vim-colorschemes'
Plugin 'christophermca/meta5'
Plugin 'joshdick/onedark.vim'
Plugin 'sjl/badwolf'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" statusline {{{

" https://powerline.readthedocs.org/en/latest/usage/other.html#vim-statusline
"
" instead of this deprecated vimscript plugin...:
" Plugin 'Lokaltog/vim-powerline
" ... we use this rewritten one in python:
" Plugin 'powerline/powerline'

" disable powerline if it is installed
let g:powerline_loaded = 1

" on arch linux, installed python-powerline
" and fix import error with
"let $PYTHONPATH="/usr/lib/python3.5/site-packages"


" lightweight alternative to powerline

Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts=0


" TODO simple statusline like this
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plugin 'tpope/vim-fugitive'

nmap <Leader>gg <Leader>gs
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gr :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>ga :Gwrite<CR>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gp :Gpull<CR>
nnoremap <Leader>gP :Gpush<CR>


" show git status of lines on the left

Plugin 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

nnoremap <C-G>g :GitGutterToggle<CR>


" commit messages are special
augroup gitcommit
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit setlocal textwidth=50
    autocmd filetype gitcommit setlocal colorcolumn=""
augroup END


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plugin 'easymotion/vim-easymotion'

" prefix
map ä <Plug>(easymotion-prefix)


" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
Plugin 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<CR>", "\<Tab>"]
let g:clever_f_chars_match_any_signs = 'ö'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

Plugin 'haya14busa/incsearch.vim'

"nnoremap ö  <Plug>(incsearch-forward)
"nnoremap Ö  <Plug>(incsearch-backward)
"nnoremap gö <Plug>(incsearch-stay)

nnoremap ö :call incsearch#call()<CR>
nnoremap Ö :call incsearch#call({'command': '?'})<CR>


" searching in multiple files
" install 'the_silver_searcher' package on the system
Plugin 'rking/ag.vim'

" always start in project root instead of cwd
let g:ag_working_path_mode="r"

nnoremap / :Ag<Space>
" search for word under cursor
nnoremap <Leader>* :Ag "\b<C-R><C-W>\b"<CR>:cw<CR>
" search for visual selection
xnoremap  / y:<c-u>Ag <C-R>=shellescape(expand(@"),1)<CR><CR>
"nnoremap  K :<c-u>Ag <c-r>=shellescape(expand("<cword>"),1)<cr>:copen<cr>


" % also matches HTML-tags/words etc
Plugin 'edsono/vim-matchit'


" hide (fold) everything except search string etc
Plugin 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <Leader>zs :Fs<CR>
nnoremap <Leader>z/ :Fs<CR>
nnoremap <Leader>zö :Fs<CR>
nnoremap <Leader>zz :Fs<CR>

" show word under cursor
nnoremap <Leader>z* :Fw<CR>
nnoremap <Leader>zw :Fw<CR>

" show visual selection
vnoremap <Leader>z y:Fp<Space>\V<C-R>"<CR>

" change context size (number of lines around matches)
nnoremap <Leader>z+ :Fi<CR>
nnoremap <Leader>zi :Fi<CR>
nnoremap <Leader>z- :Fd<CR>
nnoremap <Leader>zd :Fd<CR>

" restore folds
nnoremap <Leader>ze :Fe<CR>
nnoremap <Leader>Z  :Fe<CR>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

Plugin 'kien/ctrlp.vim'

let g:ctrlp_map = '#'
let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap #          :CtrlPBuffer<CR>
nnoremap <Leader>er :CtrlPMRUFiles<CR>
nnoremap <Leader>em :CtrlPMixed<CR>
nnoremap <Leader>eo :CtrlPRoot<CR>
nnoremap <Leader>eb :CtrlPBuffer<CR>

" ignore some stuff
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<Esc><Enter>', '<c-v>', '<RightMouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<c-l>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<c-h>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<left>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>', '<right>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plugin 'Shougo/vimproc.vim'
"Plugin 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) overview {{{

Plugin 'majutsushi/tagbar'

" install 'ctags' package on the system

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <Leader>tt :TagbarToggle<CR>

"autocmd FileType vim nested :TagbarOpen()<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file browser {{{

Plugin 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show/hide nerdtree
noremap <silent> <Leader>tn :NERDTreeToggle<CR>
" show nerdtree from current file
noremap <silent> <Leader>tN :call SetCwdToFilePath() <bar> :NERDTreeCWD<CR>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

Plugin 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex"] }

nnoremap <silent> <Leader>sc :SyntasticCheck<CR>
nnoremap <silent> <Leader>sr :SyntasticReset<CR>
nnoremap <silent> <Leader>st :SyntasticToggleMode<CR>
nnoremap <silent> <Leader>si :SyntasticInfo<CR>


" install linters on the system:
" - pylint
" - jslint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)
let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mLine indented incorrectly;.*',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mShort PHP opening tag used;'
            \ ] }



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" text editing {{{

" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plugin 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <C-p> <Plug>yankstack_substitute_older_paste
nmap <C-n> <Plug>yankstack_substitute_newer_paste
"call yankstack#setup()

" add and toggle comments with <Leader>c<space> etc
Plugin 'scrooloose/nerdcommenter'
" use leading space
let g:NERDSpaceDelims = 1
" duplicate a line and comment out the first one
nmap <Leader>cd yy<Leader>ccp

" automagically add closing braces etc
Plugin 'Raimondi/delimitMate'

" add a ; at the end of a line
"Plugin 'lfilho/cosco.vim'
"inoremap <silent> <Esc><Enter> <Esc>:call cosco#commaOrSemiColon()<CR>A<Enter>
inoremap <silent> <Esc><Enter> <Esc>A;<Enter>

" add/change/delete quotes/braces/... and more
Plugin 'tpope/vim-surround'

" swap ('transpose') two words or arbitrary things
Plugin 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <Leader>x <Plug>(Exchange)
xmap <Leader>x <Plug>(Exchange)
nmap <Leader>xc <Plug>(ExchangeClear)
nmap <Leader>xl <Plug>(ExchangeLine)
nmap <Leader>xx <Leader>xiwb.

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plugin 'shinokada/dragvisuals.vim'
"vmap <expr> <C-H>  DVB_Drag('left')
"vmap <expr> <C-L>  DVB_Drag('right')
"vmap <expr> <C-J>  DVB_Drag('down')
"vmap <expr> <C-K>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plugin 'zirrostig/vim-schlepp'

vmap <up>    <Plug>SchleppUp
vmap <down>  <Plug>SchleppDown
vmap <left>  <Plug>SchleppLeft
vmap <right> <Plug>SchleppRight

" duplicate selection
vmap <Enter> <Plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plugin 'vim-scripts/toggle_words.vim'

noremap <silent> -tw :ToggleWord<CR>

let g:toggle_words_dict = {
            \ 'css': [
            \     ["div", "span"],
            \     ["head", "body"],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ["div", "span"],
            \     ["head", "body"],
            \     ["header", "footer"],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ["0", "1"],
            \     ["black", "white"],
            \     ["dark", "light"],
            \     ["deep", "shallow"],
            \     ["get", "set"],
            \     ["head", "tail"],
            \     ["header", "footer"],
            \     ["left", "right"],
            \     ["love", "hate"],
            \     ["min", "max"],
            \     ["next", "previous"],
            \     ["on", "off"],
            \     ["open", "close"],
            \     ["red","orange","yellow","green","blue","purple"],
            \     ["strong", "weak"],
            \     ["this", "that"],
            \     ["top", "bottom"],
            \     ["true", "false"],
            \     ["up", "down"],
            \     ["width", "height"],
            \     ["yes", "no"],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plugin 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger="<Esc>."
"let g:UltiSnipsListSnippets="<Esc>."
let g:UltiSnipsJumpForwardTrigger="<C-i>"
let g:UltiSnipsJumpBackwardTrigger="<C-o>"
let g:UltiSnipsSnippetDirectories=["UltiSnips", "sflipsnippets"]


" snippet packs
Plugin 'honza/vim-snippets'


" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced auto completion engine {{{
"
" Remember: YCM is a plugin with a compiled component. If you update YCM using
" Vundle and the ycm_support_libs library APIs have changed (happens rarely),
" YCM will notify you to recompile it. You should then rerun the install
" process.

Plugin 'Valloric/YouCompleteMe'

let g:ycm_key_list_select_completion   = ['<C-N>', '<Down>', '<Tab>', '<Enter>']
let g:ycm_key_list_previous_completion = ['<C-P>', '<Up>']

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

Plugin 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-l=)
xmap -l <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -lG=)
nmap -l <Plug>(EasyAlign)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

Plugin 'Chiel92/vim-autoformat'

" install formatters on the system:
" - js-beautify (for HTML, CSS, JavaScript, JSON)

nnoremap -af :Autoformat<CR>
vnoremap -af :Autoformat<CR>
nmap <Leader>af -af
vmap <Leader>af -af


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plugin 'vim-scripts/ShowTrailingWhiteSpace'

" (has a bug)
"Plugin 'vim-scripts/JumpToTrailingWhiteSpace'

Plugin 'vim-scripts/DeleteTrailingWhiteSpace'
" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
" delete trailing whitespace for selected line
vnoremap <silent> -dst :DeleteTrailingWhitespace<CR>
" delete trailing whitespace for whole buffer
nnoremap <silent> -dst :%DeleteTrailingWhitespace<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make #DD8844 appear orange etc
Plugin 'ap/vim-css-color'

" launch colorpicker and insert color code
Plugin 'blindFS/vim-colorpicker'
nnoremap <Leader>cp :ColorPicker<CR>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plugin 'KabbAmine/vCoolor.vim'
"nnoremap <Leader>cp :VCoolor<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" LaTeX stuff {{{

Plugin 'lervag/vimtex'

let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

nnoremap <Leader>bl :VimtexCompileToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" scala stuff {{{

Plugin 'derekwyatt/vim-scala'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plugin 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <Leader>ut :GundoToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    " finish vundle
    call vundle#end()
    filetype plugin indent on


    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping
    " but cannot be executed in the vundle block)
    call yankstack#setup()

endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" options {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=1200

" don't draw everything (e.g. when playing macros)
set lazyredraw

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread

" command history size
set history=9999

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable

" highlight conflict markers
" TODO make it work. seems not to.
"match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = 1
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter * set nocursorline nocursorcolumn
    au WinEnter,InsertLeave * if g:cursorposition
    au WinEnter,InsertLeave *     set cursorline cursorcolumn
    au WinEnter,InsertLeave * endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignore+=*.o,*.obj
set wildignore+=*.pyc
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=8
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
" never have to append 'g' to a search/substitute again
set gdefault

" allow the cursor to move where there is no character
set virtualedit=all

" characters to show in list mode (like whitespace)
" and wrap symbols that are always shown
set listchars=space:·,tab:--,extends:❯,precedes:❮
set showbreak=↪
" use 4 spaces instead of tabs
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright


" }}}


" colorscheme {{{

set background=dark

if s:MyMode == 'mastery'

    " colorscheme candycode
    " colorscheme dante
    " colorscheme jellybeans
    " colorscheme meta5
    " colorscheme desertEx
    " colorscheme lucius
    " colorscheme onedark
    colorscheme molokai
    colorscheme badwolf

    " let g:airline_theme='serene'
    " let g:airline_theme='kalisi'
    " let g:airline_theme='lucius'
    " let g:airline_theme='tomorrow'
    let g:airline_theme='base16_summerfruit'

    highlight CursorLine   ctermbg=235
    highlight CursorColumn ctermbg=235

else

    " fallback colorscheme
    colorscheme desert

endif

" }}}


" allows cursor change in tmux mode {{{

if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" toggle syntax highlighting {{{
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction
" }}}


" get a list of buffers {{{
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction
" }}}


" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}


" make columns after &textwidth visible or invisible {{{
function! ToggleColorColumn()
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if &colorcolumn == "" || &colorcolumn != expr
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}
"... and call this function when &textwidth is changed
augroup colorcolumn
    au!
    au OptionSet textwidth if &textwidth != 0
    au OptionSet textwidth      call ToggleColorColumn()
    au OptionSet textwidth else
    au OptionSet textwidth      set colorcolumn=
    au OptionSet textwidth endif
augroup END


" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\S)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\S)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\S)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters above {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num - 1
    execute "normal O\<Esc>i" . char . "\<Esc>vy" . num . "pj"
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    execute "normal I" . char . " \<Esc>A " . char ."\<Esc>"
    execute "normal VYPVr" . char . char . "\<Esc>"
    execute "normal Yjp\<Esc>"
endfunction
" }}}



" ranger as a file chooser {{{
function! RangerChooser()
    let temp = tempname()
    " The option "--choosefiles" was added in ranger 1.5.1. Use the next line
    " with ranger 1.4.2 through 1.5.0 instead.
    "exec 'silent !ranger --choosefile=' . shellescape(temp)
    if has("gui_running")
        exec 'silent !xterm -e ranger --choosefiles=' . shellescape(temp)
    else
        exec 'silent !ranger --choosefiles=' . shellescape(temp)
    endif
    if !filereadable(temp)
        redraw!
        " Nothing to read.
        return
    endif
    let names = readfile(temp)
    if empty(names)
        redraw!
        " Nothing to open.
        return
    endif
    " Edit the first item.
    exec 'edit ' . fnameescape(names[0])
    " Add any remaning items to the arg list/buffer list.
    for name in names[1:]
        exec 'argadd ' . fnameescape(name)
    endfor
    redraw!
endfunction
command! -bar RangerChooser call RangerChooser()
" }}}






""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" I copied this great piece of code from Steve Losh (sjl):




" Next and Last {{{
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B.
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# "b" || c ==# "(" || c ==# ")"
        let c = "("
    elseif c ==# "B" || c ==# "{" || c ==# "}"
        let c = "{"
    elseif c ==# "r" || c ==# "[" || c ==# "]"
        let c = "["
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute "normal! " . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute "normal! va" . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# "("
            let open = "("
            let close = ")"
        elseif c ==# "{"
            let open = "{"
            let close = "}"
        elseif c ==# "["
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute "normal! vi" . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute "normal! vi" . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute "normal! va" . c . "hol"

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}



" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}


" }}}





""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  KEYMAP SECTION                                                              "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{



let mapleader=' '



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" (for compatibility)
nnoremap <C-G><C-G> <C-G>

" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<CR>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<CR>
"endif
"nnoremap <Leader><F5> :MyRefresh<CR>

" open config file
"nnoremap <Leader>ev :edit ~/dotfiles/vim/vimrc<CR>
nnoremap <Leader>ev :execute 'edit ' . resolve(expand($MYVIMRC))<CR>
nnoremap <Leader>e3 :edit ~/.i3/config<CR>

" reload config file
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <F5>       :source $MYVIMRC<CR>


" to follow links in help and jump to definition (ctags)
nnoremap <M-Enter>    <C-]>
nnoremap <Esc><Enter> <C-]>


" visual block mode is more useful than visual mode
nnoremap v <C-v>
nnoremap <C-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <C-c>


" copy to clipboard in visual mode
"vnoremap <C-c> "+y
vnoremap <C-c> "*y
nnoremap <C-c> gg0VG"*y
" paste from clipboard
noremap  <C-v><C-v> "*p
inoremap <C-v><C-v> <Esc>"*p


" record macro ('complex repeat')
nnoremap <Leader>M q
" replay macro ('complex repeat')
nnoremap <Leader>m @


" alternative way to go back to normal mode
inoremap jk <Esc>
cnoremap jk <C-c>
cnoremap <C-g>  <C-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll with arrow keys if i lay back
"nnoremap <Down> <C-E>
"nnoremap <Up>   <C-Y>

" scroll a little smoother (but still without plugin)
" (this actually is suggested in :help scroll-smooth)
noremap <M-j>  <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <Esc>j <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <M-k>  <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
noremap <Esc>k <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)


" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))

" write changes with root permissions
cnoremap w!! w !sudo tee % >/dev/null
"cnoreabbrev w!! w !sudo tee % >/dev/null

" have the up/down search functionality with C-p too
cnoremap <C-n> <down>
cnoremap <C-p> <up>





" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{


" change text width
nnoremap <Leader>ow0 :set textwidth=0<CR>
nnoremap <Leader>ow7 :set textwidth=78<CR>
nnoremap <Leader>ow8 :set textwidth=80<CR>
nnoremap <Leader>ow1 :set textwidth=100<CR>
nnoremap <Leader>ow2 :set textwidth=120<CR>

" change tab width
nnoremap <Leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>
nnoremap <Leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
nnoremap <Leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<CR>
" convert tabs so spaces with :retab

" toggle paste mode
nnoremap <Leader>op :set paste! <bar> :set paste?<CR>

" ... but ignore typos
nnoremap <Leader>o <NOP>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <C-G>y :call ToggleSyntax()<CR>

" toggle line numbers
noremap <silent> <C-G>l :set number! <bar> :set relativenumber! <CR>
noremap <silent> <C-G>L :set relativenumber! <CR>

" toggle word wrap
nnoremap <silent> <C-G>w :set wrap! <CR>

" toggle vertical ruler
nnoremap <silent> <C-G>r :call ToggleColorColumn()<CR>
nnoremap <silent> <C-G>R :highlight ColorColumn ctermbg=234<CR>

" toggle highlight current cursor position
" (switch to insert mode to apply changes)
nnoremap <silent> <C-G>h :let g:cursorposition = 1 - g:cursorposition <CR>

" toggle show listchars (like whitespace)
nnoremap <silent> <C-G>a :set list!<CR>


" spell checking
nnoremap <C-G>ss :set spell! <bar> :set spell? <CR>
nnoremap <C-G>se :set spelllang=en<CR>
nnoremap <C-G>sd :set spelllang=de<CR>
nmap <C-G>sg <C-G>sd


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{


" move intuitively when text is wrapped
nnoremap j gj
nnoremap k gk

" move faster
nnoremap gj 10j
nnoremap gk 10k
vnoremap gj 10j
vnoremap gk 10k


" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <C-b>  <Left>
noremap! <C-f>  <Right>
noremap! <C-d>  <Delete>
" ... by words
noremap! <M-b>  <S-Left>
noremap! <M-f>  <S-Right>
cnoremap <Esc>b <S-Left>
cnoremap <Esc>f <S-Right>


" move to BOL
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <C-A> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <C-A> <C-O><C-A>

" move to EOL
nnoremap <C-E> $
vnoremap <C-E> $
onoremap <C-E> $
inoremap <C-E> <Esc>A
cnoremap <C-A> <Home>
" move to EOL with l instead of $
nnoremap cl c$
nnoremap yl y$
nnoremap dl d$
"nnoremap vl v$


" swap , and ;
" (makes more sense on german keyboard)
nnoremap , ;
nnoremap ; ,
nnoremap g, g;
nnoremap g; g,


" swap ` and ' (jump to markers)
" (by default, ' marked line, ` marked line and column)
nnoremap ' `
nnoremap ` '

" goto mark
nnoremap Ä `

" goto last edit
nnoremap <Leader>. '.zz


" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{


" search
if s:MyMode == 'stripped'
    nnoremap ö /
    nnoremap Ö ?
endif

" search in multiple files
if s:MyMode == 'stripped'
    nnoremap / :vimgrep<Space>
endif

" search for visual selection
vnoremap * y/<C-R>"<CR>
if s:MyMode == 'stripped'
    vnoremap / y/<C-R>"<CR>
endif


" find next and previous occurence like usual when we searched backwards
nnoremap <expr> n  'Nn'[v:searchforward]
nnoremap <expr> N  'nN'[v:searchforward]

" keep search matches in the middle of the window
" TODO decide if i really want that and combine with the thing above
"nnoremap n nzzzv
"nnoremap N Nzzzv


" find trailing whitespace
nnoremap <Leader>fst /\v\s+$<CR>

" find matching element (brackets/braces/parentheses)
nnoremap <Leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <Leader>fm %
nmap <Leader>ff %

" find all lines with keyword under cursor and ask which one to jump to
nmap <Leader>fj [I:let nr = input("Which one: ")
            \   <Bar> exe "normal " . nr ."[\t"<CR>

" find git merge conflict markers
nnoremap <Leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is minus ('-')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$j

" autocompletion
if s:MyMode == 'stripped'
    inoremap <M-.>  <C-N>
    inoremap <Esc>. <C-N>
    inoremap <M-:>  <C-P>
    inoremap <Esc>: <C-P>
endif

" increment/decrement number
nnoremap +  <C-A>
nnoremap -- <C-X>


" indent lines
nnoremap < <<
vnoremap < <gv
nnoremap > >>
vnoremap > >gv

" move line up or down
nnoremap <silent> -k :m .-2<CR>==
nnoremap <silent> -j :m .+1<CR>==
vnoremap <silent> -j :m '>+1<CR>gv=gv
vnoremap <silent> -k :m '<-2<CR>gv=gv


" split line (opposite of 'J'oin lines)
" (regular 'S' can be done with 'cc' instead)
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w


" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <M-o>  <Esc>o<Esc>k
"noremap <Esc>o <Esc>o<Esc>k
"noremap <M-O>  <Esc>O<Esc>j
"noremap <Esc>O <Esc>O<Esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k


" add space (a few newlines) below
"nnoremap <Enter> :.+1insert \n\n\n<CR>
nnoremap -as mno<Esc>o<Esc>o<Esc>o<Esc>`n

" add a line of characters
nnoremap -al :call InsertCharLine(input("Insert character: "), 80)<CR>
" add a box of characters ('comment box')
nnoremap -ab :call InsertCharBox(input("Insert character: "))<CR>


" substitute occurences of selection in this buffer with confirmation
" (to change only this occurence, use c. by default they are the same)
vnoremap s y:%s/<C-R>"//c<Left><Left>
vmap -s s

" substitute (last) search
nnoremap -ss :%s:<C-R>/:

" enter substitution mode quickly
nnoremap -sl :s:
nnoremap <C-S> :%s:


" replace word under cursor with yank
nnoremap -rw viwp
nnoremap -rW viWp
" replace line with yank
"nnoremap -rl Vp
nnoremap -rl v$p


" sort lines
nnoremap -o vip:sort<CR>
vnoremap -o :sort<CR>


" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap -tt blgueea


" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> -dsl :s:^\s\+::<CR>
" replace '  ' (double space) with ' ' (one space)
nnoremap <silent> -dsd :.s:\v(\S)  (\S):\1 \2:<CR>
nnoremap <silent> -dsD :%s:\v(\S)  (\S):\1 \2:<CR>


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <Leader>ch :call ToggleHTMLComment("n")<CR>
vnoremap <silent> <Leader>ch :call ToggleHTMLComment("v")<CR>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <Leader>cd yyI#<Esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <M-u>  :earlier<CR>
noremap <Esc>u :earlier<CR>
noremap <M-U>  :later<CR>
noremap <Esc>U :later<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{


" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUILDING AND DEBUGGING {{{


" make
nnoremap <Leader>bm :make<CR>

" jump to (syntastic) errors
nnoremap <Leader>sf :lfirst<CR>
nnoremap <Leader>sn :lnext<CR>
nnoremap <Leader>sN :lprevious<CR>

" jump through lists
nnoremap <left>  :cprev<cr>
nnoremap <right> :cnext<cr>
nnoremap <up>    :lprev<cr>
nnoremap <down>  :lnext<cr>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <Leader>sl :lclose<bar>:cclose<CR>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <Leader>sL :lopen<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS AND WINDOWS {{{


" change buffer by searching
if s:MyMode == 'stripped'
    nnoremap # :buffer<Space>
endif

" change to LRU buffer
nnoremap <Space><Space> :buffer #<CR>

" circle through buffers
nnoremap <M-n>  :bnext<CR>
nnoremap <Esc>n :bnext<CR>
nnoremap <M-p>  :bprevious<CR>
nnoremap <Esc>p :bprevious<CR>

" change window
nnoremap <silent> <C-j> :wincmd j<CR>
nnoremap <silent> <C-k> :wincmd k<CR>
nnoremap <silent> <C-h> :wincmd h<CR>
nnoremap <silent> <C-l> :wincmd l<CR>

" move buffer to a new window
nnoremap <silent> <Leader><C-l> :vsplit<CR><C-W>w<CR>:bprevious<CR><C-W>w<CR>
nnoremap <silent> <Leader><C-j>  :split<CR><C-W>w<CR>:bprevious<CR><C-W>w<CR>


" clear windows (close quickfix and location list)
nnoremap <silent> <BS> :lclose <Bar> :cclose <CR>

" toggle quickfix or location list
nnoremap <silent> <Leader>tf :call ToggleList("Quickfix List", 'c')<CR>
nnoremap <silent> <Leader>tl :call ToggleList("Location List", 'l')<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{


" shell in dir of current file
nnoremap <Leader>if :call SetCwdToFilePath() <bar>
            \ :let $SHELL = '/usr/bin/fish' <bar> :!fish<CR>
nnoremap <Leader>ib :call SetCwdToFilePath() <bar> :!bash<CR>

" file manager in dir of current file
"nnoremap <Leader>ir :call SetCwdToFilePath() <bar> :!ranger<CR>
nnoremap <Leader>ir :call SetCwdToFilePath() <bar> :RangerChooser<CR>

" git interface
nnoremap <Leader>it :call SetCwdToFilePath() <bar> :!tig status<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{


" check for file changes (and 'reload' them or get asked with autoread)
nnoremap <Leader>rl :checktime<CR>


" write changes
nnoremap <Leader>w :update<CR>
nnoremap <Leader>WW :update!<CR>

" quit current buffer
nnoremap q :bdelete<CR>
nnoremap <Leader>qq :bdelete<CR>
nnoremap <Leader>QQ :bdelete!<CR>

" quit all buffers (not vim)
nnoremap <Leader>qa :bufdo bdelete<CR>

" quit current window
nnoremap Q :quit<CR>
" quit all windows but current
nnoremap <Leader>qo :only<CR>

" quit vim (mulitple windows)
" (this is how i exit most terminal applications)
nnoremap <C-D> :quitall<CR>
nnoremap <Leader><C-D><C-D> :quitall!<CR>

" remember ZZ and ZQ


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



" }}}




" vim:tw=80:sw=4:fdm=marker:
