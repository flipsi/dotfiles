"  Author:  Philipp Moers
"           soziflip@gmail.com
"           http://github.com/sflip/dotfiles
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
" If you are reading this configuration file on whe web and want use it right
" away, start vim like this:
"
"       bash -c "vim -u <(curl https://raw.githubusercontent.com/sflip/dotfiles/master/vim/vimrc) FILE"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins.
" I use   VUNDLE    to manage my plugins.
" It seems to be best package manager for me. For a discussion see here:
"       http://quyennguyen.com/code/Sync-Vim-With-Github-and-Vundle/
"       http://lepture.com/en/2012/vundle-vs-pathogen

" I install vundle like this:
"
"       git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install some of the vim configuration files and from inside vim I call
" :PluginInstall on each host to let vundle handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a KEYMAP SECTION
"                           where characters are bound.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (' ')
"                           - text edit leader is minus ('-')
"                           - interface leader is space followed by y (' y')
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"       a LOCAL SECTION
"                           where potential other vimrc files are loaded.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash
" (fish is not posix compatible and makes problems)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" always search recursively (e.g. when using :find)
set path+=**

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
" (TODO: current implementation is very simple and should be improved)
function! ComputeMyMode()
    if isdirectory(expand("~/.vim/bundle/vundle"))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc source $MYVIMRC
    autocmd BufWritePost vimrc AirlineRefresh
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


if s:MyMode == 'mastery'


    " start vundle
    filetype off
    set rtp+=~/.vim/bundle/vundle/
    "call vundle#rc()
    call vundle#begin()



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let Vundle manage Vundle (required!) {{{

Plugin 'gmarik/vundle'

" package control mappings from vundle itself
nnoremap <leader>pl :PluginList<cr>
nnoremap <leader>pi :PluginInstall<cr>:smile<cr>
nnoremap <leader>pc :PluginClean<cr>
nnoremap <leader>pu :PluginUpdate<cr>
nnoremap <leader>ps :PluginSearch<space>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim sessions {{{

" make sessions more convenient and automatically updated
Plugin 'tpope/vim-obsession'

let g:session_file_name = '.session.vim'

" start session
nnoremap <leader>se :exe 'Obsession' . g:session_file_name<cr>

" automatically load sessions if started without args
autocmd VimEnter * nested
            \ if !argc() && empty(v:this_session) |
            \   if filereadable(g:session_file_name) |
            \     exe 'source' . g:session_file_name |
          " \   elseif |
          " \     exe 'Obsession' . g:session_file_name |
            \   endif |
            \ endif


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tmux integration {{{


" fix FocusLost and FocusGained events in tmux
Plugin 'tmux-plugins/vim-tmux-focus-events'


" " don't worry about tmux panes and vim splits
" Plugin 'christoomey/vim-tmux-navigator'
" let g:tmux_navigator_save_on_switch = 1
" let g:tmux_navigator_no_mappings = 1
" nnoremap <silent> {Left-Mapping}     :TmuxNavigateLeft<cr>
" nnoremap <silent> {Down-Mapping}     :TmuxNavigateDown<cr>
" nnoremap <silent> {Up-Mapping}       :TmuxNavigateUp<cr>
" nnoremap <silent> {Right-Mapping}    :TmuxNavigateRight<cr>
" nnoremap <silent> {Previous-Mapping} :TmuxNavigatePrevious<cr>


" run tmux commands from within vim
Plugin 'benmills/vimux'
let g:VimuxHeight = "50"
let g:VimuxOrientation = "h"
let VimuxUseNearest = 1
nnoremap <leader>bo         :VimuxRunCommand ""<left>
nnoremap <leader>bv         :call MakeWithVimux("")<left><left>
nnoremap <leader>bf         :VimuxRunCommand " " . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
nnoremap <leader>bF         :VimuxRunCommand "./" . expand('%') . " "<left>
nnoremap <leader>bb         :update<cr>:VimuxRunLastCommand<cr>
nnoremap <leader>bl         :VimuxRunCommand "clear"<cr>
nnoremap <leader>bq         :VimuxCloseRunner<cr>
nnoremap <leader>b<bs>      :VimuxCloseRunner<cr>
nnoremap <leader>bz         :call VimuxZoomRunner()<cr>
nnoremap <leader>bc         :VimuxInterruptRunner<cr>
nnoremap <leader>b<c-c>     :VimuxInterruptRunner<cr>
nnoremap <leader>b<c-b>     :VimuxInspectRunner<cr>
nnoremap <leader><c-b><c-b> :VimuxInspectRunner<cr>
nnoremap <leader>be         :call MakeWithVimuxOpenErrors('quickfix')<cr>
nnoremap <leader>bE         :call MakeWithVimuxOpenErrors('buffer')<cr>
" MORE SPECIFIC MAPPING IN OTHER VIMRC SECTIONS (which makes more sense)

" build/debug with vimux
" param command: the shell command to execute
function! MakeWithVimux(command)
    let l:git_branch_name = system('git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d "\n" || echo -n ""')
    let l:git_branch_name_escaped = substitute(UrlEncode(l:git_branch_name), '%..', '-', 'g')
    if !empty(v:servername)
        let l:project_name = tolower(v:servername)
    else
        let l:project_name = tolower(system('basename $(pwd) | tr -d "\n"'))
    endif
    let g:makewithvimux_outfile = '/tmp/vim.'.l:project_name.'.'.l:git_branch_name_escaped.'.make.out'
    let command = a:command . ' | tee ' . g:makewithvimux_outfile
    call VimuxRunCommand(command)
endfunction
function! MakeWithVimuxOpenErrors(where)
    " remove terminal color escape sequences that fuck with errorformat
    exec  ':silent !sed -i -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" ' . g:makewithvimux_outfile
    redraw!
    exec 'cfile ' . g:makewithvimux_outfile
    if a:where == 'quickfix'
        let g:jumplist = 'quickfixlist'
        call ToggleList("Quickfix List", 'c')
    elseif a:where == 'buffer'
        execute "edit " . g:makewithvimux_outfile
    endif
endfunction





" autocompletion from words visible in tmux panes
Plugin 'wellle/tmux-complete.vim'
" <c-x><c-u> and then <c-u> or <c-n> a few times



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plugin 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" make gvim colorschemes work in terminal
Plugin 'godlygeek/csapprox'


" colorschemes
Plugin 'flazz/vim-colorschemes'
Plugin 'christophermca/meta5'
Plugin 'joshdick/onedark.vim'
Plugin 'sjl/badwolf'


" cycle through colorschemes
Plugin 'vim-scripts/ScrollColors'
nnoremap <leader>yo :COLORSCROLL<cr>


" " highlight different bracket pairs with different colors
" " DOES NOT WORK
" Plugin 'kien/rainbow_parentheses.vim'
" nnoremap <leader>yb :RainbowParenthesesToggle<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" distraction free mode {{{

Plugin 'junegunn/goyo.vim'

let g:goyo_width="120"
let g:goyo_height="100%"

nnoremap <leader>yy :Goyo<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" statusline {{{

" https://powerline.readthedocs.org/en/latest/usage/other.html#vim-statusline
"
" instead of this deprecated vimscript plugin...:
" Plugin 'Lokaltog/vim-powerline
" ... we use this rewritten one in python:
" Plugin 'powerline/powerline'

" disable powerline if it is installed
let g:powerline_loaded = 1

" on arch linux, installed python-powerline
" and fix import error with
"let $PYTHONPATH="/usr/lib/python3.5/site-packages"


" lightweight alternative to powerline

Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'

let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline#extensions#tabline#enabled = 0

"let g:airline_section_y = g:airline_section_a
let g:airline_section_a = '%{fnamemodify(getcwd(), ":t")}'

let g:airline_powerline_fonts=0
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''



" simple statusline
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plugin 'tpope/vim-fugitive'

nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gU :Gread<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>gA :Gwrite<cr>
nnoremap <leader>gc :Gcommit<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gpp :Gpull<cr>
nnoremap <leader>gpu :Gpush<cr>
nnoremap <leader>gpU :exe ':Git push -u ' . system('git remote \| head -n1') . ' ' . system('git rev-parse --abbrev-ref HEAD')
nnoremap <leader>geb :exe ':Git checkout -b ' . input('Branch name: ')<cr>

" in Gdiff view, navigate and stage/checkout easily
augroup gitdiff
    au!
    au BufRead fugitive://* nnoremap <buffer> <down>  ]c
    au BufRead fugitive://* nnoremap <buffer> <up>    [c
    au BufRead fugitive://* nnoremap <buffer> <left>  do
    au BufRead fugitive://* nnoremap <buffer> <right> dp
augroup END


" show git status of lines on the left

Plugin 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

" GitGutter styling to use · instead of +/-
let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_modified_removed = '∙'

" do not map ic/ac text objects etc because I decide how I use them
let g:gitgutter_map_keys = 0

omap ih <plug>GitGutterTextObjectInnerPending
omap ah <plug>GitGutterTextObjectOuterPending
xmap ih <plug>GitGutterTextObjectInnerVisual
xmap ah <plug>GitGutterTextObjectOuterVisual

nnoremap <leader>yG   :GitGutterToggle<cr>
nnoremap <leader>yg   :GitGutter<cr> " redraw
nnoremap <leader>gg gg:GitGutterNextHunk<cr>ztzv
nnoremap <leader>gG  G:GitGutterPrevHunk<cr>ztzv
nnoremap <leader>gn   :GitGutterNextHunk<cr>ztzv
nnoremap <leader>gN   :GitGutterPrevHunk<cr>ztzv
nnoremap <down>       :GitGutterNextHunk<cr>ztzv
nnoremap <up>         :GitGutterPrevHunk<cr>ztzv
nnoremap <leader>ga   :GitGutterStageHunk<cr>
nnoremap <leader>gu   :GitGutterUndoHunk<cr>
nnoremap <leader>gi   :GitGutterPreviewHunk<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle unicode and digraphs easily {{{

Plugin 'chrisbra/unicode.vim'

" inspect character under cursor
nnoremap ga :UnicodeName<cr>

" complete unicode with <c-x><c-z>
" complete digraph with <c-x><c-g>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plugin 'easymotion/vim-easymotion'

" prefix
map ä <plug>(easymotion-prefix)
" keys to move to target
let g:EasyMotion_keys = 'asdfgh,.qwertuiocvbnmjkl'



" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
" Plugin 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<cr>", "\<tab>"]
let g:clever_f_chars_match_any_signs = 'ö'



" like f but with two characters
Plugin 'justinmk/vim-sneak'

" interactive mode like easymotion
" let g:sneak#label = 1

" movement repeatable with same keystroke like clever-f
" (i don't really like this, as it makes movements unpredictable)
" let g:sneak#s_next = 1

" , always forwards ; always backwards
" let g:sneak#absolute_dir = 1

" use smartcase;
let g:sneak#use_ic_scs = 1

nmap f <plug>Sneak_s
xmap z <plug>Sneak_s
omap z <plug>Sneak_s

nmap s <plug>Sneak_S
nmap F <plug>Sneak_S
xmap Z <plug>Sneak_S
omap Z <plug>Sneak_S

nmap , <plug>Sneak_;
nmap ; <plug>Sneak_,


autocmd ColorScheme * hi Sneak      ctermfg=72 ctermbg=236
autocmd ColorScheme * hi SneakScope ctermfg=72 ctermbg=236



" make f only match interesting characters
" Plugin 'svermeulen/vim-NotableFt'

" nmap , <plug>NotableFtRepeatSearchForward
" nmap ; <plug>NotableFtRepeatSearchBackward
" nmap f <plug>NotableFtSearchFForward
" nmap s <plug>NotableFtSearchFBackward
" nmap F <plug>NotableFtSearchFBackward
" nmap t <plug>NotableFtSearchTForward
" nmap T <plug>NotableFtSearchTBackward



" highlight characters for f
" Plugin 'unblevable/quick-scope'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" movements and text objects for parts of words {{{

" move with ,w in wordsLikeThisWord or words_like_this_word
" Plugin 'bkad/CamelCaseMotion'

" call camelcasemotion#CreateMotionMappings(',') " DOES NOT WORK HERE

" also handle dashes with this plugin (hence w should move over them)
" (this breaks toggle_words for many cases)
" set iskeyword+=-


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better and custom text objects {{{

Plugin 'wellle/targets.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Plugin 'kana/vim-textobj-user'

" lines with the same indent level (ai/ii)
Plugin 'kana/vim-textobj-indent'

" quotes (aq/iq)
Plugin 'beloglazov/vim-textobj-quotes'

" functions (af/if)
Plugin 'kana/vim-textobj-function'
Plugin 'thinca/vim-textobj-function-javascript'

" function arguments (aa/ia)
" (somehow required one more keystroke)
Plugin 'gaving/vim-textobj-argument'

" lines with ( [ { pairs (ac/ic)
" Plugin 'Chun-Yang/vim-textobj-chunk'

" css rules (ac/ic)
Plugin 'jasonlong/vim-textobj-css'
" Plugin 'stephenway/vim-textobj-css'

" HTML/XML attributes (ax/ix)
Plugin 'whatyouhide/vim-textobj-xmlattr'

" PHP Tags (aP/iP)
Plugin 'akiyan/vim-textobj-php'

" folds (az/iz)
Plugin 'kana/vim-textobj-fold'

" git hunks (ih) (now managed by gitgutter plugin)
" Plugin 'gilligan/textobj-gitgutter'
" omap ah <plug>(textobj-gitgutter-i)
" vmap ah <plug>(textobj-gitgutter-i)

" entire buffer / 'all' (aa/ia)
Plugin 'kana/vim-textobj-entire'
let g:textobj_entire_no_default_key_mappings = 1
omap aE <plug>(textobj-entire-a)
vmap aE <plug>(textobj-entire-a)
omap iE <plug>(textobj-entire-i)
vmap iE <plug>(textobj-entire-i)
" load dynamically with :TextobjEntireDefaultKeyMappings

" note that vimtex also defines mappings ic/id/ie/i$


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

" Plugin 'google/vim-searchindex'
" Plugin 'osyo-manga/vim-anzu'


Plugin 'haya14busa/incsearch.vim'
let g:incsearch#emacs_like_keymap = 1
let g:incsearch_cli_key_mappings = {
\   "\<c-n>": {
\     'key': '<over>(buffer-complete)',
\     'noremap': 1
\   },
\   "\<c-p>": {
\     'key': '<over>(buffer-complete-prev)',
\     'noremap': 1
\   },
\ }
" TODO: <c-k> and <c-j> to scroll through old searches. use arrows until fix.

" nnoremap ö  <plug>(incsearch-forward)
" nnoremap Ö  <plug>(incsearch-backward)
nnoremap ö :call incsearch#call()<cr>
nnoremap Ö :call incsearch#call({'command': '?'})<cr>


" searching in multiple files
" install 'the_silver_searcher' package on the system
Plugin 'mileszs/ack.vim'

" command to execute
let g:ackprg="ag --vimgrep --smart-case"

" type a search pattern
nnoremap <leader>Ö :let g:jumplist = 'quickfixlist'<cr>
                 \ :Ack!<space>""<left>

" search for visual selection
xnoremap <leader>Ö y:let g:jumplist = 'quickfixlist'<cr>
                 \ :<c-u>Ack! "-Q" "<c-r>""<cr>


" % also matches HTML-tags/words etc
Plugin 'matchit.zip'


" hide (fold) everything except search string etc
Plugin 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <leader>zs :Fs<cr>
nnoremap <leader>z/ :Fs<cr>
nnoremap <leader>zö :Fs<cr>
nnoremap <leader>zz :Fs<cr>

" show word under cursor
nnoremap <leader>z* :Fw<cr>
nnoremap <leader>zw :Fw<cr>

" show visual selection
vnoremap <leader>z y:Fp<space>\V<c-r>"<cr>

" change context size (number of lines around matches)
nnoremap <leader>z+ :Fi<cr>
nnoremap <leader>zi :Fi<cr>
nnoremap <leader>z- :Fd<cr>
nnoremap <leader>zd :Fd<cr>

" restore folds
nnoremap <leader>ze :Fe<cr>
nnoremap <leader>Z  :Fe<cr>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

" (i use fzf instead)
" Plugin 'kien/ctrlp.vim'

" let g:ctrlp_map = '#'
" let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap #          :CtrlPBuffer<cr>
nnoremap <leader>#  :CtrlPRoot<cr>
nnoremap <leader>er :CtrlPMRUFiles<cr>
nnoremap <leader>em :CtrlPMixed<cr>
nnoremap <leader>eo :CtrlPRoot<cr>
nnoremap <leader>eb :CtrlPBuffer<cr>

" ignore some stuff (in addition to 'wildignore')
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<esc><enter>', '<c-l>', '<c-v>', '<rightmouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<right>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<left>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1

" only cache if we're in huge projects
let g:ctrlp_use_caching = 2000


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf - great fuzzy finder {{{
" (makes ctrlp and the ag plugin obsolete)
" (prefixing a word with ' makes it non-fuzzy)

" install 'fzf' package on the system. or:
Plugin 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }

Plugin 'junegunn/fzf.vim'


" prefix all the command names
let g:fzf_command_prefix = 'Fzf'

" layout [ down / up / left / right ]
let g:fzf_layout = { 'down': '~30%' }

" extra interactive key bindings
" (scroll with <c-k> and <c-j>
let g:fzf_action = {
  \ 'ctrl-x': 'split',
  \ 'ctrl-l': 'vsplit',
  \ 'ctrl-v': 'vsplit',
  \ }
" \ 'ctrl-k': 'previous-history',
" \ 'ctrl-j': 'next-history',

" enable per-command history
" (scroll through history with <c-p> and <c-n>)
let g:fzf_history_dir = '~/.local/share/fzf-history'

" override command to only match content (not filenames)
command! -bang -nargs=* FzfAg
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')
  \                         : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:50%:hidden', '?'),
  \                 <bang>0)

" open files by name
nnoremap <leader>fi :FzfFiles<cr>
nnoremap <leader>fl :FzfLocate<space>
nnoremap #          :FzfBuffers<cr>
xnoremap #          <esc>:FzfBuffers<cr>
nnoremap <leader>#  :FzfFiles<cr>
xnoremap <leader>#  <esc>:FzfFiles<cr>
nnoremap <leader>eo :FzfGFiles<cr>
nnoremap <leader>eg :FzfGFiles?<cr>
nnoremap <leader>er :FzfHistory<cr>
nnoremap <leader>eb :FzfBuffers<cr>

let g:fzf_tags_command = 'ctags -R -f .tags'
nnoremap <leader>et  :FzfTags<cr>
xnoremap <leader>et y:FzfTags <c-r>"<cr>

" type a search pattern
nnoremap <leader>ö :FzfAg<cr>
" search for word under cursor
nnoremap <leader>+ :FzfAg! <c-r><c-w><cr>
nmap     <leader>* <leader>+
" search for visual selection
xnoremap <leader>ö y:<c-u>FzfAg! <c-r>"<cr>
xmap     <leader>* <leader>ö
xmap     <leader>+ <leader>ö

" fuzzy search for built-in vim stuff (command history, searches, helptags)
nnoremap <leader>:          :FzfHistory:<cr>
nnoremap <leader>/          :FzfHistory/<cr>
nnoremap <leader>h<leader>  :FzfHelptags<cr>

" autocomplete lines like a boss, even across multiple files
imap <c-x><c-l> <plug>(fzf-complete-line)


" adjust colors to colorscheme: gruvbox
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plugin 'Shougo/vimproc.vim'
"Plugin 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) {{{

" install 'ctags' package on the system

" generate tag file manually
" (fails with '–exclude=@.gitignore' when the file does not exist!)
nnoremap <leader>eT :!ctags -R -f .tags .<cr>


" generate tag file automagically
Plugin 'craigemery/vim-autotag'

let g:autotagTagsFile=".tags"



Plugin 'majutsushi/tagbar'

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <leader>tt :TagbarToggle<cr>

"autocmd FileType vim nested :TagbarOpen()<cr>



" jump to definitions without relying on tags
" Plugin 'misterbuckley/vim-definitive'
Plugin 'sflip/vim-definitive'

nnoremap <leader>fd :FindDefinition<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file management {{{

" sugar for unix shell commands like move/rename/delete/find files etc.
Plugin 'tpope/vim-eunuch'

nnoremap <leader>rn :Rename <c-r>=expand("%:t")<cr>
nnoremap <leader>rm :Remove<cr>


" Plugin 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show nerdtree from current file
noremap <silent> <leader>tn :NERDTreeFind<cr>
" show/hide nerdtree
noremap <silent> <leader>tN :NERDTreeToggle<cr>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'


" pimp netrw
" Plugin 'tpope/vim-vinegar'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" close all other buffers {{{

Plugin 'vim-scripts/BufOnly.vim'

nmap <leader>qo :BufOnly<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

" Plugin 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex", "scala"] }
" let g:syntastic_cpp_compiler = 'clang++'
" let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_c_cppcheck_args = ' -std=c++11 -stdlib=libc++'

nnoremap <silent> <leader>sc :SyntasticCheck<cr>
nnoremap <silent> <leader>sr :SyntasticReset<cr>
nnoremap <silent> <leader>st :SyntasticToggleMode<cr>
nnoremap <silent> <leader>si :SyntasticInfo<cr>


" install linters on the system:
" - pylint
" - jslint / jshint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)
" - fsc
" - scalac
" - shellcheck

let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']
" let g:syntastic_javascript_checkers = ['eslint', 'jshint', 'jslint']
let g:syntastic_javascript_checkers = ['eslint', 'jshint']
let g:syntastic_scala_checkers = ['fsc']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mFile is being conditionally included;',
            \ '\mFile is being unconditionally included;',
            \ '\mLine indented incorrectly;.*',
            \ '\mMulti-line IF statement not indented correctly;.*',
            \ '\mEach line in a multi-line IF statement must begin with a boolean operator.*',
            \ '\mSpace after opening parenthesis of function call prohibited.*',
            \ '\mExpected 0 spaces before closing bracket; .* found.*',
            \ '\mExpected \\"foreach (...) {\\n\\"; found \\"foreach(...) {\\n\\".*',
            \ '\mExpected \\"if (...) {\\n\\"; found \\"if(...) {\\n\\".*',
            \ '\mExpected \\"} elseif (...) {\\n\\"; found \\"} elseif(...) {\\n\\".*',
            \ '\mOpening brace should be on a new line.*',
            \ '\mBad line breaking before .+..',
            \ '\mInline control structures are discouraged',
            \ '\mClosing parenthesis of a multi-line IF statement must be on a new line',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mDon.t use adjoining classes.',
            \ '\mDon.t use IDs in selectors.',
            \ '\mHeading (h.) should not be qualified.',
            \ '\mShort PHP opening tag used;',
            \ '\m.$. was used before it was defined.',
            \ '\mpossible unwanted space at "{"',
            \ '\mFunction name .* is prefixed with a package name but does not begin with a capital letter',
            \ '\m.$. was used before it was defined.'
            \ ] }



" asynchronous alternative to syntastic
Plugin 'w0rp/ale'

let g:ale_list_window_size = 5
let g:ale_lint_on_enter = 0
let g:ale_fixers = {
\   'javascript': ['eslint'],
\}

let g:ale_python_pylint_options = '--rcfile $HOME/.vim/config/pylint.rc'

nnoremap <silent> <leader>sc :ALELint<cr>
nnoremap <silent> <leader>sn :ALENext<cr>
nnoremap <silent> <leader>sN :ALEPrevious<cr>
nnoremap <silent> <leader>sp :ALEPrevious<cr>
nnoremap <silent> <leader>sr :ALEDisable<cr>
nnoremap <silent> <leader>st :ALEToggle<cr>
nnoremap <silent> <leader>si :ALEInfo<cr>

highlight ALEErrorSign      ctermfg=203
highlight ALEWarningSign    ctermfg=227
highlight ALEInfoSign       ctermfg=227


" evaluate expression live, which is awesome
" Plugin 'metakirby5/codi.vim'



" lookup stuff
Plugin 'dbeniamine/cheat.sh-vim'

let g:CheatSheetDefaultMode=0

let g:CheatSheetDoNotMap=1

" use line as query and paste result after line
nnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 3, '!')<cr>
vnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", -1, -1, 3, 1, '!')<cr>


"result in buffer
nnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 0, '!')<cr>
vnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", -1, -1, 2, 0, '!')<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" read the docs {{{

Plugin 'thinca/vim-ref'

":Ref STUFF



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" text editing {{{


" replace some motion or text object or selection with current yank
" Plugin 'ReplaceWithRegister'
" nmap -rr <plug>ReplaceWithRegisterOperator
" nmap -re <plug>ReplaceWithRegisterLine
" xmap -r  <plug>ReplaceWithRegisterVisual
" I DON'T REALLY USE THIS BUT v3wp or -rw OCCASIONALLY


" preview register contents
Plugin 'junegunn/vim-peekaboo'


" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plugin 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <leader>pp <plug>yankstack_substitute_older_paste
nmap <leader>nn <plug>yankstack_substitute_newer_paste
"call yankstack#setup() " DOES NOT WORK HERE


" add and toggle comments with <leader>c<space> etc
Plugin 'scrooloose/nerdcommenter'
" use leading space, but delete trailing space
let g:NERDSpaceDelims = 1
let g:NERDTrimTrailingWhitespace = 1
" do not nest by default
let g:NERDDefaultNesting = 1
let g:NERDAltDelims_javascript = 0
" align multiline comments
let g:NERDDefaultAlign = 'left'
" nmap -c <leader>c
" xmap -c <leader>c
" comment text objects and movements
for mov in ['j', 'k', 'gg', 'G', '(', ')', '{', '}', 'as', 'is', 'ap', 'ip']
    exe "nmap \<leader\>c" . mov . " V" . mov . "\<plug\>NERDCommenterInvert"
    exe "nmap -c"          . mov . " V" . mov . "\<plug\>NERDCommenterComment"
endfor
for i in range(1, 50)
    exe "nmap \<leader\>c" . i . "j V" . i . "j\<plug\>NERDCommenterInvert"
    exe "nmap \<leader\>c" . i . "k V" . i . "k\<plug\>NERDCommenterInvert"
    exe "nmap -c"          . i . "j V" . i . "j\<plug\>NERDCommenterComment"
    exe "nmap -c"          . i . "k V" . i . "k\<plug\>NERDCommenterComment"
endfor
" duplicate a line and comment out the first one
nmap <leader>cd <leader>cyp
" do not comment on new lines (except when already in insert mode)
nnoremap o o<esc>S
nnoremap O O<esc>S


" automagically add closing braces etc
Plugin 'Raimondi/delimitMate'


" add a ; at the end of a line
"Plugin 'lfilho/cosco.vim'
"inoremap <silent> <esc><enter> <esc>:call cosco#commaOrSemiColon()<cr>A<enter>
inoremap <silent> <esc><enter> <esc>A;<esc>^


" add/change/delete quotes/braces/... and more
Plugin 'tpope/vim-surround'

" surround consistently in both modes and more comfortably on german keyboard
nmap -s ys
vmap -s S

" surround with quotes/parentheses/brackets quickly
vmap -q S'
vmap -Q S"
nmap -q ysiw'
nmap -Q ysiw"
vmap -b S)
vmap -B S}
nmap -b ysiw)
nmap -B ysiw}
nmap dq ds'
nmap dQ ds"

" toggle quotes {{{
function! ToggleQuotesWithVimSurround()
    let pos_cursor = getpos(".")[2]
    let linepart   = strpart(getline("."), pos_cursor - 1)
    let pos_single = stridx(linepart, "'")
    let pos_double = stridx(linepart, '"')
    if pos_single >= 0 && (pos_double < 0 || pos_single < pos_double)
        normal cs'"
    elseif pos_double >= 0 && (pos_single < 0 || pos_double < pos_single)
        normal cs"'
    endif
endfunction
" }}}
nnoremap <silent> -tq :call ToggleQuotesWithVimSurround()<cr>


" swap ('transpose') two words or arbitrary things
Plugin 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <leader>x <plug>(Exchange)
xmap <leader>x <plug>(Exchange)
nmap <leader>xc <plug>(ExchangeClear)
nmap <leader>xl <plug>(ExchangeLine)
nmap <leader>xx <leader>xiw


" " find and replace tool for multiple files (IDE like)
" " (helptags are buggy according to vundle)
" Plugin 'brooth/far.vim'
" nnoremap <leader>SS :Far  **<left><left><left>
" vnoremap <leader>SS :Far *  **<left><left><left>
" nnoremap <leader>SD :Fardo<cr>


" " add "printf" statements with shortcut
" Plugin 'bergercookie/vim-debugstring'

" nmap <leader>ad <plug>DumpDebugString



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" multiple cursor like in Sublime {{{

" SEEMS NOT TO WORK PROPERLY FOR ME

" Plugin 'terryma/vim-multiple-cursors'

" let g:multi_cursor_use_default_mapping=0

" " (only single keystrokes are possible at the moment)
" let g:multi_cursor_next_key='<c-n>'
" let g:multi_cursor_prev_key='<c-p>'
" let g:multi_cursor_skip_key='<c-x>'
" let g:multi_cursor_quit_key='<esc>'
" nnoremap -<c-c> :call multiple_cursors#quit()<cr>

" let g:multi_cursor_exit_from_visual_mode=1
" let g:multi_cursor_exit_from_insert_mode=0


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better diff {{{

Plugin 'AndrewRadev/linediff.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" run make or jobs asynchronously {{{

Plugin 'tpope/vim-dispatch'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better quickfix window {{{

" edit quickfix list (make changes directly after global search or linting)
Plugin 'Olical/vim-enmasse'


" automatically resize quickfix window
Plugin 'blueyed/vim-qf_resize'

let g:qf_resize_min_height = 1
let g:qf_resize_max_height = 8


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plugin 'shinokada/dragvisuals.vim'
"vmap <expr> <c-h>  DVB_Drag('left')
"vmap <expr> <c-l>  DVB_Drag('right')
"vmap <expr> <c-j>  DVB_Drag('down')
"vmap <expr> <c-k>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plugin 'zirrostig/vim-schlepp'

vmap <up>    <plug>SchleppUp
vmap <down>  <plug>SchleppDown
vmap <left>  <plug>SchleppLeft
vmap <right> <plug>SchleppRight

" duplicate
" (delete selection with x. by default, x and d do the same)
vmap -u <plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plugin 'vim-scripts/toggle_words.vim'

noremap <silent> -tw :ToggleWord<cr>

let g:toggle_words_dict = {
            \ 'css': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['header', 'footer'],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ['0', '1'],
            \     ['add', 'remove'],
            \     ['and', 'or'],
            \     ['ascending', 'descending'],
            \     ['authentication', 'authorization'],
            \     ['ASC', 'DESC'],
            \     ['begin', 'end'],
            \     ['big', 'little'],
            \     ['black', 'white'],
            \     ['clean', 'dirty'],
            \     ['create', 'delete'],
            \     ['dark', 'light'],
            \     ['deep', 'shallow'],
            \     ['dynamic', 'static'],
            \     ['enable', 'disable'],
            \     ['enabled', 'disabled'],
            \     ['fast', 'slow'],
            \     ['fat', 'thin'],
            \     ['first', 'last'],
            \     ['forward', 'backward'],
            \     ['get', 'set'],
            \     ['good', 'bad'],
            \     ['happy', 'sad'],
            \     ['hard', 'soft'],
            \     ['head', 'tail'],
            \     ['hide', 'show'],
            \     ['high', 'low'],
            \     ['header', 'footer'],
            \     ['in', 'out'],
            \     ['initialize', 'terminate'],
            \     ['initialization', 'termination'],
            \     ['inner', 'outer'],
            \     ['left', 'right'],
            \     ['light', 'dark'],
            \     ['local', 'global'],
            \     ['long', 'short'],
            \     ['love', 'hate'],
            \     ['many', 'few'],
            \     ['master', 'slave', 'develop'],
            \     ['min', 'max'],
            \     ['more', 'less'],
            \     ['new', 'old'],
            \     ['next', 'previous'],
            \     ['on', 'off'],
            \     ['online', 'offline'],
            \     ['open', 'close'],
            \     ['present', 'absent'],
            \     ['question', 'answer'],
            \     ['red','orange','yellow','green','blue','purple'],
            \     ['setup', 'teardown'],
            \     ['single', 'double', 'multi'],
            \     ['start', 'stop'],
            \     ['started', 'stopped'],
            \     ['starting', 'stopping'],
            \     ['strong', 'weak'],
            \     ['testing', 'production'],
            \     ['this', 'that'],
            \     ['top', 'bottom'],
            \     ['true', 'false'],
            \     ['up', 'down'],
            \     ['wide', 'narrow'],
            \     ['width', 'height'],
            \     ['write', 'read'],
            \     ['yes', 'no'],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plugin 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger='<c-k>'
"let g:UltiSnipsListSnippets='<esc>.'
let g:UltiSnipsJumpForwardTrigger='<c-i>'
let g:UltiSnipsJumpBackwardTrigger='<c-o>'
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'sflipsnippets']


" snippet packs
Plugin 'honza/vim-snippets'


" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced autocompletion engine {{{
"
" Remember: YCM is a plugin with a compiled component. If you update YCM using
" Vundle and the ycm_support_libs library APIs have changed (happens rarely),
" YCM will notify you to recompile it. You should then rerun the install
" process.

" Plugin 'Valloric/YouCompleteMe'
" let g:ycm_server_python_interpreter = '/usr/bin/python3'
" let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
let g:ycm_key_invoke_completion = '<esc>.'
let g:ycm_key_list_select_completion   = ['<c-n>', '<down>', '<tab>', '<enter>']
let g:ycm_key_list_previous_completion = ['<c-p>', '<up>']
" let g:ycm_show_diagnostics_ui = 0


" autocompletion in command mode
Plugin 'vim-scripts/CmdlineComplete'
cmap <c-p> <plug>CmdlineCompleteBackward
cmap <c-n> <plug>CmdlineCompleteForward


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" generate docs {{{

" generate javascript docs
Plugin 'heavenshell/vim-jsdoc'
" nnoremap <silent> -adj ?function<cr>:noh<cr><plug>(jsdoc)
nnoremap <silent> -adj :JsDoc<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

" show indentation level
Plugin 'Yggdroot/indentLine'
let g:indentLine_enabled = 1
let g:indentLine_char = '┊'
nnoremap <leader>yI :IndentLinesToggle<cr>

" Does not work. TODO: Fix it!
augroup indentline_enabled
    au!
    au BufWinEnter */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ IndentLinesDisable
                " \ echo 'jaaa' | IndentLinesDisable
augroup END


" align plugin
Plugin 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-L=)
xmap -L <plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -LG=)
nmap -L <plug>(EasyAlign)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

Plugin 'Chiel92/vim-autoformat'

" install formatters on the system:
" - js-beautify (for HTML, CSS, JavaScript, JSON)
" - scalafmt (for scala)

nnoremap -af :Autoformat<cr>:GitGutter<cr>
vnoremap -af :Autoformat<cr>:GitGutter<cr>
nmap <leader>af -af
vmap <leader>af -af

let g:formatdef_scalafmt = "'scalafmt --stdin 2>/dev/null'"
let g:formatters_scala = ['scalafmt']


" autoformat for json does not work out with the plugin above. do this instead:
augroup json_map_autoformat
    au!
    au FileType json nnoremap -af :%!python -m json.tool<cr>
    au FileType json nmap <leader>af -af
augroup END



" change wrapping of function arguments
Plugin 'FooSoft/vim-argwrap'

nnoremap <silent> -tf :ArgWrap<cr>



" coercion:
" - MixedCase (crm),
" - camelCase (crc),
" - snake_case (crs),
" - UPPER_CASE (cru),
" - dash-case (cr-),
" - dot.case (cr.),
" - space case (cr<space>),
" - Title Case (crt)
Plugin 'tpope/vim-abolish'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" don't worry about 'shiftwidth' and 'expandtab' etc. {{{

Plugin 'tpope/vim-sleuth'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plugin 'vim-scripts/ShowTrailingWhiteSpace'
let g:ShowTrailingWhitespace = 1
command! -bar ShowTrailingWhitespaceOn  call ShowTrailingWhitespace#Set(1,1)
command! -bar ShowTrailingWhitespaceOff call ShowTrailingWhitespace#Set(0,1)
command! -bar ShowTrailingWhitespaceToggle call ShowTrailingWhitespace#Toggle(0)
        \ <bar>echo (ShowTrailingWhitespace#IsSet() ?
        \ 'Show trailing whitespace' : 'Not showing trailing whitespace')
nnoremap <silent> <leader>yA  :ShowTrailingWhitespaceToggle<cr>
nnoremap <silent> <leader>yst :ShowTrailingWhitespaceToggle<cr>

" (has a bug)
"Plugin 'vim-scripts/JumpToTrailingWhiteSpace'


Plugin 'vim-scripts/DeleteTrailingWhiteSpace'

" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'ask'

" enable/disable plugin
nnoremap <leader>dst :let g:DeleteTrailingWhitespace = 1 - g:DeleteTrailingWhitespace<cr>
            \ :echo g:DeleteTrailingWhitespace == 1 ?
            \ 'DeleteTrailingWhitespace enabled' :
            \ 'DeleteTrailingWhitespace disabled'<cr>
" delete trailing whitespace for selected line
vnoremap <silent> -dst :DeleteTrailingWhitespace<cr>
" delete trailing whitespace for whole buffer
nnoremap <silent> -dst :%DeleteTrailingWhitespace<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make #DD8844 appear orange etc
Plugin 'ap/vim-css-color'

" launch colorpicker and insert color code
Plugin 'blindFS/vim-colorpicker'
nnoremap <leader>icp :ColorPicker<cr>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plugin 'KabbAmine/vCoolor.vim'
"nnoremap <leader>cp :VCoolor<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Language specific stuff {{{


Plugin 'sheerun/vim-polyglot'



" Language: fish

Plugin 'dag/vim-fish'


" Language: javascript

augroup javascript_on_read
    au!
    au FileType javascript call SetupJavascript()
augroup END
function! SetupJavascript()
    nnoremap <leader>bi  :call VimuxRunCommand("npm install")<cr>
    nnoremap <leader>bs  :call VimuxRunCommand("npm start")<cr>
    nnoremap <leader>btt :call VimuxRunCommand("npm test")<cr>
    nnoremap <leader>btu :call VimuxRunCommand("npm test-unit")<cr>
    nnoremap <leader>bti :call VimuxRunCommand("npm test-int")<cr>
endfunction


" Language: LaTeX

Plugin 'lervag/vimtex'

let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'
let g:vimtex_quickfix_ignore_all_warnings=1
let g:vimtex_quickfix_mode=0

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

augroup map_latex
    au!
    au FileType latex nnoremap <leader>bl :VimtexCompileToggle<cr>
augroup END


" Language: PHP

augroup php_on_read
    au!
    au FileType php call SetupPHP()
augroup END
function! SetupPHP()
    nnoremap <leader>bi  :call VimuxRunCommand("composer install")<cr>
    nnoremap <leader>bu  :call VimuxRunCommand("composer update")<cr>
    nnoremap <leader>btt :call VimuxRunCommand("composer test")<cr>
    nnoremap <leader>btu :call VimuxRunCommand("composer test")<cr>
endfunction


" Language: python

augroup python_on_read
    au!
    au FileType python call SetupPython()
augroup END
function! SetupPython()
    nnoremap <leader>bs  :call VimuxRunCommand("python " . expand('%'))<cr>
    nnoremap <leader>b2  :call VimuxRunCommand("python2 " . expand('%'))<cr>
    nnoremap <leader>b3  :call VimuxRunCommand("python3 " . expand('%'))<cr>
endfunction


" Language: R

if v:version > 704 || v:version == 704 && has("patch1829")
    Plugin 'jalvesaq/Nvim-R'
    " use with tmux
    let R_in_buffer = 0
    let R_applescript = 0
    let R_tmux_split = 1
    let R_vsplit = 1
    let R_rconsole_width = 80
    " custom keybindings
    let R_user_maps_only = 1
    augroup NvimR
        au!
        au FileType r nmap <c-r>s           <plug>RStart
        au FileType r nmap <c-r>q           <plug>RClose
        au FileType r nmap <c-r><c-l>       <plug>RClearConsole
        au FileType r nmap <leader><enter>  <plug>RSendFile
        au FileType r nmap <enter>          <plug>RSendLine
        au FileType r xmap <enter>          <plug>RSendSelection
    augroup END
endif


" Language: Scala

" Plugin 'ervandew/eclim'

" start eclipse
noremap <leader>aea :Start! /usr/lib/eclipse/eclimd<cr>
" test connection to eclipse
noremap <leader>aep :PingEclim<cr>
noremap <leader>aev :EclimValidate<cr>
" shutdown eclipse
noremap <leader>aeo :ShutdownEclim<cr>

" automated imports
noremap <leader>aei :ScalaImport<cr>

" goto definition
noremap <leader>ae<return> :ScalaSearch<cr>



Plugin 'derekwyatt/vim-scala'
Plugin 'derekwyatt/vim-sbt'
Plugin 'mdreves/vim-scaladoc'
nnoremap <leader>sd :call scaladoc#Search(expand("<cword>"))<cr>

" Plugin 'ensime/ensime-sbt', { 'branch': '2.0', 'for': 'scala' }
" Plugin 'ensime/ensime-server', { 'branch': '2.0', 'for': 'scala' }
" Plugin 'ensime/ensime-vim', { 'for': 'scala' }
" augroup map_scala
    " au!
    " au FileType scala
                " \ nnoremap <leader>9d :EnDeclaration<cr> |
                " \ nnoremap <leader>9D :EnDeclarationSplit v<cr> |
                " \ nnoremap <leader>9x :EnDocBrowse<cr> |
                " \ nnoremap <leader>9t :EnType<cr> |
                " \ " nnoremap <leader>9t :EnInspectType<cr> |
                " \ nnoremap <leader>9T :EnTypeCheck<cr> |
                " \ nnoremap <leader>9ö :EnSearch<space> |
                " \ nnoremap <leader>9r :EnRename<cr> |
                " \ nnoremap <leader>9i :EnOrganizeImports<cr> |
                " \ nnoremap <leader>9I :EnSugestImport<cr> |
                " \ nnoremap <leader>9 <nop>
" augroup END

" scala and ctags:
" https://advancedweb.hu/2017/01/10/vim-scala-ag-ctags/
" plugin that also creates ctags for libaries (can be slow and huge files):
" Plugin 'ceedubs/sbt-ctags'

" show sbt errors in the quickfix window
" Plugin 'dscleaver/sbt-quickfix'
" (does not work and is not necessary: https://gist.github.com/nkpart/5945278)

" :!sbt -Dsbt.log.noformat=true compile 2>&1 >/tmp/sbt.out
" let g:cfile = system('ag -l "\[(error|warn)\]" target/streams/ | head -n 1')
" let g:cfile_escaped = substitute(g:cfile, "\\$", "\\\\$", "g")

augroup scala_on_read
    au!
    au FileType scala call SetupScala()
augroup END
function! SetupScala()
    let l:sbt_version = system('grep -E "sbt\.version" project/build.properties | sed -E "s/.*=(.*)/\1/"')
    " sbt shows column in compiler errors since version 1.0.0 so there are two " cases for errorformat:
    if l:sbt_version
        set errorformat=
                    \%E\ %#[error]\ %f:%l:%c:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:%c:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    else
        set errorformat=
                    \%E\ %#[error]\ %f:%l:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    endif
    " the lines above work for compiler errors
    " the lines below are for testing errors but do not work yet
    " (for example because the file path is not absolute)
    " (also, I'm a noob with the efm matching syntax)
                " \%E\ \%#[info]%.%#was\ not\ equal\ to%.%#(%f:%l),%Z,
                " \%E\ \%#[info]\ %.%#\ was\ not\ equal\ to\ %.%#\ (%f:%l),%Z,
                " \%E\ %#[info]\ %.%#\ ***\ FAILED\ ***,%C\ %#[info]\ %m\ (%f:%l)%Z,
    match ErrorMsg '\*\*\* FAILED \*\*\*'
    nnoremap <leader>bd  :call MakeWithVimux("sbt compile")<cr>
    nnoremap <leader>bs  :call MakeWithVimux("sbt run")<cr>
    nnoremap <leader>btt :call MakeWithVimux("sbt test it:test")<cr>
    nnoremap <leader>btu :call MakeWithVimux("sbt test")<cr>
    nnoremap <leader>bti :call MakeWithVimux("sbt it:test")<cr>
    nnoremap <leader>bto :call MakeWithVimux("sbt '". CalculateSbtTestOnlyCommand() . "'")<cr>
    nnoremap <leader>bx  :call MakeWithVimux("sbt clean")<cr>
    nnoremap <leader>br  :call MakeWithVimux("sbt console")<cr>
    nnoremap <leader>bD  :call VimuxRunCommand("sbt compile")<cr>
    nnoremap <leader>bS  :call VimuxRunCommand("sbt run")<cr>
    nnoremap <leader>btT :call VimuxRunCommand("sbt test it:test")<cr>
    nnoremap <leader>btU :call VimuxRunCommand("sbt test")<cr>
    nnoremap <leader>btI :call VimuxRunCommand("sbt it:test")<cr>
    nnoremap <leader>btO :call VimuxRunCommand("sbt '". CalculateSbtTestOnlyCommand() . "'")<cr>
    nnoremap <leader>bE  :call MakeWithVimuxOpenErrors('buffer')<cr>gg/\*\*\* FAILED \*\*\*<cr>
    nnoremap <leader>fe  /\*\*\* FAILED \*\*\*<cr>
endfunction
command! -bang SetupScala :call SetupScala()

function! CalculateSbtTestOnlyCommand()
    let lines_that_match_package = GetMatches('^package.*', 1, line('$'))
    let lines_that_match_class   = GetMatches('^class.*', 1, line('$'))
    if len(lines_that_match_package) == 0 || len(lines_that_match_class) == 0
        echoerr "Could not find class name."
        return  1
    endif
    let package  = substitute(lines_that_match_package[0], '^package\s\+\(\w\+\)', '\1', '')
    let class    = substitute(lines_that_match_class[0], '^class\s\+\(\w\+\).*', '\1', '')
    let itPrefix = match(@%, '.*/it/.*') == -1 ? '' : 'it:'
    return itPrefix . "testOnly " . package . "." . class
endfunction

" augroup scala_on_write
    " au!
    " au BufWritePost *.scala Dispatch! sbt -Dsbt.log.noformat=true parse
" augroup END


" TODO: find fzf scala docs


" Language: SQL
augroup sql_on_read
    au!
    au FileType sql call SetupSQL()
augroup END
function! SetupSQL()
    nnoremap <leader>bm  :call VimuxRunCommand("\\. " . expand('%:p'))<cr>
    nnoremap <leader>bp  :call VimuxRunCommand("\\i " . expand('%:p'))<cr>
endfunction


Plugin 'tpope/vim-db'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plugin 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <leader>ut :GundoToggle<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    " finish vundle
    call vundle#end()
    filetype plugin indent on

    " THE FOLLOWING MUST BE EXECUTED AFTER VUNDLE FINISHED:

    " call camelcasemotion#CreateMotionMappings(',')

    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping)
    call yankstack#setup()

    " fix s mapping
    " (must be executed after yankstack#setup())
    nmap s <plug>Sneak_S


endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" options {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=1200

" always assume modern terminal
set ttyfast
" don't draw everything (e.g. when playing macros)
set ttyfast
set lazyredraw

" allow mouse usage for bad days
if has('mouse')
    set mouse=a
endif

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8
" <eol> line ending philosophies to try
" set fileformats=unix,dos,mac

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread

" automatically save buffer when it loses focus
if s:MyMode == 'mastery'
    let g:autosave = 1
else
    let g:autosave = 0
endif
augroup autosave
    au!
    au BufLeave,FocusLost * if (g:autosave && !exists("b:local_autosave"))
                          \ || (g:autosave && exists("b:local_autosave") && b:local_autosave)
                          \ || (!g:autosave && exists("b:local_autosave") && b:local_autosave)
    au BufLeave,FocusLost *     silent! update
    au BufLeave,FocusLost * endif
augroup END

" automatically change working directory to current file
" set autochdir

" command history size
set history=9999

" do not create swap files (they annoy me more than they help)
set noswapfile

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" meta files (like tagfiles)
set tags+=.tags

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable
let g:synmaxcol=300
exe 'set synmaxcol=' . g:synmaxcol

" highlight matching bracket when typing
" set showmatch
" set matchtime=4

" do not wrap lines until I say so
set nowrap

" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = 0
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter,FocusLost   * set nocursorline nocursorcolumn
    au WinEnter,InsertLeave,FocusGained * if g:cursorposition
    au WinEnter,InsertLeave,FocusGained *     set cursorline cursorcolumn
    au WinEnter,InsertLeave,FocusGained * endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2
set noshowmode

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignorecase
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
set wildignore+=*.o,*.obj,*.pyc,*.class
set wildignore+=*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.odt,*.ods
set wildignore+=*.jpg,*.jpeg,*.png
set wildignore+=*.mp3,*.mp4,*.mpg,*.mpeg,*.flv,*.wav
set wildignore+=*.aux,*.bbl,*.blg,*.fdb_latexmk,*.fls,*.loe,*.lof,*.out,*.toc

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=5
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
set gdefault
set nohlsearch
set nowrapscan

" allow the cursor to move where there is no character
set virtualedit=block,insert,onemore


" characters to show in list mode
if v:version > 704 || v:version == 704 && has("patch711")
    set listchars=space:·,tab:--,extends:❯,precedes:❮
else
    set listchars=tab:--,extends:❯,precedes:❮
endif

" how it looks like if we wrap lines
if v:version > 704 || v:version == 704 && has("patch338")
    set breakindent
endif
set showbreak=↪

" how other stuff looks like
set fillchars+=vert:\ "
set fillchars+=fold:─

" use 4 spaces instead of tabs
" (otherwise handled by sleuth)
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" 1 space, not 2, when joining sentences
set nojoinspaces

" allow <bs> to delete everything
set backspace=indent,eol,start

" when incrementing numbers with leading zeros, don't interpret them as octal
set nrformats-=octal

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright



" }}}


" colorscheme {{{

if s:MyMode == 'mastery'

    " DARK THEMES

    set background=dark

    " colorscheme apprentice
    " colorscheme badwolf
    " colorscheme blackboard
    " colorscheme blacklight
    " colorscheme candycode
    " colorscheme dante
    " colorscheme desertEx
    colorscheme gruvbox
    " colorscheme iceberg
    " colorscheme jellybeans
    " colorscheme luna-term
    " colorscheme meta5
    " colorscheme materialbox
    " colorscheme molokai
    " colorscheme onedark
    " colorscheme pride
    " colorscheme seoul256
    " colorscheme Tomorrow-Night
    " colorscheme up
    " colorscheme woju

    let g:airline_theme='base16'
    " let g:airline_theme='base16_summerfruit'
    " let g:airline_theme='base16_grayscale'
    " let g:airline_theme='behelit'
    " let g:airline_theme='distinguished'
    " let g:airline_theme='kalisi'
    " let g:airline_theme='laederon'
    " let g:airline_theme='lucius'
    " let g:airline_theme='minimalist'
    " let g:airline_theme='raven'
    " let g:airline_theme='serene'
    " let g:airline_theme='tomorrow'
    " let g:airline_theme='ubaryd'
    " let g:airline_theme='wombat'
    " let g:airline_theme='zenburn'

    let g:indentLine_setColors = 1
    let g:indentLine_color_term = 236

    highlight CursorLine              ctermbg=236 cterm=NONE
    highlight CursorColumn            ctermbg=236
    highlight ColorColumn             ctermbg=237
    highlight DiffAdd                 ctermbg=234
    highlight DiffDelete              ctermbg=234
    highlight DiffChange              ctermbg=234
    highlight DiffText                ctermbg=233
    highlight ShowTrailingWhitespace  ctermbg=235
    highlight VertSplit               ctermfg=238
    highlight Folded                  ctermfg=238 ctermfg=248
    highlight LineNr                  ctermbg=237 ctermfg=243
    " highlight SignColumn              ctermbg=237
    " highlight GitGutterAdd            ctermbg=235
    " highlight GitGutterChange         ctermbg=235
    " highlight GitGutterDelete         ctermbg=235
    " highlight GitGutterChangeDelete   ctermbg=235
    highlight Conceal                 ctermbg=237
    " highlight Search                  ctermbg=237 ctermfg=white
    highlight Error                   ctermbg=162
    highlight Todo                    ctermfg=132
    highlight EasyMotionTarget        ctermfg=72
    highlight EasyMotionTarget2First  ctermfg=72
    highlight EasyMotionTarget2Second ctermfg=108


    " LIGHT THEMES

    " set background=light

    " colorscheme lucius
    " colorscheme peaksea
    " colorscheme seoul256-light
    " colorscheme Tomorrow-Night

    " let g:airline_theme='bubblegum'
    " let g:airline_theme='lucius'
    " let g:airline_theme='sol'

    " highlight CursorLine   ctermbg=252
    " highlight CursorColumn ctermbg=252
    " highlight ColorColumn  ctermbg=250
    " highlight ShowTrailingWhitespace ctermbg=250

else

    " fallback colorscheme
    colorscheme desert

    let g:cursorposition = 0
    set nocursorcolumn nocursorline
    highlight CursorLine   ctermbg=233
    highlight CursorColumn ctermbg=233
    highlight ColorColumn  ctermbg=233

endif

" }}}




" cursor change in insert mode (from block to i-beam) {{{

" http://stackoverflow.com/questions/6488683/how-do-i-change-the-vim-cursor-in-insert-normal-mode

" escape sequence depends on the terminal ('konsole', 'urxvt')
let terminal='urxvt'



if terminal == 'konsole'
    " (this also resets the terminal font size, which is annoying)
    if exists('$TMUX')
        let &t_SI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=1\x7\<esc>\\"
        let &t_EI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=0\x7\<esc>\\"
    else
        let &t_SI = "\<esc>]50;CursorShape=1\x7"
        let &t_EI = "\<esc>]50;CursorShape=0\x7"
    endif
elseif terminal == 'urxvt'
    let &t_SI = "\e[6 q"
    let &t_EI = "\e[2 q"
endif



" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" URL encode a string. ie. Percent-encode characters as necessary. {{{
function! UrlEncode(string)

    let result = ""

    let characters = split(a:string, '.\zs')
    for character in characters
        if character == " "
            let result = result . "+"
        elseif CharacterRequiresUrlEncoding(character)
            let i = 0
            while i < strlen(character)
                let byte = strpart(character, i, 1)
                let decimal = char2nr(byte)
                let result = result . "%" . printf("%02x", decimal)
                let i += 1
            endwhile
        else
            let result = result . character
        endif
    endfor

    return result

endfunction

" Returns 1 if the given character should be percent-encoded in a URL encoded
" string.
function! CharacterRequiresUrlEncoding(character)

    let ascii_code = char2nr(a:character)
    if ascii_code >= 48 && ascii_code <= 57
        return 0
    elseif ascii_code >= 65 && ascii_code <= 90
        return 0
    elseif ascii_code >= 97 && ascii_code <= 122
        return 0
    elseif a:character == "-" || a:character == "_" || a:character == "." || a:character == "~"
        return 0
    endif

    return 1

endfunction

" }}}


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" toggle syntax highlighting {{{
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction
" }}}


" get a list of buffers {{{
function! GetBufferList()
  silent! redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction
" }}}


" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}


" return 1 iff the active window contains a quickfix buffer and there are no
" other windows with normal buffers.
function! IsOrphanQuickfixList()
    let winnr = winnr("$")
    while winnr >= 1
        if getbufvar(winbufnr(winnr), "&buftype") == ""
            return 0
        endif
        let winnr -=1
    endwhile
    return getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"
endfunction
" improve quickfix/location list
augroup quickfix
    au!
    " automatically close quickfix/location list when alone
    au BufEnter * if IsOrphanQuickfixList()
    au BufEnter *     bdelete
    au BufEnter * endif
augroup END




" make columns after &textwidth visible or invisible {{{
function! SetColorColumn(mode)
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if (&colorcolumn == "" || &colorcolumn != expr) && a:mode == 'toggle' || a:mode == "on"
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}

"... and call this function when &textwidth is changed
if v:version > 704 || v:version == 704 && has("patch786") " if has ('patch-7.4.786')
    augroup colorcolumn
        au!
        au OptionSet textwidth if &textwidth != 0
        au OptionSet textwidth      call SetColorColumn('on')
        au OptionSet textwidth else
        au OptionSet textwidth      set colorcolumn=
        au OptionSet textwidth endif
    augroup END
endif


" Return list of matches for given pattern in given range.
" This only works for matches within a single line.
" Empty hits are skipped so search for '\d*\ze,' is not stuck in '123,456'.
" If omit match() 'count' argument, pattern '^.' matches every character.
" Using count=1 causes text before the 'start' argument to be considered.
function! GetMatches(pattern, line1, line2)
  let hits = []
  for line in range(a:line1, a:line2)
    let text = getline(line)
    let from = 0
    while 1
      let next = match(text, a:pattern, from, 1)
      if next < 0
        break
      endif
      let from = matchend(text, a:pattern, from, 1)
      if from > next
        call add(hits, strpart(text, next, from - next))
      else
        let char = matchstr(text, '.', next)
        if empty(char)
          break
        endif
        let from = next + strlen(char)
      endif
    endwhile
  endfor
  return hits
endfunction


" Search across newlines {{{
" separated with whitespace (if no '!'),
" or with non-word characters (if '!' added to command).
" http://vim.wikia.com/wiki/Search_across_multiple_lines
function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag SearchMultiLine call SearchMultiLine(<bang>0, <f-args>)|normal! /<c-r>/<cr>

" }}}



" Search for current word and replace with given text for files in arglist. {{{
" http://vim.wikia.com/wiki/Search_and_replace_in_multiple_buffers
function! Replace(bang, replace)
    " (we use 'gdefault')
    " let flag = 'ge'
    let flag = 'gge'
    if !a:bang
        let flag .= 'c'
    endif
    let search = '\<' . escape(expand('<cword>'), '/\.*$^~[') . '\>'
    let replace = escape(a:replace, '/\&~')
    execute 'argdo %s/' . search . '/' . replace . '/' . flag
endfunction
command! -nargs=1 -bang Replace :call Replace(<bang>0, <q-args>)

" }}}


" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\s)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\s)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\s)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters below {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num
    let linenumber = line(".")
    call append(linenumber, repeat(char, num))
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    let linenumber = line(".")
    let line = getline(".")
    let len = strlen(line) + 2 + 2
    let borderline = repeat(char, len)
    execute '.substitute/^/' . char . ' /'
    execute '.substitute/$/ ' . char . '/'
    call append(linenumber, repeat(char, len))
    call append(linenumber-1, repeat(char, len))
endfunction
" }}}



" ranger as a file chooser {{{
function! RangerChooser(starting_dir)
    let temp = tempname()
    " The option "--choosefiles" was added in ranger 1.5.1. Use the next line
    " with ranger 1.4.2 through 1.5.0 instead.
    "exec 'silent !ranger --choosefile=' . shellescape(temp)
    if has("gui_running")
        let command = 'silent !xterm -e ranger'
    else
        let command = 'silent !ranger'
    endif
    exec command . ' --choosefiles=' . shellescape(temp) . ' --cmd="set viewmode\!" ' . a:starting_dir
    if !filereadable(temp)
        redraw!
        " Nothing to read.
        return
    endif
    let names = readfile(temp)
    if empty(names)
        redraw!
        " Nothing to open.
        return
    endif
    " Edit the first item.
    exec 'edit ' . fnameescape(names[0])
    " Add any remaning items to the arg list/buffer list.
    for name in names[1:]
        exec 'argadd ' . fnameescape(name)
    endfor
    redraw!
endfunction
command! -bar RangerChooser call RangerChooser(getcwd())
" }}}



" change search mode (what happens when hitting n) {{{
" http://vim.wikia.com/wiki/Make_search_results_appear_in_the_middle_of_the_screen
function! s:SearchMode()
  if !exists('s:searchmode') || s:searchmode == 0
    echo 'Search next: scroll as few times as possible (smart)'
    nnoremap <silent> n n:call <sid>MaybeScroll()<cr>zv
    nnoremap <silent> N N:call <sid>MaybeScroll()<cr>zv
    let s:searchmode = 1
  elseif s:searchmode == 1
    echo 'Search next: scroll hit to middle'
    nnoremap n nzzzv
    nnoremap N Nzzzv
    let s:searchmode = 2
  else
    echo 'Search next: normal'
    " nunmap n
    " nunmap N
    nnoremap n nzv
    nnoremap N Nzv
    let s:searchmode = 0
  endif
endfunction
" If cursor is on top, scroll to bottom, if it is on bottom, scroll to top
function! s:MaybeScroll()
  if winline() == &scrolloff + 1
    normal! zb
  elseif winline() == winheight(0) - &scrolloff
    normal! zt
  endif
endfunction

" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" send buffer via slack {{{
function! SendBufferViaSlack(channel)
    let content = getline(1, '$')
    exec "write !slackcat --channel " . a:channel . " --filename " . expand("%:t")
endfunction
" }}}


" send buffer via slack after choosing channel interactively {{{
function! SendBufferViaSlackChooseChannel()
    " let content = system("slackcat --list")
    " echo content
    let choice = input("Which channel: ")
    call SendBufferViaSlack(choice)
endfunction
nnoremap <leader>iS :call SendBufferViaSlackChooseChannel()<cr>
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

" add highlighted word
nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" remove highlighted words
nnoremap <silent> <leader>0
    \ :silent! call matchdelete(86751)<bar>
    \ :silent! call matchdelete(86752)<bar>
    \ :silent! call matchdelete(86753)<bar>
    \ :silent! call matchdelete(86754)<bar>
    \ :silent! call matchdelete(86755)<bar>
    \ :silent! call matchdelete(86756)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" handle binary documents {{{

augroup read_special_files
    au!
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}
                \ call s:filter_special_files()
augroup END

fu! s:filter_special_files() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif
    let fname = shellescape(expand('%:p'), 1)
    let ext = expand('%:e')
    let ext2cmd = {
    \               'doc' : '%!antiword '.fname,
    \               'docx': '%!pandoc -f docx -t markdown '.fname,
    \               'epub': '%!pandoc -f epub -t markdown '.fname,
    \               'odp' : '%!odt2txt '.fname,
    \               'odt' : '%!odt2txt '.fname,
    \               'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
    \               'rtf' : '%!unrtf --text',
    \             }
    if has_key(ext2cmd, ext)
        setl ma noro
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl noma ro nomod
    endif
endfu

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  KEYMAP SECTION                                                              "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{



let mapleader=' '


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FIX MY TYPING {{{

iabbrev todo TODO
iabbrev autotype autotype: email :tab pass :enter


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<cr>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<cr>
"endif
"nnoremap <leader><f5> :MyRefresh<cr>


" show absolute path of current file (':help filename-modifiers')
nnoremap <leader><c-g> :echo expand("%:~")<cr>

" copy current filename/path/dir (unnamed register/clipboard/fucking everywhere)
nnoremap <leader>yf :let @" = expand("%:t") <cr>
            \       :let @+ = expand("%:t") <cr>
            \       :let @* = expand("%:t") <cr>
            \       :echo @" <cr>
nnoremap <leader>ye :let @" = expand("%:t:r") <cr>
            \       :let @+ = expand("%:t:r") <cr>
            \       :let @* = expand("%:t:r") <cr>
            \       :echo @" <cr>
nnoremap <leader>yp :let @" = expand("%:p") <cr>
            \       :let @+ = expand("%:p") <cr>
            \       :let @* = expand("%:p") <cr>
            \       :echo @" <cr>
nnoremap <leader>yP :let @" = expand("%") <cr>
            \       :let @+ = expand("%") <cr>
            \       :let @* = expand("%") <cr>
            \       :echo @" <cr>
nnoremap <leader>yd :let @" = expand("%:p:h") <cr>
            \       :let @+ = expand("%:p:h") <cr>
            \       :let @* = expand("%:p:h") <cr>
            \       :echo @" <cr>


" if in a git directory and there are dirty files, open them
" nnoremap <leader>eG :silent! args `git diff --name-only`<cr>:bd#<cr>
function! EditGitDirtyFiles()
    let numberOfGitDirtyFiles = system("git status --porcelain 2>/dev/null \| egrep '^(M\| M)' \| wc -l")
    if numberOfGitDirtyFiles != 0
        silent! args `git diff --name-only`
        " if vim was just started, let's get rid of the first unnamed buffer:
        if empty(getbufinfo()[0]['name'])
            bd 1
        endif
        " TODO: avoid error with already openend windows
    else
        echo 'Working directory clean'
    endif
endfunction
nnoremap <leader>eG :call EditGitDirtyFiles()<cr>

" open config file
"nnoremap <leader>ev :edit ~/dotfiles/vim/vimrc<cr>
nnoremap <leader>ev :execute 'edit ' . resolve(expand($MYVIMRC))<cr>
nnoremap <leader>e3 :execute 'edit ' . resolve(expand('~/.i3/config'))<cr>

" reload config file
nnoremap <leader>sv :source $MYVIMRC<cr>:syntax enable<cr>
nmap <f5> <leader>sv


" to follow links in help and jump to definition (ctags)
nnoremap <m-enter>    <c-]>
nnoremap <esc><enter> <c-]>
augroup map_enter_help
    au!
    au BufReadPost */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ nnoremap <buffer> <enter> <c-]>
augroup END
nnoremap <leader><down> :tn<cr>
nnoremap <leader><up>   :tp<cr>


" visual block mode is more useful than visual mode
nnoremap v <c-v>
nnoremap <c-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <c-c>


" copy to clipboard / primary selection
nnoremap         <c-c>     "+y
nnoremap    <c-c><c-c>    V"*ygv"+y
nnoremap <leader><c-c> ggVG"*ygv"+y<c-o><c-o>
vnoremap         <c-c>     "*ygv"+y

" paste from clipboard / primary selection {{{
function! PasteFromGUI()
    let clipbrd = @+
    let primary = @*
    if len(primary) == 0
        normal "+P
    elseif len(clipbrd) == 0
        normal "*P
    elseif primary == clipbrd
        normal "*P
    else
        ec "Paste (c)lipboard (default)    " . strtrans(strpart(clipbrd, 0, 50))
        ec "or    (p)rimary selection?     " . strtrans(strpart(primary, 0, 50))
        let c = getchar()
        if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
            redraw
        elseif nr2char(c) == 'c' || nr2char(c) == '+' || c == 13 || c == 22
            normal "+P
            redraw
        elseif nr2char(c) == 'p' || nr2char(c) == 's' || nr2char(c) == '*'
            normal "*P
            redraw
        endif
    endif
endfunction
" }}}
noremap <silent> <c-v><c-v> :call PasteFromGUI()<cr>
imap <c-v><c-v> <c-o><c-v><c-v>
noremap <silent> <c-v>j o<esc>:call PasteFromGUI()<cr>
noremap <silent> <c-v>k O<esc>:call PasteFromGUI()<cr>



" macro ('complex repeat') without worrying about registers
" record macro (start and stop) with <leader>Q
" replay macro with <leader>q
" nnoremap @{ :nmap <leader<left><right>>Q @}<cr>qq
" nnoremap @} q:nmap <leader<left><right>>Q @{<cr>:echo ''<cr>
" nmap     <leader>Q @{
" nnoremap <leader>q @q

" macro ('complex repeat') with registers
" (remapping q is bad, because it is used to close stuff like plugin windows)
nnoremap Q @
nnoremap QQ @@



" alternative way to go back to normal mode
inoremap jk <esc>
cnoremap jk <c-c>
cnoremap <c-g> <c-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll with arrow keys if i lay back
"nnoremap <down> <c-e>
"nnoremap <up>   <c-y>

" scroll a little smoother (but still without plugin)
" (this actually is suggested in :help scroll-smooth)
noremap <m-j>  <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <esc>j <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <m-k>  <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>
noremap <esc>k <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)


" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))
autocmd FileType help wincmd L

" write changes with root permissions
cnoremap w!! w !sudo tee % >/dev/null
"cnoreabbrev w!! w !sudo tee % >/dev/null

" have the up/down search functionality without reaching to the arrow keys
cnoremap <c-j> <down>
cnoremap <c-k> <up>





" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{


" change text width
nnoremap <leader>ow0 :set textwidth=0<cr>
nnoremap <leader>ow5 :set textwidth=50<cr>
nnoremap <leader>ow7 :set textwidth=78<cr>
nnoremap <leader>ow8 :set textwidth=80<cr>
nnoremap <leader>ow1 :set textwidth=100<cr>
nnoremap <leader>ow2 :set textwidth=120<cr>

" change tab width (soft)
nnoremap <leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<cr>
nnoremap <leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<cr>
nnoremap <leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<cr>

" toggle paste mode
nnoremap <leader>op :set paste! <bar> :set paste?<cr>

" toggle autosave ('autowrite')
nnoremap <silent> <leader>oWW
            \ :if !exists("b:local_autosave") <bar> let b:local_autosave = 0 <bar> endif <cr>
            \ :let b:local_autosave = 1 - b:local_autosave <cr>
            \ :echo b:local_autosave == 1 ?
            \ 'autosave enabled for local buffer' :
            \ 'autosave disabled for local buffer'<cr>
nnoremap <silent> <leader>oWA
            \ :let g:autosave = 1 - g:autosave <cr>
            \ :echo g:autosave == 1 ?
            \ 'autosave enabled' :
            \ 'autosave disabled'<cr>

" toggle search preferences
nnoremap <leader>os :set hlsearch! <bar> :set hlsearch?<cr>
nnoremap <leader>oS :set wrapscan! <bar> :set wrapscan?<cr>

" ... but ignore typos
nnoremap <leader>o <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <leader>ysy :call ToggleSyntax()<cr>
" toggle syntax highlighting after g:synmaxcol characters
nmap <silent> <leader>ysmc :let &synmaxcol = g:synmaxcol - &synmaxcol <cr>

" toggle line numbers
noremap <silent> <leader>yl :set number! <bar> :set relativenumber! <cr>
noremap <silent> <leader>yL :set relativenumber! <cr>

" toggle word wrap
nnoremap <silent> <leader>yw :setlocal wrap! <bar> :set wrap? <cr>

" toggle vertical ruler
nnoremap <silent> <leader>yr :call SetColorColumn('toggle')<cr>
nnoremap <silent> <leader>yR :highlight ColorColumn ctermbg=235
                  \ <bar> highlight clear BGdd8844
                  \ <bar> highlight clear BG000000
                  \ <bar> highlight clear BGffa724
                  \ <bar> highlight clear BGaeee00
                  \ <bar> highlight clear BG8cffba
                  \ <bar> highlight clear BGb88853
                  \ <bar> highlight clear BGff9eb8
                  \ <bar> highlight clear BGff2c4b
                  \ <cr>


" toggle highlight current cursor position
nnoremap <silent> <leader>yc :let g:cursorposition = 1 - g:cursorposition <cr>i<esc>

" toggle show listchars (like whitespace)
nnoremap <silent> <leader>ya :set list!<cr>


" spell checking {{{
function! ChangeSpellChecking()
    ec "<space>  Toggle spell checking"
    ec "<e>      Set language to 'en'"
    ec "<d>      Set language to 'de'"
    ec ""
    let c = getchar()
    if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
        redraw
    elseif nr2char(c) == ' ' || nr2char(c) == 'p'
        redraw
        set spell!
        redraw
    elseif nr2char(c) == 'e'
        set spell=en
        redraw
    elseif nr2char(c) == 'e'
        set spell=de
        redraw
    endif
endfunction
" }}}
nnoremap <leader>ysp :call ChangeSpellChecking() <bar> :set spell? <cr>

" ... but ignore typos
nnoremap <leader>y <nop>
nnoremap <leader>ys <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{


" move intuitively when text is wrapped
nnoremap j gj
nnoremap k gk

" move faster
nnoremap gj 8j
nnoremap gk 8k
vnoremap gj 8j
vnoremap gk 8k


" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <c-b>  <left>
noremap! <c-f>  <right>
noremap! <c-d>  <delete>
" ... by words
noremap! <m-b>  <s-left>
noremap! <m-f>  <s-right>
cnoremap <esc>b <s-left>
cnoremap <esc>f <s-right>


" move to BOL
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <c-a> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <c-a> <c-o><c-a>

" move to EOL
nnoremap <c-e> $
vnoremap <c-e> $
onoremap <c-e> $
inoremap <c-e> <end>
cnoremap <c-a> <home>
" move to EOL with l instead of $
onoremap l $

" ... but current character movement is useful sometimes
nnoremap ch cl
nnoremap yh yl

" swap , and ;
" (makes more sense on german keyboard)
" nnoremap , ;
" nnoremap ; ,
nnoremap g, g;
nnoremap g; g,


" swap ` and ' (jump to markers)
" (by default, ' marked line, ` marked line and column)
nnoremap ' `
nnoremap ` '

" goto mark
nnoremap Ä `

" goto last edit
nnoremap <leader>. `.zzzv


" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{


" search in this buffer
if s:MyMode == 'stripped'
    nnoremap ö /
    nnoremap Ö ?
endif


" restart search from BOF/EOF
" (is useful when 'nowrapscan' is set)
" nmap gö 1Gn
nmap gÖ G$N
" nmap gö :keepjumps normal 1G<cr>n " does not work
" nmap gÖ :keepjumps normal G$<cr>N " does not work
nmap <silent> gö :ijump! 1    /<c-r>/<cr>zv
" nmap gÖ :ijump! 9999 /<c-r>/<cr> " does not work


" number of occurrences
nnoremap <leader>n* *<c-o>:%s///ngg<cr>
nnoremap <leader>nö  :%s:<c-r>/::ngg<cr>
xnoremap <leader>nö y:%s:\V<c-r>"::ngg<cr>



" search in multiple files
if s:MyMode == 'stripped'
    nnoremap <leader>ö
            \ :call ToggleList("Quickfix List", 'c')<cr>
            \ :vimgrep // **/*<left><left><left><left><left><left>
endif



" find next and previous occurence like usual when we searched backwards
" nnoremap <expr> n  'Nn'[v:searchforward]
" nnoremap <expr> N  'nN'[v:searchforward]

" keep search matches in the middle of the window and open folds
" nnoremap n nzzzv
" nnoremap N Nzzzv
silent call <sid>SearchMode()
nnoremap <silent> <leader>on :call <sid>SearchMode()<cr>


" 'goto definition' with viewport adjustments
nmap gd gdztzv
nmap gD gDztzv


" search across newlines
nnoremap <leader>fn :SearchMultiLine<space>


" find word under cursor
nnoremap *  *zv
nnoremap +  #zv
nnoremap g+ #gg/<c-p><cr>zv

" find visual selection
" (i use this instead of g* and g# anyway)
xnoremap *  y/\V<c-r>"<cr>zv
xnoremap +  y?\V<c-r>"<cr>zv
xnoremap g+ ygg/\V<c-r>"<cr>zv


" find lines that are too long
nnoremap <leader>fw :exec '/\v^.{' . &textwidth . '}.'<cr>

" find trailing whitespace
nnoremap <leader>fst /\v\s+$<cr>

" find matching element (brackets/braces/parentheses)
nnoremap <leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <leader>f<leader> %

" find all lines with keyword under cursor and ask which one to jump to
nmap <leader>fj [I:let nr = input("Which one: ")
            \   <bar> exe "normal " . nr ."[\t"<cr>

" find git merge conflict markers
nnoremap <leader>fc /\v^[<\|=>]{7}( .*\|$)<cr>

" find errors and stuff
nnoremap <leader>fe /\v(error\|fail)<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is minus ('-')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$j

" select last pasted/edited text
nnoremap gV `[v`]

" change case of word under cursor
nnoremap cC viw~

" autocompletion
inoremap <m-.>  <c-n>
inoremap <esc>. <c-n>
inoremap <m-:>  <c-p>
inoremap <esc>: <c-p>

" increment/decrement number
nnoremap -i <c-a>
nnoremap -- <c-x>


" indent lines
vnoremap < <gv
vnoremap > >gv

" change tab width (hard)
nnoremap -rt2 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=2 <bar> :retab <cr>
nnoremap -rt4 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=4 <bar> :retab <cr>
nnoremap -rt8 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=8 <bar> :retab <cr>

" yank line with Enter (i do that so often)
" CANNOT MAP THIS BECAUSE OF SPECIAL PLUGIN BUFFERS AND STUFF
" nnoremap <enter> yy

" " autoformat with enter in normal buffers
" augroup map_enter_autoformat
"     au!
"     au BufReadPost *
"                 \ if ! strchars(&buftype) |
"                 \   nnoremap <buffer> <enter> gqap |
"                 \   vnoremap <buffer> <enter> gq |
"                 \ endif
" augroup END

" move line up or down
" (:m closes folds https://groups.google.com/forum/#!topic/vim_dev/QGgbjv4uyZc)
nnoremap <silent> -k :set fdm=manual<cr>:m .-2<cr>:set fdm=marker<cr>
nnoremap <silent> -j :set fdm=manual<cr>:m .+1<cr>:set fdm=marker<cr>
vnoremap <silent> -j <esc>:set fdm=manual<cr>gv:m '>+1<cr>gv=gv:set fdm=marker<cr>
vnoremap <silent> -k <esc>:set fdm=manual<cr>gv:m '<-2<cr>gv=gv:set fdm=marker<cr>

" join line
nnoremap -lj J

" join line above (instead of below)
nnoremap -lk kddpkJ

" split line (opposite of join line)
" (regular 'S' can be done with 'cc' instead)
nnoremap -ls i<cr><esc>
            \ ^mq
            \ :let searchregister=@/<cr>
            \ :silent! .-1s/\v +$//<cr>:nohlsearch<cr>
            \ :let @/=searchregister<cr>
            \ `q

" duplicate code
nnoremap -uu yyp
nnoremap -ul yyp
nnoremap -up yap<s-}>p
vnoremap -u yP

" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <m-o>  <esc>o<esc>k
"noremap <esc>o <esc>o<esc>k
"noremap <m-o>  <esc>O<esc>j
"noremap <esc>O <esc>O<esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k

" align next column in duplicated line when i don't use replace mode
" (very bad implementation)
nnoremap -li kWjdwgE

" add space (a few newlines) below
"nnoremap <enter> :.+1insert \n\n\n<cr>
nnoremap -as mno<esc>o<esc>o<esc>o<esc>`n

" add a line of characters
nnoremap -al :call InsertCharLine(input("Insert character: "), 80)<cr>
" add a box of characters ('comment box')
nnoremap -ab :call InsertCharBox(input("Insert character: "))<cr>
" add a line of characters below, just as long as the current line
nnoremap -au- yyp^v$r-
nnoremap -au= yyp^v$r=
nnoremap -au# yyp^v$r#

" enter substitution mode quickly
nnoremap <c-s><c-s> :%s::<left>


" in visual mode, use 's' for substitution
" (to change only a single occurence, use 'c'. by default they are the same)

" substitute occurrences of selection in this buffer
vnoremap <c-s>         yms:%s:\V\C<c-r>":<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap <leader><c-s> yms:%s:\V\C\<<c-r>"\>:<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>

" substitute occurrences of selection in this buffer from current line and below
vnoremap s             yms:,$s:\V\C<c-r>":<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap <leader>s     yms:,$s:\V\C\<<c-r>"\>:<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>

" " (these are actually two substitutions, so that we start at the current line
" " but continue from the first. source: http://stackoverflow.com/a/7608016)
" vnoremap s             yms:,$s:\V\C<c-r>":<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>
" " the same, but with keyword matching
" vnoremap <leader>s     yms:,$s:\V\C\<<c-r>"\>:<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>

" substitute motions
for mov in ['e', 'E', 'b', 'B']
    exe "nmap \<c-s>" . mov . " v" . mov . "\<c-s>"
endfor
" substitute text objects
nmap <c-s>iw viw<leader><c-s>
nmap <c-s>iW viW<c-s>
"substitute word under cursor
nmap <c-s>w viw<leader><c-s>
nmap <c-s>W viW<c-s>

" substitute word under cursor in multiple files (add them with ':arg **' before)
" (instead of using the far plugin)
nnoremap <c-s>a :call Replace(0, input('Replace '.expand('<cword>').' with: '))<cr>
" ... and then ':wa'

" substitute last search
nmap <c-s>ö gggn<c-s>


" replace something with yank
nnoremap -rw viwp
nnoremap -rW viWp
nnoremap -rl v$hp


" sort lines
nnoremap -o vip:sort<cr>
vnoremap -o :sort<cr>


" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap -tu blguee
inoremap -tu <esc>blgueea


if s:MyMode == 'stripped'
    " delete trailing whitespace for selected line
    vnoremap <silent> -dst <esc>:.s:\v\s+$::<cr>
    " delete trailing whitespace for whole buffer
    nnoremap <silent> -dst :%s:\v\s+$::<cr>
endif

" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> -dsl :s:^\s\+::<cr>
" replace double/multiple spaces with one space
nnoremap <silent> -dsd :.s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> -dsD :%s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> -dsm :.s:\v(\S) {2,}(\S):\1 \2:<cr>
nnoremap <silent> -dsM :.s:\v(\S) {2,}(\S):\1 \2:<cr>


" convert a vim plugin github url into appropriate format for vundle
nnoremap -pi :.s:\m.*http.*github\.com/\([^/]*/[^/]*\).*:Plugin '\1':<cr>


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <leader>ch :call ToggleHTMLComment("n")<cr>
vnoremap <silent> <leader>ch :call ToggleHTMLComment("v")<cr>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <leader>cd yyI#<esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <m-u>  :earlier<cr>
noremap <esc>u :earlier<cr>
noremap <m-u>  :later<cr>
noremap <esc>U :later<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{


" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUILDING AND DEBUGGING {{{


" make
nnoremap <leader>bm :make<cr>

" execute shell script
augroup shellscript_on_read
    au!
    au FileType sh      call SetupShellscript()
    au FileType fish    call SetupShellscript()
augroup END
function! SetupShellscript()
    if s:MyMode == 'mastery'
        nnoremap <leader>bs :call VimuxRunCommand("bash -c 'chmod u+x " . expand("%") . " && " . expand("%") . "'")<cr>
    else
        nnoremap <leader>bs :!chmod u+x % && ./%<cr>
    endif
endfunction


" jump to (syntastic) errors
nnoremap <leader>sg :lfirst<cr>
nnoremap <leader>sG :llast<cr>
" nnoremap <leader>sn :lnext<cr>
" nnoremap <leader>sN :lprevious<cr>

" perform a :cnext or :lnext
" so we jump through both quickfix and location list with one keystroke
" @param direction: 0 for next, 1 for previous
" @param switch: 0 for the same list as before, 1 for the other
let g:jumplist = 'locationlist'
function! JumpThroughList(direction, switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (a:direction == 1)
        if (g:jumplist == 'quickfixlist')
            silent! cprevious
        else
            silent! lprevious
        endif
    else
        if (g:jumplist == 'quickfixlist')
            silent! cnext
        else
            silent! lnext
        endif
    endif
endfunction
nnoremap <silent> <left>          :call JumpThroughList(1, 0)<cr>
nnoremap <silent> <right>         :call JumpThroughList(0, 0)<cr>
nnoremap <silent> <leader><left>  :call JumpThroughList(1, 1)<cr>
nnoremap <silent> <leader><right> :call JumpThroughList(0, 1)<cr>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <leader>sl :lclose<bar>:cclose<cr>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <leader>sL :lopen<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS AND WINDOWS {{{


" change or open new buffer by searching for file name
if s:MyMode == 'stripped'
    nnoremap # :buffers<cr>:buffer<space>
    nnoremap <leader># :find<space>
endif

" change to LRU buffer
nnoremap <space><space> :buffer #<cr>
nnoremap <space><tab>   :buffer #<cr>

" circle through buffers
nnoremap <m-n>  :bnext<cr>
nnoremap <esc>n :bnext<cr>
nnoremap <m-p>  :bprevious<cr>
nnoremap <esc>p :bprevious<cr>

" change window
nnoremap <silent> <c-j> :wincmd j<cr>
nnoremap <silent> <c-k> :wincmd k<cr>
nnoremap <silent> <c-h> :wincmd h<cr>
nnoremap <silent> <c-l> :wincmd l<cr>

" move buffer to a new window
nnoremap <silent> <leader><c-l> :vsplit<cr><c-w>w:bprevious<cr><c-w>w<cr>
nnoremap <silent> <leader><c-j>  :split<cr><c-w>w:bprevious<cr><c-w>w<cr>

" resize window faster
nnoremap <silent> <c-w>+ :resize +3<cr>
nnoremap <silent> <c-w>- :resize -3<cr>
nnoremap <silent> <c-w>> 5<c-w>>
nnoremap <silent> <c-w>< 5<c-w><


" clear windows (close quickfix and location list) and refresh screen
nnoremap <silent> <bs> :nohlsearch \| :lclose \| :cclose \| :redraw! <cr>
xmap <silent> <bs> <bs>gv

" toggle quickfix or location list
nnoremap <silent> <leader>tq :call ToggleList("Quickfix List", 'c')<cr>
nnoremap <silent> <leader>tl :call ToggleList("Location List", 'l')<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" builtin file explorer (netrw) {{{
" (who needs NERDTree anyway)

" let g:netrw_liststyle = 1
" let g:netrw_winsize = 31
let g:netrw_liststyle = 0
let g:netrw_winsize = 16
let g:netrw_banner = 0
let g:netrw_browse_split = 4

let g:netrw_is_toggled = 0


" toggle netrw and start from current file
nnoremap <silent> <leader>te :exe ':Lexplore! ' . expand('%:p:h')<cr>
" toggle netrw and start from working (project) dir
nnoremap <silent> <leader>tE :Lexplore!<cr>


augroup netrw_autocmds
    autocmd!
    autocmd filetype netrw call NetrwMappings()
augroup END

function! NetrwMappings()
    silent! nunmap <buffer> qL
    silent! nunmap <buffer> qF
    silent! nunmap <buffer> qf
    silent! nunmap <buffer> qb
    silent! nunmap <buffer> q
    nnoremap <buffer> q   :bd<cr>
    nnoremap <buffer> h   :help netrw-quickmap<cr>
    nmap     <buffer> .   gh
    nmap     <buffer> u   -
    " TODO: nnoremap u or locally unmap all - bindings to prevent odd bugs
    nmap     <buffer> af  %
    nmap     <buffer> ad  d
endfunction



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{

" search the web with selection
vnoremap <leader>isl :<c-w>!$BROWSER 'https://dict.leo.org/ende/?lang=en&search=<c-r>*'<cr><cr>
vnoremap <leader>isd :<c-w>!$BROWSER 'https://duckduckgo.com/?q=<c-r>*'<cr><cr>
vnoremap <leader>isg :<c-w>!$BROWSER 'https://google.com/?q=<c-r>*'<cr><cr>

" shell in working dir or dir of current file
nnoremap <leader>if :!fish<cr><cr>
nnoremap <leader>iF :execute '!cd ' . expand('%:p:h') . '; fish'<cr><cr>
nnoremap <leader>ib :!bash<cr><cr>
nnoremap <leader>iB :execute '!cd ' . expand('%:p:h') . '; bash'<cr><cr>

" file manager in working dir or dir of current file
" nnoremap <leader>ir :call VimuxRunCommand("ranger")<cr>
" nnoremap <leader>ir :exe "!ranger " . shellescape(expand("%p:h"))
nnoremap <leader>ir :call RangerChooser(expand('%:p:h'))<cr>
nnoremap <leader>iR :RangerChooser<cr>

" git interface in working dir or dir of current file
nnoremap <leader>it :!tig status <cr><cr>
nnoremap <leader>iT :execute '!cd ' . expand('%:p:h') . '; tig status'<cr><cr>

" insert google contacts with name and mail addresses (with goobook)
nnoremap <leader>igm         :r!goobook-query-mail.sh<space>
" inoremap <leader>igm <esc>diw:r!goobook-query-mail.sh<space><c-r>"<cr><cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{


" check for file changes (and 'reload' them or get asked with autoread)
nnoremap <leader>rl :checktime<cr>

" discard changes ('reset')
nnoremap <leader>rs :e!<cr>


" write changes
nnoremap <leader>w  :update<cr>:GitGutter<cr>
nnoremap <leader>WW :update!<cr>

" quit current buffer
nnoremap <leader><bs> :bdelete<cr>
nnoremap <leader>qq   :bdelete<cr>
nnoremap <leader>QQ   :bdelete!<cr>
augroup map_q_in_read_only_buffers
    au!
    au BufReadPost * if &readonly
    au BufReadPost *   nnoremap <buffer> q :bd<cr>
    au BufReadPost * endif
    au BufReadPost fugitive://* nnoremap <buffer> q :bd<cr>
augroup END


" quit all buffers (not vim)
nnoremap <leader>qa :bufdo bdelete<cr>

" quit current window
nnoremap <leader>qW :quit<cr>:buffer #<cr>
" quit all windows but current
nnoremap <leader>qw :only<cr>

" quit vim (multiple windows)
" (this is how i exit most terminal applications)
nnoremap <c-d>              :quitall<cr>
nnoremap <leader><c-d><c-d> :quitall!<cr>

" ... but ignore typos
nnoremap <leader>q <nop>
nnoremap <leader>Q <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILETYPE SPECIFIC SETTINGS {{{

augroup FILETYPE_SPECIFIC_SETTINGS_QUICKFIX
    autocmd!
    autocmd filetype qf setlocal norelativenumber
    autocmd filetype qf setlocal colorcolumn=
augroup END

augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit let b:local_autosave = 0
    autocmd filetype gitcommit normal gg
augroup END

augroup FILETYPE_SPECIFIC_SETTINGS_JSON
    autocmd!
    autocmd! FileType json setlocal conceallevel=0 foldmethod=syntax foldlevel=999
augroup END


" default textwidth
augroup auto_textwidth
    autocmd!
    autocmd FileType dockerfile      set textwidth=100 | call SetColorColumn('on')
    autocmd FileType gitcommit       set textwidth=50  | call SetColorColumn('on')
    autocmd FileType markdown        set textwidth=100 | call SetColorColumn('on')
    autocmd FileType php             set textwidth=120 | call SetColorColumn('on')
    autocmd FileType scala           set textwidth=120 | call SetColorColumn('on')
    autocmd FileType sh              set textwidth=100 | call SetColorColumn('on')
    autocmd FileType sql             set textwidth=80  | call SetColorColumn('on')
augroup END



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" LOCAL SECTION                                                                "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{

" Check for local vimrc files and source them.
" (project files take precedence over global files)
" (non-hidden files take precedence over hidden files)
" (child directory takes precedence over parent directory)
let vimrcs = []
for vimrc_name in ['vimrc.local', '.vimrc.local']
    let dir = getcwd()
    while dir != '/'
        let vimrc = glob(dir . '/' . vimrc_name)
        if filereadable(vimrc)
            let vimrcs = vimrcs + [vimrc]
        endif
        let dir = fnamemodify(dir . '..', ':h')
    endwhile
endfor
let vimrcs = vimrcs + ['~/.vimrc.local']
for vimrc in reverse(vimrcs)
    if filereadable(vimrc)
        exec 'source ' . vimrc
    endif
endfor


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=80:sw=4:fdm=marker:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
