"  Author:  Philipp Moers
"           soziflip@gmail.com
"           http://github.com/sflip/dotfiles
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
" If you are reading this configuration file on whe web and want use it right
" away, start vim like this:
"
"       bash -c "vim -u <(curl https://raw.githubusercontent.com/sflip/dotfiles/master/vim/vimrc) FILE"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins.
" I use   VUNDLE    to manage my plugins.
" It seems to be best package manager for me. For a discussion see here:
"       http://quyennguyen.com/code/Sync-Vim-With-Github-and-Vundle/
"       http://lepture.com/en/2012/vundle-vs-pathogen

" I install vundle like this:
"
"       git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install some of the vim configuration files and from inside vim I call
" :PluginInstall on each host to let vundle handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a KEYMAP SECTION
"                           where characters are bound.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (' ')
"                           - text edit leader is minus ('-')
"                           - interface leader is control+g ('<C-G>')
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"       a LOCAL SECTION
"                           where potential other vimrc files are loaded.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash
" (fish is not posix compatible and makes problems)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" always search recursively (e.g. when using :find)
set path+=**

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
" (TODO: current implementation is very simple and should be improved)
function! ComputeMyMode()
    if isdirectory(expand("~/.vim/bundle/vundle"))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc source $MYVIMRC
    autocmd BufWritePost vimrc AirlineRefresh
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


if s:MyMode == 'mastery'


    " start vundle
    filetype off
    set rtp+=~/.vim/bundle/vundle/
    "call vundle#rc()
    call vundle#begin()



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let Vundle manage Vundle (required!) {{{

Plugin 'gmarik/vundle'

" package control mappings from vundle itself
nnoremap <Leader>pl :PluginList<CR>
nnoremap <Leader>pi :PluginInstall<CR>:smile<CR>
nnoremap <Leader>pc :PluginClean<CR>
nnoremap <Leader>pu :PluginUpdate<CR>
nnoremap <Leader>ps :PluginSearch<Space>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tmux integration {{{


" fix FocusLost and FocusGained events in tmux
Plugin 'tmux-plugins/vim-tmux-focus-events'


" " don't worry about tmux panes and vim splits
" Plugin 'christoomey/vim-tmux-navigator'
" let g:tmux_navigator_save_on_switch = 1
" let g:tmux_navigator_no_mappings = 1
" nnoremap <silent> {Left-Mapping}     :TmuxNavigateLeft<cr>
" nnoremap <silent> {Down-Mapping}     :TmuxNavigateDown<cr>
" nnoremap <silent> {Up-Mapping}       :TmuxNavigateUp<cr>
" nnoremap <silent> {Right-Mapping}    :TmuxNavigateRight<cr>
" nnoremap <silent> {Previous-Mapping} :TmuxNavigatePrevious<cr>


" run tmux commands from within vim
Plugin 'benmills/vimux'
let g:VimuxHeight = "24"
let g:VimuxOrientation = "v"
let VimuxUseNearest = 1
nnoremap <Leader>bo         :VimuxRunCommand "clear; "<Left>
nnoremap <Leader>bf         :VimuxRunCommand "clear;  " . expand('%')<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
nnoremap <Leader>bb         :update<CR>:VimuxRunLastCommand<CR>
nnoremap <Leader>bl         :update<CR>:VimuxRunLastCommand<CR>
nnoremap <Leader>bq         :VimuxCloseRunner<CR>
nnoremap <Leader>bx         :VimuxCloseRunner<CR>
nnoremap <Leader>bz         :call VimuxZoomRunner()<CR>
nnoremap <Leader>bc         :VimuxInterruptRunner<CR>
nnoremap <Leader>b<C-c>     :VimuxInterruptRunner<CR>
nnoremap <Leader>b<C-b>     :VimuxInspectRunner<CR>
nnoremap <Leader><C-b><C-b> :VimuxInspectRunner<CR>
nnoremap <Leader>be         :call MakeWithVimuxOpenErrors('quickfix')<CR>
nnoremap <Leader>bE         :call MakeWithVimuxOpenErrors('buffer')<CR>
" MORE SPECIFIC MAPPING IN OTHER VIMRC SECTIONS (which makes more sense)

" build/debug with vimux
" param command: the shell command to execute
let g:makewithvimux_outfile = '/tmp/vim.make.out'
function! MakeWithVimux(command)
    call VimuxRunCommand(a:command . ' | tee ' . g:makewithvimux_outfile)
endfunction
function! MakeWithVimuxOpenErrors(where)
    exec 'cfile ' . g:makewithvimux_outfile
    if a:where == 'quickfix'
        let g:jumplist = 'quickfixlist'
        call ToggleList("Quickfix List", 'c')
    elseif a:where == 'buffer'
        execute "edit " . g:makewithvimux_outfile
    endif
endfunction





" autocompletion from words visible in tmux panes
Plugin 'wellle/tmux-complete.vim'
" <C-x><C-u> and then <C-u> or <C-n> a few times



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plugin 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" make gvim colorschemes work in terminal
Plugin 'godlygeek/csapprox'


" colorschemes
Plugin 'flazz/vim-colorschemes'
Plugin 'christophermca/meta5'
Plugin 'joshdick/onedark.vim'
Plugin 'sjl/badwolf'


" cycle through colorschemes
Plugin 'vim-scripts/ScrollColors'
nnoremap <C-G>o :COLORSCROLL<CR>


" " highlight different bracket pairs with different colors
" " DOES NOT WORK
" Plugin 'kien/rainbow_parentheses.vim'
" nnoremap <C-G>b :RainbowParenthesesToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" distraction free mode {{{

Plugin 'junegunn/goyo.vim'

let g:goyo_width="120"
let g:goyo_height="100%"

nnoremap <C-G>f :Goyo<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" statusline {{{

" https://powerline.readthedocs.org/en/latest/usage/other.html#vim-statusline
"
" instead of this deprecated vimscript plugin...:
" Plugin 'Lokaltog/vim-powerline
" ... we use this rewritten one in python:
" Plugin 'powerline/powerline'

" disable powerline if it is installed
let g:powerline_loaded = 1

" on arch linux, installed python-powerline
" and fix import error with
"let $PYTHONPATH="/usr/lib/python3.5/site-packages"


" lightweight alternative to powerline

Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'

let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline#extensions#tabline#enabled = 0

"let g:airline_section_y = g:airline_section_a
let g:airline_section_a = '%{fnamemodify(getcwd(), ":t")}'

let g:airline_powerline_fonts=0
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''



" simple statusline
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plugin 'tpope/vim-fugitive'

nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gU :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gA :Gwrite<CR>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gpp :Gpull<CR>
nnoremap <Leader>gpu :Gpush<CR>

" in Gdiff view, navigate and stage/checkout easily
augroup gitdiff
    au!
    au BufRead fugitive://* nnoremap <buffer> <Down>  ]c
    au BufRead fugitive://* nnoremap <buffer> <Up>    [c
    au BufRead fugitive://* nnoremap <buffer> <Left>  do
    au BufRead fugitive://* nnoremap <buffer> <Right> dp
augroup END


" show git status of lines on the left

Plugin 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

" GitGutter styling to use · instead of +/-
let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_modified_removed = '∙'

" do not map ic/ac text objects etc because I decide how I use them
let g:gitgutter_map_keys = 0

omap ih <Plug>GitGutterTextObjectInnerPending
omap ah <Plug>GitGutterTextObjectOuterPending
xmap ih <Plug>GitGutterTextObjectInnerVisual
xmap ah <Plug>GitGutterTextObjectOuterVisual

nnoremap <C-G>g       :GitGutterToggle<CR>
nnoremap <Leader>gg gg:GitGutterNextHunk<CR>ztzv
nnoremap <Leader>gG  G:GitGutterPrevHunk<CR>ztzv
nnoremap <Leader>gn   :GitGutterNextHunk<CR>ztzv
nnoremap <Leader>gN   :GitGutterPrevHunk<CR>ztzv
nnoremap <Down>       :GitGutterNextHunk<CR>ztzv
nnoremap <Up>         :GitGutterPrevHunk<CR>ztzv
nnoremap <Leader>ga   :GitGutterStageHunk<CR>
nnoremap <Leader>gu   :GitGutterUndoHunk<CR>
nnoremap <Leader>gi   :GitGutterPreviewHunk<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle unicode and digraphs easily {{{

Plugin 'chrisbra/unicode.vim'

" inspect character under cursor
nnoremap ga :UnicodeName<CR>

" complete unicode with <C-X><C-Z>
" complete digraph with <C-X><C-G>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plugin 'easymotion/vim-easymotion'

" prefix
map ä <Plug>(easymotion-prefix)
" keys to move to target
let g:EasyMotion_keys = 'asdfgh,.qwertuiocvbnmjkl'



" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
" Plugin 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<CR>", "\<Tab>"]
let g:clever_f_chars_match_any_signs = 'ö'



" like f but with two characters
Plugin 'justinmk/vim-sneak'

" interactive mode like easymotion
" let g:sneak#label = 1

" movement repeatable with same keystroke like clever-f
" (i don't really like this, as it makes movements unpredictable)
" let g:sneak#s_next = 1

" , always forwards ; always backwards
" let g:sneak#absolute_dir = 1

" use smartcase;
let g:sneak#use_ic_scs = 1

nmap f <Plug>Sneak_s
xmap z <Plug>Sneak_s
omap z <Plug>Sneak_s

nmap s <Plug>Sneak_S
nmap F <Plug>Sneak_S
xmap Z <Plug>Sneak_S
omap Z <Plug>Sneak_S

nmap , <Plug>Sneak_;
nmap ; <Plug>Sneak_,


autocmd ColorScheme * hi Sneak      ctermfg=72 ctermbg=236
autocmd ColorScheme * hi SneakScope ctermfg=72 ctermbg=236



" make f only match interesting characters
" Plugin 'svermeulen/vim-NotableFt'

" nmap , <Plug>NotableFtRepeatSearchForward
" nmap ; <Plug>NotableFtRepeatSearchBackward
" nmap f <Plug>NotableFtSearchFForward
" nmap s <Plug>NotableFtSearchFBackward
" nmap F <Plug>NotableFtSearchFBackward
" nmap t <Plug>NotableFtSearchTForward
" nmap T <Plug>NotableFtSearchTBackward



" highlight characters for f
" Plugin 'unblevable/quick-scope'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" movements and text objects for parts of words {{{

" move with ,w in wordsLikeThisWord or words_like_this_word
" Plugin 'bkad/CamelCaseMotion'

" call camelcasemotion#CreateMotionMappings(',') " DOES NOT WORK HERE

" also handle dashes with this plugin (hence w should move over them)
" (this breaks toggle_words for many cases)
" set iskeyword+=-


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better and custom text objects {{{

Plugin 'wellle/targets.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Plugin 'kana/vim-textobj-user'

" lines with the same indent level (ai/ii)
Plugin 'kana/vim-textobj-indent'

" quotes (aq/iq)
Plugin 'beloglazov/vim-textobj-quotes'

" functions (af/if)
Plugin 'kana/vim-textobj-function'
Plugin 'thinca/vim-textobj-function-javascript'

" function arguments (aa/ia)
" (somehow required one more keystroke)
Plugin 'gaving/vim-textobj-argument'

" lines with ( [ { pairs (ac/ic)
" Plugin 'Chun-Yang/vim-textobj-chunk'

" css rules (ac/ic)
Plugin 'jasonlong/vim-textobj-css'
" Plugin 'stephenway/vim-textobj-css'

" HTML/XML attributes (ax/ix)
Plugin 'whatyouhide/vim-textobj-xmlattr'

" PHP Tags (aP/iP)
Plugin 'akiyan/vim-textobj-php'

" folds (az/iz)
Plugin 'kana/vim-textobj-fold'

" git hunks (ih) (now managed by gitgutter plugin)
" Plugin 'gilligan/textobj-gitgutter'
" omap ah <Plug>(textobj-gitgutter-i)
" vmap ah <Plug>(textobj-gitgutter-i)

" entire buffer / 'all' (aa/ia)
Plugin 'kana/vim-textobj-entire'
let g:textobj_entire_no_default_key_mappings = 1
omap aE <Plug>(textobj-entire-a)
vmap aE <Plug>(textobj-entire-a)
omap iE <Plug>(textobj-entire-i)
vmap iE <Plug>(textobj-entire-i)
" load dynamically with :TextobjEntireDefaultKeyMappings

" note that vimtex also defines mappings ic/id/ie/i$


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

" Plugin 'google/vim-searchindex'
" Plugin 'osyo-manga/vim-anzu'


Plugin 'haya14busa/incsearch.vim'
let g:incsearch#emacs_like_keymap = 1
let g:incsearch_cli_key_mappings = {
\   "\<C-n>": {
\     'key': '<Over>(buffer-complete)',
\     'noremap': 1
\   },
\   "\<C-p>": {
\     'key': '<Over>(buffer-complete-prev)',
\     'noremap': 1
\   },
\ }
" TODO: <C-k> and <C-j> to scroll through old searches. use arrows until fix.

" nnoremap ö  <Plug>(incsearch-forward)
" nnoremap Ö  <Plug>(incsearch-backward)
nnoremap ö :call incsearch#call()<CR>
nnoremap Ö :call incsearch#call({'command': '?'})<CR>


" searching in multiple files
" install 'the_silver_searcher' package on the system
Plugin 'mileszs/ack.vim'

" command to execute
let g:ackprg="ag --vimgrep --smart-case"

" type a search pattern
nnoremap <Leader>Ö :let g:jumplist = 'quickfixlist'<CR>
                 \ :Ack!<Space>""<Left>

" search for visual selection
xnoremap <Leader>Ö y:let g:jumplist = 'quickfixlist'<CR>
                 \ :<c-u>Ack! "-Q" "<C-R>""<CR>


" % also matches HTML-tags/words etc
Plugin 'matchit.zip'


" hide (fold) everything except search string etc
Plugin 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <Leader>zs :Fs<CR>
nnoremap <Leader>z/ :Fs<CR>
nnoremap <Leader>zö :Fs<CR>
nnoremap <Leader>zz :Fs<CR>

" show word under cursor
nnoremap <Leader>z* :Fw<CR>
nnoremap <Leader>zw :Fw<CR>

" show visual selection
vnoremap <Leader>z y:Fp<Space>\V<C-R>"<CR>

" change context size (number of lines around matches)
nnoremap <Leader>z+ :Fi<CR>
nnoremap <Leader>zi :Fi<CR>
nnoremap <Leader>z- :Fd<CR>
nnoremap <Leader>zd :Fd<CR>

" restore folds
nnoremap <Leader>ze :Fe<CR>
nnoremap <Leader>Z  :Fe<CR>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

" (i use fzf instead)
" Plugin 'kien/ctrlp.vim'

" let g:ctrlp_map = '#'
" let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap #          :CtrlPBuffer<CR>
nnoremap <Leader>#  :CtrlPRoot<CR>
nnoremap <Leader>er :CtrlPMRUFiles<CR>
nnoremap <Leader>em :CtrlPMixed<CR>
nnoremap <Leader>eo :CtrlPRoot<CR>
nnoremap <Leader>eb :CtrlPBuffer<CR>

" ignore some stuff (in addition to 'wildignore')
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<Esc><Enter>', '<c-l>', '<c-v>', '<RightMouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<right>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<left>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1

" only cache if we're in huge projects
let g:ctrlp_use_caching = 2000


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf - great fuzzy finder {{{
" (makes ctrlp and the ag plugin obsolete)
" (prefixing a word with ' makes it non-fuzzy)

" install 'fzf' package on the system. or:
Plugin 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }

Plugin 'junegunn/fzf.vim'


" prefix all the command names
let g:fzf_command_prefix = 'Fzf'

" layout [ down / up / left / right ]
let g:fzf_layout = { 'down': '~20%' }

" extra interactive key bindings
" (scroll with <C-k> and <C-j>
let g:fzf_action = {
  \ 'ctrl-x': 'split',
  \ 'ctrl-l': 'vsplit',
  \ 'ctrl-v': 'vsplit',
  \ }
" \ 'ctrl-k': 'previous-history',
" \ 'ctrl-j': 'next-history',

" enable per-command history
" (scroll through history with <C-p> and <C-n>)
let g:fzf_history_dir = '~/.local/share/fzf-history'


" open files by name
nnoremap <Leader>fi :FzfFiles<CR>
nnoremap <Leader>fl :FzfLocate<Space>
nnoremap #          :FzfBuffers<CR>
nnoremap <Leader>#  :FzfFiles<CR>
nnoremap <Leader>eo :FzfGFiles<CR>
nnoremap <Leader>eg :FzfGFiles?<CR>
nnoremap <Leader>er :FzfHistory<CR>
nnoremap <Leader>eb :FzfBuffers<CR>

let g:fzf_tags_command = 'ctags -R -f .tags'
nnoremap <Leader>et  :FzfTags<CR>
xnoremap <Leader>et y:FzfTags <C-R>"<CR>

" type a search pattern
nnoremap <Leader>ö :FzfAg<CR>
" search for word under cursor
nnoremap <Leader>+ :FzfAg <C-R><C-W><CR>
nmap     <Leader>* <Leader>+
" search for visual selection
xnoremap <Leader>ö y:<c-u>FzfAg <C-R>"<CR>
xmap     <Leader>* <Leader>ö
xmap     <Leader>+ <Leader>ö

" fuzzy search for built-in vim stuff (command history, searches, helptags)
nnoremap <Leader>:          :FzfHistory:<CR>
nnoremap <Leader>/          :FzfHistory/<CR>
nnoremap <Leader>h<Leader>  :FzfHelptags<CR>

" autocomplete lines like a boss, even across multiple files
imap <C-x><C-l> <plug>(fzf-complete-line)


" adjust colors to colorscheme: gruvbox
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plugin 'Shougo/vimproc.vim'
"Plugin 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) {{{

" install 'ctags' package on the system

" generate tag file manually
" (fails with '–exclude=@.gitignore' when the file does not exist!)
nnoremap <Leader>eT :!ctags -R -f .tags .<CR>


" generate tag file automagically
Plugin 'craigemery/vim-autotag'

let g:autotagTagsFile=".tags"



Plugin 'majutsushi/tagbar'

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <Leader>tt :TagbarToggle<CR>

"autocmd FileType vim nested :TagbarOpen()<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file browser {{{

" Plugin 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show nerdtree from current file
noremap <silent> <Leader>tn :NERDTreeFind<CR>
" show/hide nerdtree
noremap <silent> <Leader>tN :NERDTreeToggle<CR>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'


" pimp netrw
" Plugin 'tpope/vim-vinegar'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" close all other buffers {{{

Plugin 'vim-scripts/BufOnly.vim'

nmap <Leader>qo :BufOnly<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

" Plugin 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex", "scala"] }
" let g:syntastic_cpp_compiler = 'clang++'
" let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_c_cppcheck_args = ' -std=c++11 -stdlib=libc++'

nnoremap <silent> <Leader>sc :SyntasticCheck<CR>
nnoremap <silent> <Leader>sr :SyntasticReset<CR>
nnoremap <silent> <Leader>st :SyntasticToggleMode<CR>
nnoremap <silent> <Leader>si :SyntasticInfo<CR>


" install linters on the system:
" - pylint
" - jslint / jshint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)
" - fsc
" - scalac

let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']
" let g:syntastic_javascript_checkers = ['eslint', 'jshint', 'jslint']
let g:syntastic_javascript_checkers = ['eslint', 'jshint']
let g:syntastic_scala_checkers = ['fsc']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mFile is being conditionally included;',
            \ '\mFile is being unconditionally included;',
            \ '\mLine indented incorrectly;.*',
            \ '\mMulti-line IF statement not indented correctly;.*',
            \ '\mEach line in a multi-line IF statement must begin with a boolean operator.*',
            \ '\mSpace after opening parenthesis of function call prohibited.*',
            \ '\mExpected 0 spaces before closing bracket; .* found.*',
            \ '\mExpected \\"foreach (...) {\\n\\"; found \\"foreach(...) {\\n\\".*',
            \ '\mExpected \\"if (...) {\\n\\"; found \\"if(...) {\\n\\".*',
            \ '\mExpected \\"} elseif (...) {\\n\\"; found \\"} elseif(...) {\\n\\".*',
            \ '\mOpening brace should be on a new line.*',
            \ '\mBad line breaking before .+..',
            \ '\mInline control structures are discouraged',
            \ '\mClosing parenthesis of a multi-line IF statement must be on a new line',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mDon.t use adjoining classes.',
            \ '\mDon.t use IDs in selectors.',
            \ '\mHeading (h.) should not be qualified.',
            \ '\mShort PHP opening tag used;',
            \ '\m.$. was used before it was defined.',
            \ '\mpossible unwanted space at "{"',
            \ '\mFunction name .* is prefixed with a package name but does not begin with a capital letter',
            \ '\m.$. was used before it was defined.'
            \ ] }



" asynchronous alternative to syntastic
Plugin 'w0rp/ale'

let g:ale_list_window_size = 5
let g:ale_lint_on_enter = 0
let g:ale_fixers = {
\   'javascript': ['eslint'],
\}

nnoremap <silent> <Leader>sc :ALELint<CR>
nnoremap <silent> <Leader>sn :ALENext<CR>
nnoremap <silent> <Leader>sN :ALEPrevious<CR>
nnoremap <silent> <Leader>sp :ALEPrevious<CR>
nnoremap <silent> <Leader>sr :ALEDisable<CR>
nnoremap <silent> <Leader>st :ALEToggle<CR>
nnoremap <silent> <Leader>si :ALEInfo<CR>

highlight ALEErrorSign      ctermfg=203
highlight ALEWarningSign    ctermfg=227
highlight ALEInfoSign       ctermfg=227


" evaluate expression live, which is awesome
" Plugin 'metakirby5/codi.vim'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" read the docs {{{

Plugin 'thinca/vim-ref'

":Ref STUFF



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" text editing {{{


" replace some motion or text object or selection with current yank
" Plugin 'ReplaceWithRegister'
" nmap -rr <Plug>ReplaceWithRegisterOperator
" nmap -re <Plug>ReplaceWithRegisterLine
" xmap -r  <Plug>ReplaceWithRegisterVisual
" I DON'T REALLY USE THIS BUT v3wp or -rw OCCASIONALLY


" preview register contents
Plugin 'junegunn/vim-peekaboo'


" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plugin 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <Leader>pp <Plug>yankstack_substitute_older_paste
nmap <Leader>nn <Plug>yankstack_substitute_newer_paste
"call yankstack#setup() " DOES NOT WORK HERE


" add and toggle comments with <Leader>c<space> etc
Plugin 'scrooloose/nerdcommenter'
" use leading space, but delete trailing space
let g:NERDSpaceDelims = 1
let g:NERDTrimTrailingWhitespace = 1
" do not nest by default
let g:NERDDefaultNesting = 1
let g:NERDAltDelims_javascript = 0
" align multiline comments
let g:NERDDefaultAlign = 'left'
" nmap -c <Leader>c
" xmap -c <Leader>c
" comment text objects and movements
for mov in ['j', 'k', 'gg', 'G', '(', ')', '{', '}', 'as', 'is', 'ap', 'ip']
    exe "nmap \<Leader\>c" . mov . " V" . mov . "\<Plug\>NERDCommenterInvert"
    exe "nmap -c"          . mov . " V" . mov . "\<Plug\>NERDCommenterComment"
endfor
for i in range(1, 50)
    exe "nmap \<Leader\>c" . i . "j V" . i . "j\<Plug\>NERDCommenterInvert"
    exe "nmap \<Leader\>c" . i . "k V" . i . "k\<Plug\>NERDCommenterInvert"
    exe "nmap -c"          . i . "j V" . i . "j\<Plug\>NERDCommenterComment"
    exe "nmap -c"          . i . "k V" . i . "k\<Plug\>NERDCommenterComment"
endfor
" duplicate a line and comment out the first one
nmap <Leader>cd <Leader>cyp
" do not comment on new lines (except when already in insert mode)
nnoremap o o<Esc>S
nnoremap O O<Esc>S


" automagically add closing braces etc
Plugin 'Raimondi/delimitMate'


" add a ; at the end of a line
"Plugin 'lfilho/cosco.vim'
"inoremap <silent> <Esc><Enter> <Esc>:call cosco#commaOrSemiColon()<CR>A<Enter>
inoremap <silent> <Esc><Enter> <Esc>A;<Esc>^


" add/change/delete quotes/braces/... and more
Plugin 'tpope/vim-surround'

" surround consistently in both modes and more comfortably on german keyboard
nmap -s ys
vmap -s S

" surround with quotes/parentheses/brackets quickly
vmap -q S'
vmap -Q S"
nmap -q ysiw'
nmap -Q ysiw"
vmap -b S)
vmap -B S}
nmap -b ysiw)
nmap -B ysiw}
nmap dq ds'
nmap dQ ds"

" toggle quotes {{{
function! ToggleQuotesWithVimSurround()
    let pos_cursor = getpos(".")[2]
    let linepart   = strpart(getline("."), pos_cursor - 1)
    let pos_single = stridx(linepart, "'")
    let pos_double = stridx(linepart, '"')
    if pos_single >= 0 && (pos_double < 0 || pos_single < pos_double)
        normal cs'"
    elseif pos_double >= 0 && (pos_single < 0 || pos_double < pos_single)
        normal cs"'
    endif
endfunction
" }}}
nnoremap <silent> -tq :call ToggleQuotesWithVimSurround()<CR>


" swap ('transpose') two words or arbitrary things
Plugin 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <Leader>x <Plug>(Exchange)
xmap <Leader>x <Plug>(Exchange)
nmap <Leader>xc <Plug>(ExchangeClear)
nmap <Leader>xl <Plug>(ExchangeLine)
nmap <Leader>xx <Leader>xiw


" " find and replace tool for multiple files (IDE like)
" " (helptags are buggy according to vundle)
" Plugin 'brooth/far.vim'
" nnoremap <Leader>SS :Far  **<Left><Left><Left>
" vnoremap <Leader>SS :Far *  **<Left><Left><Left>
" nnoremap <Leader>SD :Fardo<CR>


" add "printf" statements with shortcut
Plugin 'bergercookie/vim-debugstring'

nmap <Leader>ad <Plug>DumpDebugString



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" multiple cursor like in Sublime {{{

" SEEMS NOT TO WORK PROPERLY FOR ME

" Plugin 'terryma/vim-multiple-cursors'

" let g:multi_cursor_use_default_mapping=0

" " (only single keystrokes are possible at the moment)
" let g:multi_cursor_next_key='<C-n>'
" let g:multi_cursor_prev_key='<C-p>'
" let g:multi_cursor_skip_key='<C-x>'
" let g:multi_cursor_quit_key='<Esc>'
" nnoremap -<C-c> :call multiple_cursors#quit()<CR>

" let g:multi_cursor_exit_from_visual_mode=1
" let g:multi_cursor_exit_from_insert_mode=0


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better diff {{{

Plugin 'AndrewRadev/linediff.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" run make or jobs asynchronously {{{

Plugin 'tpope/vim-dispatch'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better quickfix window {{{

" edit quickfix list (make changes directly after global search or linting)
Plugin 'Olical/vim-enmasse'


" automatically resize quickfix window
Plugin 'blueyed/vim-qf_resize'

let g:qf_resize_min_height = 1
let g:qf_resize_max_height = 8


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plugin 'shinokada/dragvisuals.vim'
"vmap <expr> <C-H>  DVB_Drag('left')
"vmap <expr> <C-L>  DVB_Drag('right')
"vmap <expr> <C-J>  DVB_Drag('down')
"vmap <expr> <C-K>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plugin 'zirrostig/vim-schlepp'

vmap <up>    <Plug>SchleppUp
vmap <down>  <Plug>SchleppDown
vmap <left>  <Plug>SchleppLeft
vmap <right> <Plug>SchleppRight

" duplicate
" (delete selection with x. by default, x and d do the same)
vmap -u <Plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plugin 'vim-scripts/toggle_words.vim'

noremap <silent> -tw :ToggleWord<CR>

let g:toggle_words_dict = {
            \ 'css': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['header', 'footer'],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ['0', '1'],
            \     ['add', 'remove'],
            \     ['and', 'or'],
            \     ['ascending', 'descending'],
            \     ['ASC', 'DESC'],
            \     ['begin', 'end'],
            \     ['big', 'little'],
            \     ['black', 'white'],
            \     ['clean', 'dirty'],
            \     ['create', 'delete'],
            \     ['dark', 'light'],
            \     ['deep', 'shallow'],
            \     ['dynamic', 'static'],
            \     ['enable', 'disable'],
            \     ['enabled', 'disabled'],
            \     ['fast', 'slow'],
            \     ['fat', 'thin'],
            \     ['forward', 'backward'],
            \     ['get', 'set'],
            \     ['good', 'bad'],
            \     ['happy', 'sad'],
            \     ['hard', 'soft'],
            \     ['head', 'tail'],
            \     ['hide', 'show'],
            \     ['high', 'low'],
            \     ['header', 'footer'],
            \     ['in', 'out'],
            \     ['initialize', 'terminate'],
            \     ['initialization', 'termination'],
            \     ['inner', 'outer'],
            \     ['left', 'right'],
            \     ['light', 'dark'],
            \     ['local', 'global'],
            \     ['long', 'short'],
            \     ['love', 'hate'],
            \     ['many', 'few'],
            \     ['master', 'slave', 'develop'],
            \     ['min', 'max'],
            \     ['more', 'less'],
            \     ['new', 'old'],
            \     ['next', 'previous'],
            \     ['on', 'off'],
            \     ['online', 'offline'],
            \     ['open', 'close'],
            \     ['present', 'absent'],
            \     ['question', 'answer'],
            \     ['red','orange','yellow','green','blue','purple'],
            \     ['setup', 'teardown'],
            \     ['single', 'double', 'multi'],
            \     ['start', 'stop'],
            \     ['started', 'stopped'],
            \     ['starting', 'stopping'],
            \     ['strong', 'weak'],
            \     ['testing', 'production'],
            \     ['this', 'that'],
            \     ['top', 'bottom'],
            \     ['true', 'false'],
            \     ['up', 'down'],
            \     ['wide', 'narrow'],
            \     ['width', 'height'],
            \     ['yes', 'no'],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plugin 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger='<C-k>'
"let g:UltiSnipsListSnippets='<Esc>.'
let g:UltiSnipsJumpForwardTrigger='<C-i>'
let g:UltiSnipsJumpBackwardTrigger='<C-o>'
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'sflipsnippets']


" snippet packs
Plugin 'honza/vim-snippets'


" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced autocompletion engine {{{
"
" Remember: YCM is a plugin with a compiled component. If you update YCM using
" Vundle and the ycm_support_libs library APIs have changed (happens rarely),
" YCM will notify you to recompile it. You should then rerun the install
" process.

" Plugin 'Valloric/YouCompleteMe'
" let g:ycm_server_python_interpreter = '/usr/bin/python3'
" let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
let g:ycm_key_invoke_completion = '<Esc>.'
let g:ycm_key_list_select_completion   = ['<C-N>', '<Down>', '<Tab>', '<Enter>']
let g:ycm_key_list_previous_completion = ['<C-P>', '<Up>']
" let g:ycm_show_diagnostics_ui = 0


" autocompletion in command mode
Plugin 'vim-scripts/CmdlineComplete'
cmap <C-p> <Plug>CmdlineCompleteBackward
cmap <C-n> <Plug>CmdlineCompleteForward


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" generate docs {{{

" generate javascript docs
Plugin 'heavenshell/vim-jsdoc'
" nnoremap <silent> -adj ?function<cr>:noh<cr><Plug>(jsdoc)
nnoremap <silent> -adj :JsDoc<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

" show indentation level
Plugin 'Yggdroot/indentLine'
let g:indentLine_enabled = 1
let g:indentLine_char = '┊'
nnoremap <C-G>I :IndentLinesToggle<CR>

" Does not work. TODO: Fix it!
augroup indentline_enabled
    au!
    au BufWinEnter */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ IndentLinesDisable
                " \ echo 'jaaa' | IndentLinesDisable
augroup END


" align plugin
Plugin 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-l=)
xmap -l <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -lG=)
nmap -l <Plug>(EasyAlign)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

Plugin 'Chiel92/vim-autoformat'

" install formatters on the system:
" - js-beautify (for HTML, CSS, JavaScript, JSON)
" - scalafmt (for scala)

nnoremap -af :Autoformat<CR>
vnoremap -af :Autoformat<CR>
nmap <Leader>af -af
vmap <Leader>af -af

let g:formatdef_scalafmt = "'scalafmt --stdin'"
let g:formatters_scala = ['scalafmt']


" autoformat for json does not work out with the plugin above. do this instead:
augroup json_map_autoformat
    au!
    au FileType json nnoremap -af :%!python -m json.tool<CR>
    au FileType json nmap <Leader>af -af
augroup END



" change wrapping of function arguments
Plugin 'FooSoft/vim-argwrap'

nnoremap <silent> -tf :ArgWrap<CR>



" coercion:
" - MixedCase (crm),
" - camelCase (crc),
" - snake_case (crs),
" - UPPER_CASE (cru),
" - dash-case (cr-),
" - dot.case (cr.),
" - space case (cr<space>),
" - Title Case (crt)
Plugin 'tpope/vim-abolish'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" don't worry about 'shiftwidth' and 'expandtab' etc. {{{

Plugin 'tpope/vim-sleuth'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plugin 'vim-scripts/ShowTrailingWhiteSpace'
let g:ShowTrailingWhitespace = 1
command! -bar ShowTrailingWhitespaceOn  call ShowTrailingWhitespace#Set(1,1)
command! -bar ShowTrailingWhitespaceOff call ShowTrailingWhitespace#Set(0,1)
command! -bar ShowTrailingWhitespaceToggle call ShowTrailingWhitespace#Toggle(0)
        \ <Bar>echo (ShowTrailingWhitespace#IsSet() ?
        \ 'Show trailing whitespace' : 'Not showing trailing whitespace')
nnoremap <silent> <C-G>A  :ShowTrailingWhitespaceToggle<CR>
nnoremap <silent> <C-G>st :ShowTrailingWhitespaceToggle<CR>

" (has a bug)
"Plugin 'vim-scripts/JumpToTrailingWhiteSpace'


Plugin 'vim-scripts/DeleteTrailingWhiteSpace'

" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'ask'

" enable/disable plugin
nnoremap <Leader>dst :let g:DeleteTrailingWhitespace = 1 - g:DeleteTrailingWhitespace<CR>
            \ :echo g:DeleteTrailingWhitespace == 1 ?
            \ 'DeleteTrailingWhitespace enabled' :
            \ 'DeleteTrailingWhitespace disabled'<CR>
" delete trailing whitespace for selected line
vnoremap <silent> -dst :DeleteTrailingWhitespace<CR>
" delete trailing whitespace for whole buffer
nnoremap <silent> -dst :%DeleteTrailingWhitespace<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make #DD8844 appear orange etc
Plugin 'ap/vim-css-color'

" launch colorpicker and insert color code
Plugin 'blindFS/vim-colorpicker'
nnoremap <Leader>cp :ColorPicker<CR>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plugin 'KabbAmine/vCoolor.vim'
"nnoremap <Leader>cp :VCoolor<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Language specific stuff {{{


Plugin 'sheerun/vim-polyglot'



" Language: fish

Plugin 'dag/vim-fish'


" Language: javascript

augroup javascript_on_read
    au!
    au FileType javascript call SetupJavascript()
augroup END
function! SetupJavascript()
    nnoremap <Leader>bi  :call VimuxRunCommand("clear; npm install")<CR>
    nnoremap <Leader>bs  :call VimuxRunCommand("clear; npm start")<CR>
    nnoremap <Leader>btt :call VimuxRunCommand("clear; npm test")<CR>
    nnoremap <Leader>btu :call VimuxRunCommand("clear; npm test-unit")<CR>
    nnoremap <Leader>bti :call VimuxRunCommand("clear; npm test-int")<CR>
endfunction


" Language: LaTeX

Plugin 'lervag/vimtex'

let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'
let g:vimtex_quickfix_ignore_all_warnings=1
let g:vimtex_quickfix_mode=0

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

augroup map_latex
    au!
    au FileType latex nnoremap <Leader>bl :VimtexCompileToggle<CR>
augroup END


" Language: python

augroup python_on_read
    au!
    au FileType python call SetupPython()
augroup END
function! SetupPython()
    nnoremap <Leader>bs  :call VimuxRunCommand("clear; python " . expand('%'))<CR>
    nnoremap <Leader>b2  :call VimuxRunCommand("clear; python2 " . expand('%'))<CR>
    nnoremap <Leader>b3  :call VimuxRunCommand("clear; python3 " . expand('%'))<CR>
endfunction


" Language: R

if v:version > 704 || v:version == 704 && has("patch1829")
    Plugin 'jalvesaq/Nvim-R'
    " use with tmux
    let R_in_buffer = 0
    let R_applescript = 0
    let R_tmux_split = 1
    let R_vsplit = 1
    let R_rconsole_width = 80
    " custom keybindings
    let R_user_maps_only = 1
    augroup NvimR
        au!
        au FileType r nmap <C-r>s           <Plug>RStart
        au FileType r nmap <C-r>q           <Plug>RClose
        au FileType r nmap <C-r><C-l>       <Plug>RClearConsole
        au FileType r nmap <Leader><Enter>  <Plug>RSendFile
        au FileType r nmap <Enter>          <Plug>RSendLine
        au FileType r xmap <Enter>          <Plug>RSendSelection
    augroup END
endif


" Language: Scala

Plugin 'derekwyatt/vim-scala'
Plugin 'derekwyatt/vim-sbt'
Plugin 'mdreves/vim-scaladoc'
nnoremap <leader>sd :call scaladoc#Search(expand("<cword>"))<CR>

" Plugin 'ensime/ensime-sbt', { 'branch': '2.0', 'for': 'scala' }
" Plugin 'ensime/ensime-server', { 'branch': '2.0', 'for': 'scala' }
" Plugin 'ensime/ensime-vim', { 'for': 'scala' }
" augroup map_scala
    " au!
    " au FileType scala
                " \ nnoremap <Leader>9d :EnDeclaration<CR> |
                " \ nnoremap <Leader>9D :EnDeclarationSplit v<CR> |
                " \ nnoremap <Leader>9x :EnDocBrowse<CR> |
                " \ nnoremap <Leader>9t :EnType<CR> |
                " \ " nnoremap <Leader>9t :EnInspectType<CR> |
                " \ nnoremap <Leader>9T :EnTypeCheck<CR> |
                " \ nnoremap <Leader>9ö :EnSearch<Space> |
                " \ nnoremap <Leader>9r :EnRename<CR> |
                " \ nnoremap <Leader>9i :EnOrganizeImports<CR> |
                " \ nnoremap <Leader>9I :EnSugestImport<CR> |
                " \ nnoremap <Leader>9 <NOP>
" augroup END

" scala and ctags:
" https://advancedweb.hu/2017/01/10/vim-scala-ag-ctags/
" plugin that also creates ctags for libaries (can be slow and huge files):
" Plugin 'ceedubs/sbt-ctags'

" show sbt errors in the quickfix window
" Plugin 'dscleaver/sbt-quickfix'
" (does not work and is not necessary: https://gist.github.com/nkpart/5945278)

" :!sbt -Dsbt.log.noformat=true compile 2>&1 >/tmp/sbt.out
" let g:cfile = system('ag -l "\[(error|warn)\]" target/streams/ | head -n 1')
" let g:cfile_escaped = substitute(g:cfile, "\\$", "\\\\$", "g")

augroup scala_on_read
    au!
    au FileType scala call SetupScala()
augroup END
function! SetupScala()
    set errorformat=
                \%E\ %#[error]\ %f:%l:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                \%W\ %#[warn]\ %f:%l:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                \%-G%.%#
    " the lines above work for compiler errors
    " the lines below are for testing errors but do not work yet
    " (for example because the file path is not absolute)
    " (also, I'm a noob with the efm matching syntax)
                " \%E\ \%#[info]%.%#was\ not\ equal\ to%.%#(%f:%l),%Z,
                " \%E\ \%#[info]\ %.%#\ was\ not\ equal\ to\ %.%#\ (%f:%l),%Z,
                " \%E\ %#[info]\ %.%#\ ***\ FAILED\ ***,%C\ %#[info]\ %m\ (%f:%l)%Z,
    match ErrorMsg '\*\*\* FAILED \*\*\*'
    nnoremap <Leader>bd  :call VimuxRunCommand("set TERM xterm-color; clear; sbt compile")<CR>
    nnoremap <Leader>bs  :call VimuxRunCommand("set TERM xterm-color; clear; sbt run")<CR>
    nnoremap <Leader>btt :call VimuxRunCommand("set TERM xterm-color; clear; sbt test it:test")<CR>
    nnoremap <Leader>btu :call VimuxRunCommand("set TERM xterm-color; clear; sbt test")<CR>
    nnoremap <Leader>bti :call VimuxRunCommand("set TERM xterm-color; clear; sbt it:test")<CR>
    nnoremap <Leader>br  :call VimuxRunCommand("set TERM xterm-color; clear; sbt console")<CR>
    nnoremap <Leader>bD  :call MakeWithVimux("set TERM xterm-color; clear; sbt -Dsbt.log.noformat=true compile")<CR>
    nnoremap <Leader>bS  :call MakeWithVimux("set TERM xterm-color; clear; sbt -Dsbt.log.noformat=true run")<CR>
    nnoremap <Leader>btT :call MakeWithVimux("set TERM xterm-color; clear; sbt -Dsbt.log.noformat=true test it:test")<CR>
    nnoremap <Leader>btU :call MakeWithVimux("set TERM xterm-color; clear; sbt -Dsbt.log.noformat=true test")<CR>
    nnoremap <Leader>btI :call MakeWithVimux("set TERM xterm-color; clear; sbt -Dsbt.log.noformat=true it:test")<CR>
    nnoremap <Leader>bE  :call MakeWithVimuxOpenErrors('buffer')<CR>gg/\*\*\* FAILED \*\*\*<CR>
    nnoremap <Leader>fe  /\*\*\* FAILED \*\*\*<CR>
endfunction

" augroup scala_on_write
    " au!
    " au BufWritePost *.scala Dispatch! sbt -Dsbt.log.noformat=true parse
" augroup END


" TODO: find fzf scala docs


" Language: SQL
augroup sql_on_read
    au!
    au FileType sql call SetupSQL()
augroup END
function! SetupSQL()
    nnoremap <Leader>bm  :call VimuxRunCommand("\\. " . expand('%:p'))<CR>
    nnoremap <Leader>bp  :call VimuxRunCommand("\\i " . expand('%:p'))<CR>
endfunction



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plugin 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <Leader>ut :GundoToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    " finish vundle
    call vundle#end()
    filetype plugin indent on

    " THE FOLLOWING MUST BE EXECUTED AFTER VUNDLE FINISHED:

    " call camelcasemotion#CreateMotionMappings(',')

    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping)
    call yankstack#setup()

    " fix s mapping
    " (must be executed after yankstack#setup())
    nmap s <Plug>Sneak_S


endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" options {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=1200

" always assume modern terminal
set ttyfast
" don't draw everything (e.g. when playing macros)
set ttyfast
set lazyredraw

" allow mouse usage for bad days
if has('mouse')
    set mouse=a
endif

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8
" <EOL> line ending philosophies to try
" set fileformats=unix,dos,mac

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread

" automatically save buffer when it loses focus
if s:MyMode == 'mastery'
    let g:autosave = 1
else
    let g:autosave = 0
endif
augroup autosave
    au!
    au BufLeave,FocusLost * if (g:autosave && !exists("b:local_autosave"))
                          \ || (g:autosave && exists("b:local_autosave") && b:local_autosave)
                          \ || (!g:autosave && exists("b:local_autosave") && b:local_autosave)
    au BufLeave,FocusLost *     silent! update
    au BufLeave,FocusLost * endif
augroup END

" automatically change working directory to current file
" set autochdir

" command history size
set history=9999

" do not create swap files (they annoy me more than they help)
set noswapfile

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" meta files (like tagfiles)
set tags+=.tags

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable
set synmaxcol=300

" highlight matching bracket when typing
" set showmatch
" set matchtime=4

" do not wrap lines until I say so
set nowrap

" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = 0
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter,FocusLost   * set nocursorline nocursorcolumn
    au WinEnter,InsertLeave,FocusGained * if g:cursorposition
    au WinEnter,InsertLeave,FocusGained *     set cursorline cursorcolumn
    au WinEnter,InsertLeave,FocusGained * endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2
set noshowmode

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignorecase
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
set wildignore+=*.o,*.obj,*.pyc,*.class
set wildignore+=*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.odt,*.ods
set wildignore+=*.jpg,*.jpeg,*.png
set wildignore+=*.mp3,*.mp4,*.mpg,*.mpeg,*.flv,*.wav
set wildignore+=*.aux,*.bbl,*.blg,*.fdb_latexmk,*.fls,*.loe,*.lof,*.out,*.toc

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=5
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
set gdefault
set nohlsearch
set nowrapscan

" allow the cursor to move where there is no character
set virtualedit=block,insert,onemore


" characters to show in list mode
if v:version > 704 || v:version == 704 && has("patch711")
    set listchars=space:·,tab:--,extends:❯,precedes:❮
else
    set listchars=tab:--,extends:❯,precedes:❮
endif

" how it looks like if we wrap lines
if v:version > 704 || v:version == 704 && has("patch338")
    set breakindent
endif
set showbreak=↪

" how other stuff looks like
set fillchars+=vert:\ "
set fillchars+=fold:─

" use 4 spaces instead of tabs
" (otherwise handled by sleuth)
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" 1 space, not 2, when joining sentences
set nojoinspaces

" allow <BS> to delete everything
set backspace=indent,eol,start

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright



" }}}


" colorscheme {{{

if s:MyMode == 'mastery'

    " DARK THEMES

    set background=dark

    " colorscheme apprentice
    " colorscheme badwolf
    " colorscheme blackboard
    " colorscheme blacklight
    " colorscheme candycode
    " colorscheme dante
    " colorscheme desertEx
    colorscheme gruvbox
    " colorscheme iceberg
    " colorscheme jellybeans
    " colorscheme luna-term
    " colorscheme meta5
    " colorscheme materialbox
    " colorscheme molokai
    " colorscheme onedark
    " colorscheme pride
    " colorscheme seoul256
    " colorscheme Tomorrow-Night
    " colorscheme up
    " colorscheme woju

    let g:airline_theme='base16'
    " let g:airline_theme='base16_summerfruit'
    " let g:airline_theme='base16_grayscale'
    " let g:airline_theme='behelit'
    " let g:airline_theme='distinguished'
    " let g:airline_theme='kalisi'
    " let g:airline_theme='laederon'
    " let g:airline_theme='lucius'
    " let g:airline_theme='minimalist'
    " let g:airline_theme='raven'
    " let g:airline_theme='serene'
    " let g:airline_theme='tomorrow'
    " let g:airline_theme='ubaryd'
    " let g:airline_theme='wombat'
    " let g:airline_theme='zenburn'

    let g:indentLine_setColors = 1
    let g:indentLine_color_term = 236

    highlight CursorLine              ctermbg=236 cterm=NONE
    highlight CursorColumn            ctermbg=236
    highlight ColorColumn             ctermbg=237
    highlight DiffAdd                 ctermbg=234
    highlight DiffDelete              ctermbg=234
    highlight DiffChange              ctermbg=234
    highlight DiffText                ctermbg=233
    highlight ShowTrailingWhitespace  ctermbg=235
    highlight VertSplit               ctermfg=238
    highlight Folded                  ctermfg=238 ctermfg=248
    highlight LineNr                  ctermbg=237 ctermfg=243
    " highlight SignColumn              ctermbg=237
    " highlight GitGutterAdd            ctermbg=235
    " highlight GitGutterChange         ctermbg=235
    " highlight GitGutterDelete         ctermbg=235
    " highlight GitGutterChangeDelete   ctermbg=235
    highlight Conceal                 ctermbg=237
    " highlight Search                  ctermbg=237 ctermfg=white
    highlight Error                   ctermbg=162
    highlight Todo                    ctermfg=132
    highlight EasyMotionTarget        ctermfg=72
    highlight EasyMotionTarget2First  ctermfg=72
    highlight EasyMotionTarget2Second ctermfg=108


    " LIGHT THEMES

    " set background=light

    " colorscheme lucius
    " colorscheme peaksea
    " colorscheme seoul256-light
    " colorscheme Tomorrow-Night

    " let g:airline_theme='bubblegum'
    " let g:airline_theme='lucius'
    " let g:airline_theme='sol'

    " highlight CursorLine   ctermbg=252
    " highlight CursorColumn ctermbg=252
    " highlight ColorColumn  ctermbg=250
    " highlight ShowTrailingWhitespace ctermbg=250

else

    " fallback colorscheme
    colorscheme desert

    let g:cursorposition = 0
    set nocursorcolumn nocursorline
    highlight CursorLine   ctermbg=233
    highlight CursorColumn ctermbg=233
    highlight ColorColumn  ctermbg=233

endif

" }}}




" cursor change in insert mode (from block to i-beam) {{{

" http://stackoverflow.com/questions/6488683/how-do-i-change-the-vim-cursor-in-insert-normal-mode

" escape sequence depends on the terminal ('konsole', 'urxvt')
let terminal='urxvt'



if terminal == 'konsole'
    " (this also resets the terminal font size, which is annoying)
    if exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    else
        let &t_SI = "\<Esc>]50;CursorShape=1\x7"
        let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    endif
elseif terminal == 'urxvt'
    let &t_SI = "\e[6 q"
    let &t_EI = "\e[2 q"
endif



" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" toggle syntax highlighting {{{
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction
" }}}


" get a list of buffers {{{
function! GetBufferList()
  silent! redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction
" }}}



" redraw the screen in case some git things don't keep up with shit {{{
function! GitRedraw()
    if exists(':GitGutterAll') == 2
        GitGutterAll
    endif
endfunction
" }}}



" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}


" return 1 iff the active window contains a quickfix buffer and there are no
" other windows with normal buffers.
function! IsOrphanQuickfixList()
    let winnr = winnr("$")
    while winnr >= 1
        if getbufvar(winbufnr(winnr), "&buftype") == ""
            return 0
        endif
        let winnr -=1
    endwhile
    return getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"
endfunction
" improve quickfix/location list
augroup quickfix
    au!
    " automatically close quickfix/location list when alone
    au BufEnter * if IsOrphanQuickfixList()
    au BufEnter *     bdelete
    au BufEnter * endif
augroup END




" make columns after &textwidth visible or invisible {{{
function! ToggleColorColumn()
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if &colorcolumn == "" || &colorcolumn != expr
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}

"... and call this function when &textwidth is changed
if v:version > 704 || v:version == 704 && has("patch786") " if has ('patch-7.4.786')
    augroup colorcolumn
        au!
        au OptionSet textwidth if &textwidth != 0
        au OptionSet textwidth      call ToggleColorColumn()
        au OptionSet textwidth else
        au OptionSet textwidth      set colorcolumn=
        au OptionSet textwidth endif
    augroup END
endif



" Search across newlines {{{
" separated with whitespace (if no '!'),
" or with non-word characters (if '!' added to command).
" http://vim.wikia.com/wiki/Search_across_multiple_lines
function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag SearchMultiLine call SearchMultiLine(<bang>0, <f-args>)|normal! /<C-R>/<CR>

" }}}



" Search for current word and replace with given text for files in arglist. {{{
" http://vim.wikia.com/wiki/Search_and_replace_in_multiple_buffers
function! Replace(bang, replace)
    " (we use 'gdefault')
    " let flag = 'ge'
    let flag = 'gge'
    if !a:bang
        let flag .= 'c'
    endif
    let search = '\<' . escape(expand('<cword>'), '/\.*$^~[') . '\>'
    let replace = escape(a:replace, '/\&~')
    execute 'argdo %s/' . search . '/' . replace . '/' . flag
endfunction
command! -nargs=1 -bang Replace :call Replace(<bang>0, <q-args>)

" }}}


" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\S)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\S)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\S)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters below {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num
    let linenumber = line(".")
    call append(linenumber, repeat(char, num))
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    let linenumber = line(".")
    let line = getline(".")
    let len = strlen(line) + 2 + 2
    let borderline = repeat(char, len)
    execute '.substitute/^/' . char . ' /'
    execute '.substitute/$/ ' . char . '/'
    call append(linenumber, repeat(char, len))
    call append(linenumber-1, repeat(char, len))
endfunction
" }}}



" ranger as a file chooser {{{
function! RangerChooser(starting_dir)
    let temp = tempname()
    " The option "--choosefiles" was added in ranger 1.5.1. Use the next line
    " with ranger 1.4.2 through 1.5.0 instead.
    "exec 'silent !ranger --choosefile=' . shellescape(temp)
    if has("gui_running")
        let command = 'silent !xterm -e ranger'
    else
        let command = 'silent !ranger'
    endif
    exec command . ' --choosefiles=' . shellescape(temp) . ' --cmd="set viewmode\!" ' . a:starting_dir
    if !filereadable(temp)
        redraw!
        " Nothing to read.
        return
    endif
    let names = readfile(temp)
    if empty(names)
        redraw!
        " Nothing to open.
        return
    endif
    " Edit the first item.
    exec 'edit ' . fnameescape(names[0])
    " Add any remaning items to the arg list/buffer list.
    for name in names[1:]
        exec 'argadd ' . fnameescape(name)
    endfor
    redraw!
endfunction
command! -bar RangerChooser call RangerChooser(getcwd())
" }}}



" change search mode (what happens when hitting n) {{{
" http://vim.wikia.com/wiki/Make_search_results_appear_in_the_middle_of_the_screen
function! s:SearchMode()
  if !exists('s:searchmode') || s:searchmode == 0
    echo 'Search next: scroll as few times as possible (smart)'
    nnoremap <silent> n n:call <SID>MaybeScroll()<CR>zv
    nnoremap <silent> N N:call <SID>MaybeScroll()<CR>zv
    let s:searchmode = 1
  elseif s:searchmode == 1
    echo 'Search next: scroll hit to middle'
    nnoremap n nzzzv
    nnoremap N Nzzzv
    let s:searchmode = 2
  else
    echo 'Search next: normal'
    " nunmap n
    " nunmap N
    nnoremap n nzv
    nnoremap N Nzv
    let s:searchmode = 0
  endif
endfunction
" If cursor is on top, scroll to bottom, if it is on bottom, scroll to top
function! s:MaybeScroll()
  if winline() == &scrolloff + 1
    normal! zb
  elseif winline() == winheight(0) - &scrolloff
    normal! zt
  endif
endfunction

" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" send buffer via slack {{{
function! SendBufferViaSlack(channel)
    let content = getline(1, '$')
    exec "write !slackcat -c " . a:channel
endfunction
" }}}


" send buffer via slack after choosing channel interactively {{{
function! SendBufferViaSlackChooseChannel()
    let content = system("slackcat --list")
    echo content
    let choice = input("Which channel: ")
    call SendBufferViaSlack(choice)
endfunction
nnoremap <Leader>iS :call SendBufferViaSlackChooseChannel()<CR>
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

" add highlighted word
nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" remove highlighted words
nnoremap <silent> <leader>0
    \ :silent! call matchdelete(86751)<bar>
    \ :silent! call matchdelete(86752)<bar>
    \ :silent! call matchdelete(86753)<bar>
    \ :silent! call matchdelete(86754)<bar>
    \ :silent! call matchdelete(86755)<bar>
    \ :silent! call matchdelete(86756)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" handle binary documents {{{

augroup read_special_files
    au!
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}
                \ call s:filter_special_files()
augroup END

fu! s:filter_special_files() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif
    let fname = shellescape(expand('%:p'), 1)
    let ext = expand('%:e')
    let ext2cmd = {
    \               'doc' : '%!antiword '.fname,
    \               'docx': '%!pandoc -f docx -t markdown '.fname,
    \               'epub': '%!pandoc -f epub -t markdown '.fname,
    \               'odp' : '%!odt2txt '.fname,
    \               'odt' : '%!odt2txt '.fname,
    \               'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
    \               'rtf' : '%!unrtf --text',
    \             }
    if has_key(ext2cmd, ext)
        setl ma noro
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl noma ro nomod
    endif
endfu

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  KEYMAP SECTION                                                              "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{



let mapleader=' '


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FIX MY TYPING {{{

iabbrev todo TODO


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" (for compatibility)
nnoremap <C-G><C-G> <C-G>

" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<CR>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<CR>
"endif
"nnoremap <Leader><F5> :MyRefresh<CR>


" show absolute path of current file (':help filename-modifiers')
nnoremap <Leader><C-G> :echo expand("%:~")<CR>

" if in a git directory and there are dirty files, open them
" nnoremap <Leader>eG :silent! args `git diff --name-only`<CR>:bd#<CR>
function! EditGitDirtyFiles()
    let numberOfGitDirtyFiles = system("git status --porcelain 2>/dev/null \| egrep '^(M\| M)' \| wc -l")
    if numberOfGitDirtyFiles != 0
        silent! args `git diff --name-only`
        " if vim was just started, let's get rid of the first unnamed buffer:
        if empty(getbufinfo()[0]['name'])
            bd 1
        endif
        " TODO: avoid error with already openend windows
    else
        echo 'Working directory clean'
    endif
endfunction
nnoremap <Leader>eG :call EditGitDirtyFiles()<CR>

" open config file
"nnoremap <Leader>ev :edit ~/dotfiles/vim/vimrc<CR>
nnoremap <Leader>ev :execute 'edit ' . resolve(expand($MYVIMRC))<CR>
nnoremap <Leader>e3 :edit ~/.i3/config<CR>

" reload config file
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <F5>       :source $MYVIMRC<CR>


" to follow links in help and jump to definition (ctags)
nnoremap <M-Enter>    <C-]>
nnoremap <Esc><Enter> <C-]>
augroup map_enter_help
    au!
    au BufReadPost */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ nnoremap <buffer> <Enter> <C-]>
augroup END
nnoremap <Leader><Down> :tn<CR>
nnoremap <Leader><Up>   :tp<CR>


" visual block mode is more useful than visual mode
nnoremap v <C-v>
nnoremap <C-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <C-c>


" copy to clipboard / primary selection
nnoremap         <C-c>     "+y
nnoremap    <C-c><C-c>    V"*ygv"+y
nnoremap <Leader><C-c> ggVG"*ygv"+y<C-o><C-o>
vnoremap         <C-c>     "*ygv"+y

" paste from clipboard / primary selection {{{
function! PasteFromGUI()
    let clipbrd = @+
    let primary = @*
    if len(primary) == 0
        normal "+P
    elseif len(clipbrd) == 0
        normal "*P
    elseif primary == clipbrd
        normal "*P
    else
        ec "Paste (c)lipboard (default)    " . strtrans(strpart(clipbrd, 0, 50))
        ec "or    (p)rimary selection?     " . strtrans(strpart(primary, 0, 50))
        let c = getchar()
        if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
            redraw
        elseif nr2char(c) == 'c' || nr2char(c) == '+' || c == 13 || c == 22
            normal "+P
            redraw
        elseif nr2char(c) == 'p' || nr2char(c) == 's' || nr2char(c) == '*'
            normal "*P
            redraw
        endif
    endif
endfunction
" }}}
noremap <silent> <C-v><C-v> :call PasteFromGUI()<CR>
imap <C-v><C-v> <C-o><C-v><C-v>
noremap <silent> <C-v>j o<Esc>:call PasteFromGUI()<CR>
noremap <silent> <C-v>k O<Esc>:call PasteFromGUI()<CR>



" macro ('complex repeat') without worrying about registers
" record macro (start and stop) with <Leader>Q
" replay macro with <Leader>q
" nnoremap @{ :nmap <Leader<Left><Right>>Q @}<CR>qq
" nnoremap @} q:nmap <Leader<Left><Right>>Q @{<CR>:echo ''<CR>
" nmap     <Leader>Q @{
" nnoremap <Leader>q @q

" macro ('complex repeat') with registers
" (remapping q is bad, because it is used to close stuff like plugin windows)
nnoremap Q @
nnoremap QQ @@



" alternative way to go back to normal mode
inoremap jk <Esc>
cnoremap jk <C-c>
cnoremap <C-g> <C-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll with arrow keys if i lay back
"nnoremap <Down> <C-E>
"nnoremap <Up>   <C-Y>

" scroll a little smoother (but still without plugin)
" (this actually is suggested in :help scroll-smooth)
noremap <M-j>  <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <Esc>j <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <M-k>  <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
noremap <Esc>k <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)


" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))
autocmd FileType help wincmd L

" write changes with root permissions
cnoremap w!! w !sudo tee % >/dev/null
"cnoreabbrev w!! w !sudo tee % >/dev/null

" have the up/down search functionality without reaching to the arrow keys
cnoremap <C-j> <down>
cnoremap <C-k> <up>





" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{


" change text width
nnoremap <Leader>ow0 :set textwidth=0<CR>
nnoremap <Leader>ow5 :set textwidth=50<CR>
nnoremap <Leader>ow7 :set textwidth=78<CR>
nnoremap <Leader>ow8 :set textwidth=80<CR>
nnoremap <Leader>ow1 :set textwidth=100<CR>
nnoremap <Leader>ow2 :set textwidth=120<CR>

" change tab width (soft)
nnoremap <Leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>
nnoremap <Leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
nnoremap <Leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<CR>

" toggle paste mode
nnoremap <Leader>op :set paste! <bar> :set paste?<CR>

" toggle autosave ('autowrite')
nnoremap <silent> <Leader>oWW
            \ :if !exists("b:local_autosave") <bar> let b:local_autosave = 0 <bar> endif <CR>
            \ :let b:local_autosave = 1 - b:local_autosave <CR>
            \ :echo b:local_autosave == 1 ?
            \ 'autosave enabled for local buffer' :
            \ 'autosave disabled for local buffer'<CR>
nnoremap <silent> <Leader>oWA
            \ :let g:autosave = 1 - g:autosave <CR>
            \ :echo g:autosave == 1 ?
            \ 'autosave enabled' :
            \ 'autosave disabled'<CR>

" toggle search preferences
nnoremap <Leader>os :set hlsearch! <bar> :set hlsearch?<CR>
nnoremap <Leader>oS :set wrapscan! <bar> :set wrapscan?<CR>

" ... but ignore typos
nnoremap <Leader>o <NOP>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <C-G>y :call ToggleSyntax()<CR>

" toggle line numbers
noremap <silent> <C-G>l :set number! <bar> :set relativenumber! <CR>
noremap <silent> <C-G>L :set relativenumber! <CR>

" toggle word wrap
nnoremap <silent> <C-G>w :setlocal wrap! <bar> :set wrap? <CR>

" toggle vertical ruler
nnoremap <silent> <C-G>r :call ToggleColorColumn()<CR>
nnoremap <silent> <C-G>R :highlight ColorColumn ctermbg=235
                  \ <Bar> highlight clear BGdd8844
                  \ <Bar> highlight clear BG000000
                  \ <Bar> highlight clear BGffa724
                  \ <Bar> highlight clear BGaeee00
                  \ <Bar> highlight clear BG8cffba
                  \ <Bar> highlight clear BGb88853
                  \ <Bar> highlight clear BGff9eb8
                  \ <Bar> highlight clear BGff2c4b
                  \ <CR>


" toggle highlight current cursor position
nnoremap <silent> <C-G>c :let g:cursorposition = 1 - g:cursorposition <CR>i<Esc>

" toggle show listchars (like whitespace)
nnoremap <silent> <C-G>a :set list!<CR>


" spell checking
nnoremap <C-G>ss :setlocal spell! <bar> :set spell? <CR>
nnoremap <C-G>se :setlocal spelllang=en<CR>
nnoremap <C-G>sd :setlocal spelllang=de<CR>
nmap <C-G>sg <C-G>sd

" ... but ignore typos
nnoremap <C-G> <NOP>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{


" move intuitively when text is wrapped
nnoremap j gj
nnoremap k gk

" move faster
nnoremap gj 8j
nnoremap gk 8k
vnoremap gj 8j
vnoremap gk 8k


" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <C-b>  <Left>
noremap! <C-f>  <Right>
noremap! <C-d>  <Delete>
" ... by words
noremap! <M-b>  <S-Left>
noremap! <M-f>  <S-Right>
cnoremap <Esc>b <S-Left>
cnoremap <Esc>f <S-Right>


" move to BOL
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <C-A> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <C-A> <C-O><C-A>

" move to EOL
nnoremap <C-E> $
vnoremap <C-E> $
onoremap <C-E> $
inoremap <C-E> <End>
cnoremap <C-A> <Home>
" move to EOL with l instead of $
onoremap l $

" ... but current character movement is useful sometimes
nnoremap ch cl
nnoremap yh yl

" swap , and ;
" (makes more sense on german keyboard)
" nnoremap , ;
" nnoremap ; ,
nnoremap g, g;
nnoremap g; g,


" swap ` and ' (jump to markers)
" (by default, ' marked line, ` marked line and column)
nnoremap ' `
nnoremap ` '

" goto mark
nnoremap Ä `

" goto last edit
nnoremap <Leader>. `.zzzv


" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{


" search in this buffer
if s:MyMode == 'stripped'
    nnoremap ö /
    nnoremap Ö ?
endif


" restart search from BOF/EOF
" (is useful when 'nowrapscan' is set)
" nmap gö 1Gn
nmap gÖ G$N
" nmap gö :keepjumps normal 1G<CR>n " does not work
" nmap gÖ :keepjumps normal G$<CR>N " does not work
nmap <silent> gö :ijump! 1    /<C-R>/<CR>zv
" nmap gÖ :ijump! 9999 /<C-R>/<CR> " does not work


" number of occurrences
nnoremap <Leader>n* *<C-O>:%s///ngg<CR>
nnoremap <Leader>nö  :%s:<C-R>/::ngg<CR>
xnoremap <Leader>nö y:%s:\V<C-R>"::ngg<CR>



" search in multiple files
if s:MyMode == 'stripped'
    nnoremap <Leader>ö
            \ :call ToggleList("Quickfix List", 'c')<CR>
            \ :vimgrep // **/*<Left><Left><Left><Left><Left><Left>
endif



" find next and previous occurence like usual when we searched backwards
" nnoremap <expr> n  'Nn'[v:searchforward]
" nnoremap <expr> N  'nN'[v:searchforward]

" keep search matches in the middle of the window and open folds
" nnoremap n nzzzv
" nnoremap N Nzzzv
silent call <SID>SearchMode()
nnoremap <silent> <Leader>on :call <SID>SearchMode()<CR>


" 'goto definition' with viewport adjustments
nmap gd gdztzv
nmap gD gDztzv


" search across newlines
nnoremap <Leader>fn :SearchMultiLine<Space>


" find word under cursor
nnoremap *  *zv
nnoremap +  #zv
nnoremap g+ #gg/<C-P><CR>zv

" find visual selection
" (i use this instead of g* and g# anyway)
xnoremap *  y/\V<C-R>"<CR>zv
xnoremap +  y?\V<C-R>"<CR>zv
xnoremap g+ ygg/\V<C-R>"<CR>zv


" find lines that are too long
nnoremap <Leader>fw :exec '/\v^.{' . &textwidth . '}.'<CR>

" find trailing whitespace
nnoremap <Leader>fst /\v\s+$<CR>

" find matching element (brackets/braces/parentheses)
nnoremap <Leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <Leader>f<Leader> %

" find all lines with keyword under cursor and ask which one to jump to
nmap <Leader>fj [I:let nr = input("Which one: ")
            \   <Bar> exe "normal " . nr ."[\t"<CR>

" find git merge conflict markers
nnoremap <Leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" find errors and stuff
nnoremap <Leader>fe /\v(error\|fail)<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is minus ('-')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$j

" select last pasted/edited text
nnoremap gV `[v`]

" change case of word under cursor
nnoremap cC viw~

" autocompletion
inoremap <M-.>  <C-N>
inoremap <Esc>. <C-N>
inoremap <M-:>  <C-P>
inoremap <Esc>: <C-P>

" increment/decrement number
nnoremap -i <C-A>
nnoremap -- <C-X>


" indent lines
vnoremap < <gv
vnoremap > >gv

" change tab width (hard)
nnoremap -rt2 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=2 <bar> :retab <CR>
nnoremap -rt4 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=4 <bar> :retab <CR>
nnoremap -rt8 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=8 <bar> :retab <CR>

" yank line with Enter (i do that so often)
" CANNOT MAP THIS BECAUSE OF SPECIAL PLUGIN BUFFERS AND STUFF
" nnoremap <Enter> yy

" " autoformat with enter in normal buffers
" augroup map_enter_autoformat
"     au!
"     au BufReadPost *
"                 \ if ! strchars(&buftype) |
"                 \   nnoremap <buffer> <Enter> gqap |
"                 \   vnoremap <buffer> <Enter> gq |
"                 \ endif
" augroup END

" move line up or down
" (:m closes folds https://groups.google.com/forum/#!topic/vim_dev/QGgbjv4uyZc)
nnoremap <silent> -k :set fdm=manual<CR>:m .-2<CR>:set fdm=marker<CR>
nnoremap <silent> -j :set fdm=manual<CR>:m .+1<CR>:set fdm=marker<CR>
vnoremap <silent> -j <Esc>:set fdm=manual<CR>gv:m '>+1<CR>gv=gv:set fdm=marker<CR>
vnoremap <silent> -k <Esc>:set fdm=manual<CR>gv:m '<-2<CR>gv=gv:set fdm=marker<CR>


" join line above (instead of below)
nnoremap <Leader>J kddpkJ

" split line (opposite of 'J'oin lines)
" (regular 'S' can be done with 'cc' instead)
nnoremap S i<CR><esc>
            \ ^mq
            \ :let searchregister=@/<CR>
            \ :silent! .-1s/\v +$//<CR>:nohlsearch<CR>
            \ :let @/=searchregister<CR>
            \ `q

" duplicate code
nnoremap -uu yyp
nnoremap -ul yyp
nnoremap -up yap<S-}>p
vnoremap -u yP

" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <M-o>  <Esc>o<Esc>k
"noremap <Esc>o <Esc>o<Esc>k
"noremap <M-O>  <Esc>O<Esc>j
"noremap <Esc>O <Esc>O<Esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k

" align next column in duplicated line when i don't use replace mode
" (very bad " implementation)
nnoremap -L kWjdwgE

" add space (a few newlines) below
"nnoremap <Enter> :.+1insert \n\n\n<CR>
nnoremap -as mno<Esc>o<Esc>o<Esc>o<Esc>`n

" add a line of characters
nnoremap -al :call InsertCharLine(input("Insert character: "), 80)<CR>
" add a box of characters ('comment box')
nnoremap -ab :call InsertCharBox(input("Insert character: "))<CR>
" add a line of characters below, just as long as the current line
nnoremap -au- yyp^v$r-
nnoremap -au= yyp^v$r=
nnoremap -au# yyp^v$r#

" enter substitution mode quickly
nnoremap <C-S><C-S> :%s::<Left>


" in visual mode, use 's' for substitution
" (to change only a single occurence, use 'c'. by default they are the same)

" substitute occurrences of selection in this buffer
vnoremap <C-S>         yms:%s:\V\C<C-R>":<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" the same, but with keyword matching
vnoremap <Leader><C-S> yms:%s:\V\C\<<C-R>"\>:<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" substitute occurrences of selection in this buffer from current line and below
vnoremap s             yms:,$s:\V\C<C-R>":<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" the same, but with keyword matching
vnoremap <Leader>s     yms:,$s:\V\C\<<C-R>"\>:<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" " (these are actually two substitutions, so that we start at the current line
" " but continue from the first. source: http://stackoverflow.com/a/7608016)
" vnoremap s             yms:,$s:\V\C<C-R>":<C-R>":c<Bar>1,''-&&<Bar>norm!`s
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left>
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" " the same, but with keyword matching
" vnoremap <Leader>s     yms:,$s:\V\C\<<C-R>"\>:<C-R>":c<Bar>1,''-&&<Bar>norm!`s
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left>
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" substitute motions
for mov in ['e', 'E', 'b', 'B']
    exe "nmap \<C-S>" . mov . " v" . mov . "\<C-S>"
endfor
" substitute text objects
nmap <C-S>iw viw<Leader><C-S>
nmap <C-S>iW viW<C-S>
"substitute word under cursor
nmap <C-S>w viw<Leader><C-S>
nmap <C-S>W viW<C-S>

" substitute word under cursor in multiple files (add them with ':arg **' before)
" (instead of using the far plugin)
nnoremap <C-S>a :call Replace(0, input('Replace '.expand('<cword>').' with: '))<CR>
" ... and then ':wa'

" substitute last search
nmap <C-S>ö gggn<C-S>


" replace something with yank
nnoremap -rw viwp
nnoremap -rW viWp
nnoremap -rl v$hp


" sort lines
nnoremap -o vip:sort<CR>
vnoremap -o :sort<CR>


" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap -tu blguee
inoremap -tu <Esc>blgueea


if s:MyMode == 'stripped'
    " delete trailing whitespace for selected line
    vnoremap <silent> -dst <Esc>:.s:\v\s+$::<CR>
    " delete trailing whitespace for whole buffer
    nnoremap <silent> -dst :%s:\v\s+$::<CR>
endif

" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> -dsl :s:^\s\+::<CR>
" replace double/multiple spaces with one space
nnoremap <silent> -dsd :.s:\v(\S) {2}(\S):\1 \2:<CR>
nnoremap <silent> -dsD :%s:\v(\S) {2}(\S):\1 \2:<CR>
nnoremap <silent> -dsm :.s:\v(\S) {2,}(\S):\1 \2:<CR>
nnoremap <silent> -dsM :.s:\v(\S) {2,}(\S):\1 \2:<CR>


" convert a vim plugin github url into appropriate format for vundle
nnoremap -pi :.s:\m.*http.*github\.com/\([^/]*/[^/]*\).*:Plugin '\1':<CR>


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <Leader>ch :call ToggleHTMLComment("n")<CR>
vnoremap <silent> <Leader>ch :call ToggleHTMLComment("v")<CR>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <Leader>cd yyI#<Esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <M-u>  :earlier<CR>
noremap <Esc>u :earlier<CR>
noremap <M-U>  :later<CR>
noremap <Esc>U :later<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{


" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUILDING AND DEBUGGING {{{


" make
nnoremap <Leader>bm :make<CR>

" execute shell script
augroup shellscript_on_read
    au!
    au FileType sh      call SetupShellscript()
    au FileType fish    call SetupShellscript()
augroup END
function! SetupShellscript()
    if s:MyMode == 'mastery'
        nnoremap <Leader>bs :call VimuxRunCommand("bash -c 'chmod u+x " . expand("%:~") . " && " . expand("%:~") . "'")<CR>
    else
        nnoremap <Leader>bs :!chmod u+x % && ./%<CR>
    endif
endfunction


" jump to (syntastic) errors
nnoremap <Leader>sg :lfirst<CR>
nnoremap <Leader>sG :llast<CR>
" nnoremap <Leader>sn :lnext<CR>
" nnoremap <Leader>sN :lprevious<CR>

" perform a :cnext or :lnext
" so we jump through both quickfix and location list with one keystroke
" @param direction: 0 for next, 1 for previous
" @param switch: 0 for the same list as before, 1 for the other
let g:jumplist = 'locationlist'
function! JumpThroughList(direction, switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (a:direction == 1)
        if (g:jumplist == 'quickfixlist')
            silent! cprevious
        else
            silent! lprevious
        endif
    else
        if (g:jumplist == 'quickfixlist')
            silent! cnext
        else
            silent! lnext
        endif
    endif
endfunction
nnoremap <silent> <Left>          :call JumpThroughList(1, 0)<CR>
nnoremap <silent> <Right>         :call JumpThroughList(0, 0)<CR>
nnoremap <silent> <Leader><Left>  :call JumpThroughList(1, 1)<CR>
nnoremap <silent> <Leader><Right> :call JumpThroughList(0, 1)<CR>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <Leader>sl :lclose<bar>:cclose<CR>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <Leader>sL :lopen<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS AND WINDOWS {{{


" change or open new buffer by searching for file name
if s:MyMode == 'stripped'
    nnoremap # :buffers<CR>:buffer<Space>
    nnoremap <Leader># :find<Space>
endif

" change to LRU buffer
nnoremap <Space><Space> :buffer #<CR>
nnoremap <Space><Tab>   :buffer #<CR>

" circle through buffers
nnoremap <M-n>  :bnext<CR>
nnoremap <Esc>n :bnext<CR>
nnoremap <M-p>  :bprevious<CR>
nnoremap <Esc>p :bprevious<CR>

" change window
nnoremap <silent> <C-j> :wincmd j<CR>
nnoremap <silent> <C-k> :wincmd k<CR>
nnoremap <silent> <C-h> :wincmd h<CR>
nnoremap <silent> <C-l> :wincmd l<CR>

" move buffer to a new window
nnoremap <silent> <Leader><C-l> :vsplit<CR><C-W>w:bprevious<CR><C-W>w<CR>
nnoremap <silent> <Leader><C-j>  :split<CR><C-W>w:bprevious<CR><C-W>w<CR>

" resize window faster
nnoremap <silent> <C-w>+ :resize +3<CR>
nnoremap <silent> <C-w>- :resize -3<CR>
nnoremap <silent> <C-w>> 5<C-W>>
nnoremap <silent> <C-w>< 5<C-W><


" clear windows (close quickfix and location list) and refresh screen
nnoremap <silent> <BS> :nohlsearch \| :lclose \| :cclose \| :redraw! <CR>
xmap <silent> <BS> <BS>gv

" toggle quickfix or location list
nnoremap <silent> <Leader>tq :call ToggleList("Quickfix List", 'c')<CR>
nnoremap <silent> <Leader>tl :call ToggleList("Location List", 'l')<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" builtin file explorer (netrw) {{{
" (who needs NERDTree anyway)

" let g:netrw_liststyle = 1
" let g:netrw_winsize = 31
let g:netrw_liststyle = 0
let g:netrw_winsize = 16
let g:netrw_banner = 0
let g:netrw_browse_split = 4

let g:netrw_is_toggled = 0


" toggle netrw and start from current file
nnoremap <silent> <Leader>te :exe ':Lexplore! ' . expand('%:p:h')<CR>
" toggle netrw and start from working (project) dir
nnoremap <silent> <Leader>tE :Lexplore!<CR>


augroup netrw_autocmds
    autocmd!
    autocmd filetype netrw call NetrwMappings()
augroup END

function! NetrwMappings()
    silent! nunmap <buffer> qL
    silent! nunmap <buffer> qF
    silent! nunmap <buffer> qf
    silent! nunmap <buffer> qb
    silent! nunmap <buffer> q
    nnoremap <buffer> q   :bd<CR>
    nnoremap <buffer> h   :help netrw-quickmap<CR>
    nmap     <buffer> .   gh
    nmap     <buffer> u   -
    " TODO: nnoremap u or locally unmap all - bindings to prevent odd bugs
    nmap     <buffer> af  %
    nmap     <buffer> ad  d
endfunction



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{

" copy current filepath (to clipboard and fucking everywhere)
nnoremap <Leader>iP :let @" = expand("%:~")<CR>
            \       :let @+ = expand("%:~")<CR>
            \       :let @* = expand("%:~")<CR>

" search the web with selection
vnoremap <Leader>isl :<C-w>!$BROWSER 'https://dict.leo.org/ende/?lang=en&search=<C-R>*'<CR><CR>
vnoremap <Leader>isd :<C-w>!$BROWSER 'https://duckduckgo.com/?q=<C-R>*'<CR><CR>
vnoremap <Leader>isg :<C-w>!$BROWSER 'https://google.com/?q=<C-R>*'<CR><CR>

" shell in working dir or dir of current file
nnoremap <Leader>if :!fish<CR><CR>
nnoremap <Leader>iF :execute '!cd ' . expand('%:p:h') . '; fish'<CR><CR>
nnoremap <Leader>ib :!bash<CR><CR>
nnoremap <Leader>iB :execute '!cd ' . expand('%:p:h') . '; bash'<CR><CR>

" file manager in working dir or dir of current file
" nnoremap <Leader>ir :call VimuxRunCommand("ranger")<CR>
" nnoremap <Leader>ir :exe "!ranger " . shellescape(expand("%p:h"))
nnoremap <Leader>ir :call RangerChooser(expand('%:p:h'))<CR>
nnoremap <Leader>iR :RangerChooser<CR>

" git interface in working dir or dir of current file
nnoremap <Leader>it :!tig status <CR> :call GitRedraw()<CR>
nnoremap <Leader>iT :execute '!cd ' . expand('%:p:h') . '; tig status'<CR>
                                    \ :call GitRedraw()<CR>

" insert google contacts with name and mail addresses (with goobook)
nnoremap <Leader>igm         :r!goobook-query-mail.sh<space>
" inoremap <Leader>igm <Esc>diw:r!goobook-query-mail.sh<space><C-R>"<CR><CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{


" check for file changes (and 'reload' them or get asked with autoread)
nnoremap <Leader>rl :checktime<CR>

" discard changes ('reset')
nnoremap <Leader>rs :e!<CR>


" write changes
nnoremap <Leader>w  :update<CR>
nnoremap <Leader>WW :update!<CR>

" quit current buffer
nnoremap <Leader><BS> :bdelete<CR>
nnoremap <Leader>qq   :bdelete<CR>
nnoremap <Leader>QQ   :bdelete!<CR>
augroup map_q_in_read_only_buffers
    au!
    au BufReadPost * if &readonly
    au BufReadPost *   nnoremap <buffer> q :bd<CR>
    au BufReadPost * endif
    au BufReadPost fugitive://* nnoremap <buffer> q :bd<CR>
augroup END


" quit all buffers (not vim)
nnoremap <Leader>qa :bufdo bdelete<CR>

" quit current window
nnoremap <Leader>qw :quit<CR>:buffer #<CR>
" quit all windows but current
nnoremap <Leader>qW :only<CR>

" quit vim (multiple windows)
" (this is how i exit most terminal applications)
nnoremap <C-D>              :quitall<CR>
nnoremap <Leader><C-D><C-D> :quitall!<CR>

" ... but ignore typos
nnoremap <Leader>q <NOP>
nnoremap <Leader>Q <NOP>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILETYPE SPECIFIC SETTINGS {{{

augroup FILETYPE_SPECIFIC_SETTINGS_QUICKFIX
    autocmd!
    autocmd filetype qf setlocal norelativenumber
    autocmd filetype qf setlocal colorcolumn=
augroup END

augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit setlocal colorcolumn=50
    autocmd filetype gitcommit setlocal textwidth=50
    autocmd filetype gitcommit let b:local_autosave = 0
    autocmd filetype gitcommit normal gg
augroup END

augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT
    autocmd!
    autocmd! FileType json setlocal conceallevel=0 foldmethod=syntax foldlevel=999
augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" LOCAL SECTION                                                                "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{

" Check for local vimrc files and source them.
" (project files take precedence over global files)
" (non-hidden files take precedence over hidden files)
" (child directory takes precedence over parent directory)
let vimrcs = []
for vimrc_name in ['vimrc.local', '.vimrc.local']
    let dir = getcwd()
    while dir != '/'
        let vimrc = glob(dir . '/' . vimrc_name)
        if filereadable(vimrc)
            let vimrcs = vimrcs + [vimrc]
        endif
        let dir = fnamemodify(dir . '..', ':h')
    endwhile
endfor
let vimrcs = vimrcs + ['~/.vimrc.local']
for vimrc in reverse(vimrcs)
    if filereadable(vimrc)
        exec 'source ' . vimrc
    endif
endfor


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=80:sw=4:fdm=marker:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
