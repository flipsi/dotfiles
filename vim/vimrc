"  Author:  Philipp Moers
"           soziflip@gmail.com
"           https://github.com/flipsi/dotfiles
"           https://philippmoers.de
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
" If you are reading this configuration file on whe web and want use it right
" away, start vim like this:
"
"       bash -c "vim -u <(curl https://raw.githubusercontent.com/flipsi/dotfiles/master/vim/vimrc) FILE"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins. I use vim-plug to manage them.

" I install vim-plug like this in neovim:
"
" sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
"
" or like this in vim:
"
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install vim configuration files let vim-plug handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a COMMAND AND KEYMAP SECTION
"                           where commands are defined and characters are bound.
"                           Command definitions makes it easier to find a
"                           functionality via :FzfCommands when I can't remember
"                           the corresponding mapping.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (` `)
"                           - text edit leader is single quote (`'`)
"                           - interface leader is space followed by y (` y`)
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"       a LOCAL SECTION
"                           where potential other vimrc files are loaded.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash
" (fish is not posix compatible and makes problems)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" force usage of python3
" https://robertbasic.com/blog/force-python-version-in-vim/
if has('python3')
endif

" always search recursively (e.g. when using :find)
set path+=**

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
function! ComputeMyMode()
    if has('nvim')
        let l:plugin_file = '~/.local/share/nvim/site/autoload/plug.vim'
    else
        let l:plugin_file = '"~/.vim/autoload/plug.vim"'
    endif
    if filereadable(expand(l:plugin_file))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" leader key should do nothing alone
nnoremap <leader> <nop>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

if !exists("*SourceMYVIMRC")
    function SourceMYVIMRC()
        echo 'Sourcing vimrc ...'
        source ~/.vimrc
        syntax enable
        AirlineRefresh
        FixHighlighting
        let l:win_id = win_getid()
        normal! mZ
        if exists("*RainbowToggleOn")
            windo RainbowToggleOn
        endif
        call win_gotoid(l:win_id)
        normal! `Z
        redraw
        echomsg 'vimrc sourced' . ' ✔'
    endfunction
endif
command! SourceMYVIMRC :call SourceMYVIMRC() " Reload configuration

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc SourceMYVIMRC
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically create non-existing directories when writing files

augroup Mkdir
    autocmd!
    autocmd BufWritePre * call mkdir(expand("<afile>:p:h"), "p")
augroup END


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically resize windows when terminal (or font) is resized

augroup autoresize_windows
    autocmd!
    autocmd VimResized * :wincmd =
augroup END


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


nnoremap <leader>pi :PlugInstall<cr>
nnoremap <leader>pc :PlugClean<cr>
nnoremap <leader>pu :PlugUpdate<cr>
nnoremap <leader>ps :PlugStatus<space>
nnoremap <leader>pd :PlugDiff<space>



if s:MyMode == 'mastery'

    call plug#begin()


if has('nvim')
    Plug 'nvim-lua/plenary.nvim'
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Extend gx to use it beyond just URLs! {{{

" ... e.g. vim plugin URLS, markdown URLs etc.
"
Plug 'stsewd/gx-extended.vim'

nmap gx <Plug>(gxext-normal)
xmap gx <Plug>(gxext-visual)


" }}}
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim sessions {{{

" make sessions more convenient and automatically updated
Plug 'tpope/vim-obsession'

let g:session_file_name = '.session.vim'

" start session
nnoremap <leader>se :exe 'Obsession' . g:session_file_name<cr>

" automatically load sessions if started without args
autocmd VimEnter * nested
            \ if !argc() && empty(v:this_session) |
            \   if filereadable(g:session_file_name) |
            \     exe 'source' . g:session_file_name |
          " \   elseif |
          " \     exe 'Obsession' . g:session_file_name |
            \   endif |
            \ endif


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" terminal extensions {{{

Plug 'kassio/neoterm'

" layout options, see SetNeoTermModeAutomatically()
let g:neoterm_mode = 'automatically'
let g:neoterm_default_mod = ''
let g:neoterm_size_horizontally = '20'
let g:neoterm_size_vertically = ''

let g:neoterm_shell = 'fish'
let g:neoterm_autoinsert = 1
let g:neoterm_autoscroll = 1
let g:neoterm_automap_keys = '' " don't add default mapping (,tt)

" Execute some neoterm terminal command without ending up in insert mode
" (this is necessary due to the 'startinsert' autocmd that I want)
command! -nargs=1 ExecuteInNeoTerminal :call ExecuteInNeoTerminal(<q-args>)
function! ExecuteInNeoTerminal(vimcommand)
    let g:suppress_terminal_autoinsert = 1
    call SetNeoTermModeAutomatically()
    if index(['Tkill','Tclear'], a:vimcommand) >= 0
        execute a:vimcommand
    else
        execute "T " . a:vimcommand
    endif
    sleep 50m
    unlet g:suppress_terminal_autoinsert
endfunction

" Switch how to split terminal window
command! SwitchNeoTermMode :call SwitchNeoTermMode()
function! SwitchNeoTermMode()
    let g:run_command_method = "terminal-buffer" " I don't use this function when I don't use that setting...
    if g:neoterm_mode == 'automatically'
        let g:neoterm_mode = ':botright'
        let g:neoterm_default_mod = ':botright'
        let g:neoterm_size = g:neoterm_size_horizontally
        echo 'Splitting terminal at the bottom'
    elseif g:neoterm_mode == ':botright'
        let g:neoterm_mode = ':vertical'
        let g:neoterm_default_mod = ':vertical'
        let g:neoterm_size = g:neoterm_size_vertically
        echo 'Splitting terminal vertically'
    else
        let g:neoterm_mode = 'automatically'
        let g:neoterm_default_mod = ''
        let g:neoterm_size =''
        echo 'Splitting terminal based on window layout'
    endif
endfunction

" If enabled (g:neoterm_mode), set how to split terminal window (g:neoterm_default_mod) based on current window layout
command! SetNeoTermModeAutomatically :call SetNeoTermModeAutomatically()
function! SetNeoTermModeAutomatically()
    if g:neoterm_mode == 'automatically'
        " if winnr('$') == 1
        if len(filter(range(1, winnr('$')), 'winwidth(v:val) != &columns')) == 0
            let g:neoterm_default_mod = ':vertical'
            let g:neoterm_size = g:neoterm_size_vertically
        else
            let g:neoterm_default_mod = ':botright'
            let g:neoterm_size = g:neoterm_size_horizontally
        endif
    endif
endfunction

" " Remove stupid default mappings
" augroup neoterm_remove_mappings
    " au!
    " au VimEnter * silent! nunmap ,tt
" augroup END

nnoremap <leader>ott    :SwitchNeoTermMode<cr>
nnoremap <leader>tm     :echo "Use <leader>ott from now on, please!"<cr> " legacy binding

nnoremap <leader>tt     :call SetNeoTermModeAutomatically() <bar> Topen<cr>
nnoremap <leader>tn     :Tnew<cr>
nnoremap <leader>t<bs>  :Tclose<cr>         " only hides buffer, we can still sent commands to it

" nnoremap <leader>tl :Tclear<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tmux integration {{{


" fix FocusLost and FocusGained events in tmux
" Update: this plugin is now obsolete and no longer needed as both neovim and vim (since version 8.2.2345) have native support for this functionality.
" Plug 'tmux-plugins/vim-tmux-focus-events'


" consistent keybindings to change tmux panes and vim windows
Plug 'christoomey/vim-tmux-navigator'
" NOTE that this doesn't work in terminal buffers, see https://github.com/christoomey/vim-tmux-navigator/pull/172
let g:tmux_navigator_save_on_switch = 1
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-left>    :TmuxNavigateLeft<cr>
nnoremap <silent> <C-down>    :TmuxNavigateDown<cr>
nnoremap <silent> <C-up>      :TmuxNavigateUp<cr>
nnoremap <silent> <C-right>   :TmuxNavigateRight<cr>
"nnoremap <silent> <esc><c-space>   :TmuxNavigatePrevious<cr>


" run tmux commands from within vim
Plug 'preservim/vimux'
let g:VimuxHeight = "50"
let g:VimuxOrientation = "h"
let VimuxUseNearest = 1



" autocompletion from words visible in tmux panes
Plug 'wellle/tmux-complete.vim'
" <c-x><c-u> and then <c-u> or <c-n> a few times



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plug 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" " smooth scrolling
" Plug 'psliwka/vim-smoothie'
" nmap <unique> <M-j> <Plug>(SmoothieDownwards)
" nmap <unique> <M-k> <Plug>(SmoothieUpwards)


" make gvim colorschemes work in terminal
Plug 'godlygeek/csapprox'

" colorschemes
Plug 'flazz/vim-colorschemes'
Plug 'christophermca/meta5'
Plug 'sjl/badwolf'
Plug 'sonph/onehalf', {'rtp': 'vim/'}
Plug 'ayu-theme/ayu-vim'
Plug 'NLKNguyen/papercolor-theme'
Plug 'sainnhe/gruvbox-material'


" cycle through colorschemes
Plug 'vim-scripts/ScrollColors'
nnoremap <leader>yo :COLORSCROLL<cr>


" highlight word under cursor
" Plug 'RRethy/vim-illuminate'
let g:Illuminate_delay = 200
let g:Illuminate_highlightUnderCursor = 0


" highlight different parentheses pairs with different colors
if has('nvim')

    Plug 'hiphish/rainbow-delimiters.nvim'

    nnoremap <leader>yb :lua require('rainbow-delimiters').toggle(0)<cr>

else

    Plug 'luochen1990/rainbow'
    let g:rainbow_active = 1
    nnoremap <leader>yb :RainbowToggle<cr>

    augroup rainbow_disable_in_terminal_buffers
        au!
        " au TermOpen * echo "zack" " TODO: delete this debugging statement
        " TODO: FIX
        " au TermOpen * RainbowToggleOff
        " au TermOpen * if exists(":RainbowToggleOff") | RainbowToggleOff | endif
    augroup END

    augroup rainbow_disable_in_terminal_buffers_too_late_but_used_to_work
        au!
        au BufEnter term://* echo "zzzack"
        au BufEnter term://* RainbowToggleOff
    augroup END

    " TODO: fork plugin and disable per filetype
    " https://github.com/luochen1990/rainbow/issues/187
    "
endif


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" distraction free mode {{{

if has('nvim')
    Plug 'folke/zen-mode.nvim'
    nnoremap <leader>yz :ZenMode<cr>
endif

Plug 'junegunn/goyo.vim'

let g:goyo_width="120"
let g:goyo_height="100%"

nnoremap <leader>yy :Goyo<cr>


" maximize (like tmux 'zoom') current window temporarily
Plug 'szw/vim-maximizer'
let g:maximizer_set_default_mapping = 0
nnoremap <silent><leader>ym :MaximizerToggle!<CR>
vnoremap <silent><leader>ym :MaximizerToggle!<CR>gv
nnoremap <c-y>z             :MaximizerToggle!<CR>
vnoremap <c-y>z             :MaximizerToggle!<CR>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" status bar {{{

Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'

let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline_inactive_collapse=0

let g:airline_statusline_ontop = 1
let g:airline#extensions#tabline#show_tabs = 0
let g:airline#extensions#tabline#show_tab_count = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'unique_tail'

if has('nvim')
    let g:airline#extensions#lsp#enabled = 1
    let g:airline#extensions#coc#enabled = 0
else
    let g:airline#extensions#coc#enabled = 1
endif

let g:airline_section_mode_default = '%#__accent_bold#%{airline#util#wrap(airline#parts#mode(),0)}%#__restore__#%{airline#util#append(airline#parts#crypt(),0)}%{airline#util#append(airline#parts#paste(),0)}%{airline#util#append(airline#extensions#keymap#status(),0)}%{airline#util#append(airline#parts#spell(),0)}%{airline#util#append("",0)}%{airline#util#append("",0)}%{airline#util#append(airline#parts#iminsert(),0)}'
let g:airline_section_my_filename = ' %{expand("%:t")}'
let g:airline_section_a = g:airline_section_mode_default . g:airline_section_my_filename

let g:airline_section_b = '%{airline#util#wrap(airline#extensions#hunks#get_hunks(),100)}%{airline#util#wrap(airline#extensions#branch#get_head(),80)}'

if g:airline#extensions#coc#enabled == 1
    let g:airline_section_c = '%{coc#status()}'
else
    let g:airline_section_c = '%{expand("%:h")}'
endif

command! -nargs=1 AirlineIndicateCustomMode :call AirlineIndicateCustomMode(<f-args>)
function! AirlineIndicateCustomMode(modename)
    if s:MyMode == 'mastery'
        " TODO use airline#section#create() ?
        let g:airline_section_a = '%#__accent_bold#[' . a:modename . ']% ' . g:airline_section_my_filename
        AirlineRefresh
    endif
endfunction

command! AirlineResetCustomMode :call AirlineResetCustomMode()
function! AirlineResetCustomMode()
    if s:MyMode == 'mastery'
        let g:airline_section_a = g:airline_section_mode_default . g:airline_section_my_filename
        AirlineRefresh
    endif
endfunction



let g:airline_powerline_fonts=0
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''


" " airline extension: show list of buffers (like tabs)
" Plug 'bling/vim-bufferline'
" let g:airline#extensions#bufferline#enabled = 0

" airline extension: obsession (session plugin)
let g:airline#extensions#obsession#enabled = 1

" airline extension: show columns of csv files
let g:airline#extensions#csv#enabled = 1

" airline extension: hide fugitive stuff
let g:airline#extensions#fugitiveline#enabled = 1

" airline extension: vim-grepper integration
let g:airline#extensions#grepper#enabled = 1


" simple status bar alternative?
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plug 'tpope/vim-fugitive'

" open quickfixlist with unstaged changes
nnoremap <leader>gel  :Git difftool<cr><esc>

" git status
" nnoremap <leader>gs   :Git<cr>
" nnoremap <leader>gs   :Gsplit :<cr>
" nnoremap <leader>gs   :silent! wincmd 1w <bar> vertical Git<cr> " Note that if the working dir is different from the git dir, strangely enough `:Git` opens netrw/ranger if not in the first window. I workaround the issue with `wincmd 1w`.
nnoremap <leader>gs   :GitStatusTab<cr>

" stage and commit
nnoremap <leader>gw   :Gwrite<cr>
nnoremap <leader>gA   :Gwrite<cr>
nnoremap <leader>gU   :Gread<cr>
nnoremap <leader>gcc  :Git commit<cr>
nnoremap <leader>gca  :Git commit --amend<cr>

" reset
nnoremap <leader>grH        :Confirm Git reset HEAD~1<cr>
nnoremap <leader>grh        :Confirm Git reset --hard<cr>
nnoremap <leader>grr  :exe ':Confirm Git reset --hard ' . GitRemoteName() . '/' . GitCurrentBranchName()<cr>

" stash
nnoremap <leader>gta  :Confirm Git stash push --include-untracked<cr>
nnoremap <leader>gtp  :Confirm Git stash pop<cr>

" diff / resolve merge conflicts
nnoremap <leader>gdd  :Gdiffsplit<cr>
nnoremap <leader>gdv  :Gvdiffsplit!<cr>gg:FindGitConflictMarkers<cr>
nnoremap <leader>gdt  :GdiffsplitTab<cr>gg:FindGitConflictMarkers<cr>
nnoremap <leader>gdm  :exe ':Shell git diff ' . GitRepoMainOrMaster() . ' \| delta'<cr>
nnoremap <leader>gdM  :GitRemoteDiffMergeRequest<cr>

" checkout/create/rename branches
nnoremap <leader>gee  :Git checkout<space>
nnoremap <leader>geo  :GitCheckoutInteractively<cr>
nnoremap <leader>gem  :exe ':Confirm Git checkout ' . GitRepoMainOrMaster()<cr>
nnoremap <leader>ge-  :Confirm Git checkout -<cr>
nnoremap <leader>geb  :silent! exe ':Git checkout -b ' . input('Branch name: ')<cr>
nnoremap <leader>gbm  :silent! exe ':Confirm Git branch -m ' . input('Renaming branch to: ')<cr>

" merge and rebase
nnoremap <leader>gmo  :GitMergeChooseBranchInteractively<cr>
nnoremap <leader>gmm  :exe ':Confirm Git merge ' . GitRepoMainOrMaster()<cr>
nnoremap <leader>gro  :GitRebaseChooseBranchInteractively<cr>
nnoremap <leader>grm  :exe ':Confirm Git rebase ' . GitRepoMainOrMaster()<cr>
nnoremap <leader>gra  :Confirm Git rebase --abort<cr>
nnoremap <leader>grc  :Confirm Git rebase --continue<cr>

" fech, pull and push
nnoremap <leader>gpl  :Git pull<cr>
nnoremap <leader>gfm  :exe ':Confirm Git fetch ' . GitRemoteName() . ' ' . GitRepoMainOrMaster() . ':' . GitRepoMainOrMaster()<cr>
nnoremap <leader>gps  :GitPush<cr>
nnoremap <leader>gpu  :GitPush<cr>
nnoremap <leader>gpf  :Git push --force-with-lease<cr>
nnoremap <leader>gup  :Confirm Git submodule update<cr>

" work with remote (Mnemonic: 'G'it Rem'o'te) Github or Gitlab
nnoremap <leader>go   <nop>
nnoremap <leader>gow  :OpenGitRepoWeb<cr>
nnoremap <leader>goo       :call GitWebUrl('line', 'open_in_web')<cr>
vnoremap <leader>goo  :<c-u>call GitWebUrl('range', 'open_in_web')<cr>
nnoremap <leader>goy       :call GitWebUrl('line', 'yank_to_clipboard')<cr>
vnoremap <leader>goy  :<c-u>call GitWebUrl('range', 'yank_to_clipboard')<cr>
nnoremap <leader>gor  :GitRemoteCreateOrViewMergeRequest<cr>
nnoremap <leader>gop  :GitRemoteShowPipeline<cr>

" git log etc.
nnoremap <leader>glh  :Git log<cr>
nnoremap <leader>gll  :tab Git log<cr>
nnoremap <leader>glf  :tab Git log %<cr>
nnoremap <leader>glm  :exe 'Git log ' . GitRepoMainOrMaster()<cr>
nnoremap <leader>gbb  :Git blame<cr>


command! GitStatusTab call GitStatusTab()
function! GitStatusTab()
    let g:git_status_last_used_tabnr = tabpagenr()
    tab Git
endfunction

" switch to last used tab after closing the Git Status tab opened with GitStatusTab
augroup gitstatusclose
    au!
    au BufDelete fugitive://*.git//             exec 'normal! ' . g:git_status_last_used_tabnr . 'gt'
    au BufDelete fugitive://*.git/worktrees/*/  exec 'normal! ' . g:git_status_last_used_tabnr . 'gt'
augroup END

" can be replaced with `<Plug><cfile>` in some cases
function! GStatusGetFilenameUnderCursor()
    return matchstr(getline('.'), '^[A-Z?] \zs.*')
endfunction

command! GdiffsplitTab call GdiffsplitTab(expand("%"))
function! GdiffsplitTab(filename)
    exe 'tabedit ' . a:filename
    Gdiffsplit
endfunction

" custom mapping in fugitive window (:Git)
augroup custom_fugitive_mappings
    au!
    au FileType fugitive nnoremap <buffer> <up>     k
    au FileType fugitive nnoremap <buffer> <down>   j
    au FileType fugitive nnoremap <buffer> <left>   h
    au FileType fugitive nnoremap <buffer> <right>  l
    au FileType fugitive nmap     <buffer> !   X
    au FileType fugitive nmap     <buffer> w   =
    au FileType fugitive nnoremap <buffer> dt  :call GdiffsplitTab(GStatusGetFilenameUnderCursor())<cr>
    au FileType fugitive nmap     <buffer> pl  :Git pull<cr>
    au FileType fugitive nmap     <buffer> ps  :Git push<cr>
    au FileType fugitive nmap     <buffer> pu  :GitPush<cr>
    au FileType fugitive nmap     <buffer> pf  :Git push --force-with-lease<cr>
    au FileType fugitive nmap     <buffer> pr  :GitRemoteCreateOrViewMergeRequest<cr>
augroup END

" in Gdiff view, stage/checkout easily
augroup gitdiff
    au!
    au BufRead fugitive://* nnoremap <buffer> <leader>g<left>  do
    au BufRead fugitive://* nnoremap <buffer> <leader>g<right> dp
augroup END

" in Git commit view (opening from git log, not commit message), don't use folds
augroup gitcommit_view
    au!
    au BufRead fugitive:///*/.git//?\\\{40\} normal zR
augroup END


" resolve 3-way merge conflicts (diff view)
nnoremap <leader>g<down>    ]c
nnoremap <leader>g<up>      [c
nnoremap <leader>g<left>    :diffget //3<cr>    " get changes from the right
nnoremap <leader>g<right>   :diffget //2<cr>    " get changes from the left



" Resolve merge conflicts the easy way (used as `git mergetool`)

Plug 'christoomey/vim-conflicted'

nnoremap <leader>gmt :Conflicted<cr>
nnoremap <leader>gmn :GitNextConflict<cr>

" navigate through hunks with ]c and [c

let g:diffget_local_map = '<left>'
let g:diffget_upstream_map = '<right>'


" Resolve merge conflicts from within vim
" (simply when conflict markers are present)

" Plug 'rhysd/conflict-marker.vim'
" or:
" https://github.com/sindrets/diffview.nvim

let g:conflict_marker_highlight_group = ''
let g:conflict_marker_begin = '^<<<<<<< .*$'
let g:conflict_marker_end   = '^>>>>>>> .*$'
highlight ConflictMarkerBegin guibg=#2f7366
highlight ConflictMarkerOurs guibg=#2e5049
highlight ConflictMarkerTheirs guibg=#344f69
highlight ConflictMarkerEnd guibg=#2f628e
highlight ConflictMarkerCommonAncestorsHunk guibg=#754a81

" [x    jump to next conflict marker
" ]x    jump to previous conflict marker
" co    choose ours (top)
" ct    choose theirs (bottom)
" cb    choose both (just remove conflict markers)
" cn    choose none (remove both versions and conflict markers)


" show git status of lines on the left

Plug 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

" GitGutter styling
let g:gitgutter_sign_added = '|'
let g:gitgutter_sign_modified = '|'
let g:gitgutter_sign_removed = '|'
let g:gitgutter_sign_modified_removed = '|'

" do not map ic/ac text objects etc because I decide how I use them
let g:gitgutter_map_keys = 0

omap ih <plug>GitGutterTextObjectInnerPending
omap ah <plug>GitGutterTextObjectOuterPending
xmap ih <plug>GitGutterTextObjectInnerVisual
xmap ah <plug>GitGutterTextObjectOuterVisual

nnoremap <leader>yG       :GitGutterToggle<cr>
nnoremap <leader>yg       :GitGutter<cr> " redraw
nnoremap <leader>gi       :GitGutterPreviewHunk<cr>
nnoremap <leader>gu       :GitGutterUndoHunk<cr>
nnoremap <leader>ga       :GitGutterStageHunk<bar>GitGutterNextHunk<cr>:EnableGitGutterMode<cr>
nnoremap <leader>gg     gg:GitGutterNextHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap <leader>gG      G:GitGutterPrevHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap <leader>g<down>  :GitGutterNextHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap <leader>g<up>    :GitGutterPrevHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap <leader>gn       :GitGutterNextHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap <leader>gN       :GitGutterPrevHunk<cr>zzzv:EnableGitGutterMode<cr>
nnoremap         gn       :GitGutterNextHunk<cr>zzzv
nnoremap         gN       :GitGutterPrevHunk<cr>zzzv

command! EnableGitGutterMode :call EnableGitGutterMode()
function! EnableGitGutterMode()
    let g:gitguttermode = 1
    nnoremap <cr>      :GitGutterStageHunk<bar>GitGutterNextHunk<cr>
    AirlineIndicateCustomMode GITGUTTER MODE
endfunction

command! DisableGitGutterMode :call DisableGitGutterMode()
function! DisableGitGutterMode()
    let g:gitguttermode = 0
    silent! nunmap <cr>
    AirlineResetCustomMode
endfunction

let g:gitguttermode = 0

" automatically unmap (after committing is reasonable)
augroup gitgutter_unmap
    au!
    au BufWipeout .git/COMMIT_EDITMSG DisableGitGutterMode
augroup END



" show commit messages in a preview window

Plug 'rhysd/git-messenger.vim'

let g:git_messenger_no_default_mappings = v:true

nmap <leader>gB <Plug>(git-messenger)



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle unicode and digraphs easily {{{

Plug 'chrisbra/unicode.vim'

" inspect character under cursor
nnoremap ga :UnicodeName<cr>

" complete unicode with <c-x><c-z>
" complete digraph with <c-x><c-g>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plug 'easymotion/vim-easymotion'

" prefix
map <M-l>  <plug>(easymotion-prefix)
map <esc>l <plug>(easymotion-prefix)
" keys to move to target
let g:EasyMotion_keys = 'asdfgh,.qwertuiocvbnmjkl'



" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
" Plug 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<cr>", "\<tab>"]
let g:clever_f_chars_match_any_signs = '/'



" like f but with two characters
Plug 'justinmk/vim-sneak'

" interactive mode like easymotion
" let g:sneak#label = 1

" movement repeatable with same keystroke like clever-f
" (i don't really like this, as it makes movements unpredictable)
" let g:sneak#s_next = 1

" , always forwards ; always backwards
" let g:sneak#absolute_dir = 1

" use smartcase;
let g:sneak#use_ic_scs = 1

nmap f <plug>Sneak_s
nmap F <plug>Sneak_S
" nmap l <plug>Sneak_S " suitable for Moonlander, but not for other keyboards...

nmap , <plug>Sneak_;
nmap ; <plug>Sneak_,

xmap f :<C-U>call sneak#wrap(visualmode(), 2, 0, 1, 0)<CR>
xmap F :<C-U>call sneak#wrap(visualmode(), 2, 1, 1, 0)<CR>
xmap l :<C-U>call sneak#wrap(visualmode(), 2, 1, 1, 0)<CR>
xmap t :<C-U>call sneak#wrap(visualmode(), 2, 0, 0, 0)<CR>
xmap T :<C-U>call sneak#wrap(visualmode(), 2, 1, 0, 0)<CR>
xmap l :<C-U>call sneak#wrap(visualmode(), 2, 1, 0, 0)<CR>

omap f :<C-U>call sneak#wrap(v:operator,   2, 0, 1, 0)<CR>
omap F :<C-U>call sneak#wrap(v:operator,   2, 1, 1, 0)<CR>
omap l :<C-U>call sneak#wrap(v:operator,   2, 1, 1, 0)<CR>
omap t :<C-U>call sneak#wrap(v:operator,   2, 0, 0, 0)<CR>
omap T :<C-U>call sneak#wrap(v:operator,   2, 1, 0, 0)<CR>
omap l :<C-U>call sneak#wrap(v:operator,   2, 1, 0, 0)<CR>


" make f only match interesting characters
" Plug 'svermeulen/vim-NotableFt'

" nmap , <plug>NotableFtRepeatSearchForward
" nmap ; <plug>NotableFtRepeatSearchBackward
" nmap f <plug>NotableFtSearchFForward
" nmap s <plug>NotableFtSearchFBackward
" nmap F <plug>NotableFtSearchFBackward
" nmap t <plug>NotableFtSearchTForward
" nmap T <plug>NotableFtSearchTBackward



" highlight characters for f
" Plug 'unblevable/quick-scope'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" movements and text objects for parts of words {{{

" move with ,w in wordsLikeThisWord or words_like_this_word
" Plug 'bkad/CamelCaseMotion'

" call camelcasemotion#CreateMotionMappings(',') " DOES NOT WORK HERE

" also handle dashes with this plugin (hence w should move over them)
" (this breaks toggle_words for many cases)
" set iskeyword+=-


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better and custom text objects {{{

"TODO: use treesitter enhanced mini.nvim
"EasyAlign -> mini.align
"flash.nvim -> mini.jump
"lualine -> mini.statusline
"nvim-autopairs -> mini.pairs
"nvim-web-devicons -> mini.icons
"vim-sandwich -> mini.surround
"vim-unimpaired -> mini.bracketed
"see https://evantravers.com/articles/2024/09/17/making-my-nvim-act-more-like-helix-with-mini-nvim/

Plug 'wellle/targets.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Plug 'kana/vim-textobj-user'

" lines with the same indent level (ai/ii)
Plug 'kana/vim-textobj-indent'

" quotes (aq/iq)
Plug 'beloglazov/vim-textobj-quotes'

" functions (af/if)
Plug 'kana/vim-textobj-function'
Plug 'thinca/vim-textobj-function-javascript'

" function arguments (aa/ia)
" (somehow required one more keystroke)
Plug 'gaving/vim-textobj-argument'

" lines with ( [ { pairs (ac/ic)
" Plug 'Chun-Yang/vim-textobj-chunk'

" css rules (ac/ic)
Plug 'jasonlong/vim-textobj-css'
" Plug 'stephenway/vim-textobj-css'

" HTML/XML attributes (ax/ix)
Plug 'whatyouhide/vim-textobj-xmlattr'

" PHP Tags (aP/iP)
Plug 'akiyan/vim-textobj-php'

" folds (az/iz)
Plug 'kana/vim-textobj-fold'

" git hunks (ih) (now managed by gitgutter plugin)
" Plug 'gilligan/textobj-gitgutter'
" omap ah <plug>(textobj-gitgutter-i)
" vmap ah <plug>(textobj-gitgutter-i)

" entire buffer / 'all' (aa/ia)
Plug 'kana/vim-textobj-entire'
let g:textobj_entire_no_default_key_mappings = 1
omap aE <plug>(textobj-entire-a)
vmap aE <plug>(textobj-entire-a)
omap iE <plug>(textobj-entire-i)
vmap iE <plug>(textobj-entire-i)
" load dynamically with :TextobjEntireDefaultKeyMappings

" note that vimtex also defines mappings ic/id/ie/i$


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

" Plug 'google/vim-searchindex'
" Plug 'osyo-manga/vim-anzu'


Plug 'haya14busa/incsearch.vim'
let g:incsearch#auto_nohlsearch = 1
let g:incsearch#emacs_like_keymap = 1
let g:incsearch_cli_key_mappings = {
\   "\<c-n>": {
\     'key': '<over>(buffer-complete)',
\     'noremap': 1
\   },
\   "\<c-p>": {
\     'key': '<over>(buffer-complete-prev)',
\     'noremap': 1
\   },
\ }

" nnoremap /  <plug>(incsearch-forward)
" nnoremap ?  <plug>(incsearch-backward)
nnoremap / :call incsearch#call()<cr>
nnoremap ? :call incsearch#call({'command': '?'})<cr>


" searching in multiple files
" Plug 'mileszs/ack.vim'

" command to execute
let g:ackprg="ag --vimgrep --smart-case"

" " type a search pattern
" nnoremap <leader>ag :let g:jumplist = 'quickfixlist'<cr>
"                  \ :Ack!<space>""<left>

" " search for visual selection
" xnoremap <leader>ag y:let g:jumplist = 'quickfixlist'<cr>
"                  \ :<c-u>Ack! "-Q" "<c-r>""<cr>


" grep in vim like a pro
Plug 'mhinz/vim-grepper'

let g:grepper = {}
" let g:grepper.tools = ['git', 'ag', 'grep', 'rg']
let g:grepper.quickfix = 1
let g:grepper.switch = 0
let g:grepper.jump = 1
let g:grepper.prompt_mapping_side = '<c-l>'
let g:grepper.searchreg = 1

nnoremap <leader>/      :Grepper<cr>

nnoremap g/             :Grepper-side<cr>
nnoremap g*             :Grepper-side -cword -noprompt -tool ag<cr>
xnoremap g/             y:Grepper-side -noprompt -tool ag -query "<c-r>""<cr>
xmap     g*             g/

nnoremap <leader>*      <nop>
nnoremap <leader>**     :Grepper -cword -noprompt -tool ag <cr>
nnoremap <leader>*b     :Grepper -cword -noprompt -tool ag -buffer<cr>
nnoremap <leader>*o     :Grepper -cword -noprompt -tool ag -buffers<cr>
nmap     <leader>*B     <leader>*b
nmap     <leader>*O     <leader>*o

nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)
xmap <leader>* y:Grepper -noprompt -tool ag -query "<c-r>""<cr>

command! TODO Grepper -noprompt -tool git -query -E '(TODO|FIXME|XXX|\?\?\?)'



" % also matches HTML-tags/words etc
Plug 'vim-scripts/matchit.zip'


" hide (fold) everything except search string etc
Plug 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <leader>zs :Fs<cr>
nnoremap <leader>z/ :Fs<cr>
nnoremap <leader>zz :Fs<cr>

" show word under cursor
nnoremap <leader>z* :Fw<cr>
nnoremap <leader>zw :Fw<cr>

" show visual selection
vnoremap <leader>z y:Fp<space>\V<c-r>"<cr>

" change context size (number of lines around matches)
nnoremap <leader>z+ :Fi<cr>
nnoremap <leader>zi :Fi<cr>
nnoremap <leader>z- :Fd<cr>
nnoremap <leader>zd :Fd<cr>

" restore folds
nnoremap <leader>ze :Fe<cr>
nnoremap <leader>Z  :Fe<cr>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

" Plug 'kien/ctrlp.vim'

" let g:ctrlp_map = '#'
" let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap <leader>ef :CtrlPRoot<cr>
nnoremap <leader>er :CtrlPMRUFiles<cr>
nnoremap <leader>em :CtrlPMixed<cr>
nnoremap <leader>eo :CtrlPRoot<cr>
nnoremap <leader>eb :CtrlPBuffer<cr>

" ignore some stuff (in addition to 'wildignore')
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<esc><enter>', '<c-l>', '<c-v>', '<rightmouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<right>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<left>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1

" only cache if we're in huge projects
let g:ctrlp_use_caching = 2000


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf - great fuzzy finder {{{
" (makes ctrlp and the ag plugin obsolete)
" (prefixing a word with ' makes it non-fuzzy)

" install 'fzf' package on the system. or:
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }
Plug 'junegunn/fzf.vim'
Plug 'stsewd/fzf-checkout.vim'

" prefix all the command names
let g:fzf_command_prefix = 'Fzf'

" how/where to open fzf
let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }

" extra interactive key bindings
" (scroll with <c-k> and <c-j>
let g:fzf_action = {
  \ 'ctrl-x': 'split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-l': 'vsplit',
  \ 'ctrl-v': 'vsplit',
  \ 'ctrl-t': '$tab split',
  \ '!':      '$tab split',
  \ }
" \ 'ctrl-k': 'previous-history',
" \ 'ctrl-j': 'next-history',

" enable per-command history
" (scroll through history with <c-p> and <c-n>)
let g:fzf_history_dir = '~/.local/share/fzf-history'

" Preview window settings (disable preview window altogether with empty value)
let g:fzf_preview_window = 'right:50%'

" override command to only match content (not filenames)
command! -bang -nargs=* FzfAg
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'down:50%')
  \                         : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:20%:hidden', '?'),
  \                 <bang>0)



" open files by name
nnoremap <leader>fl :FzfLocate<space>
nnoremap <leader>fi :FzfFiles<cr>
nnoremap <leader>ef :FzfFiles<cr>
nnoremap <leader>eo :FzfGFiles<cr>
nnoremap <leader>eg :FzfGFiles?<cr>
nnoremap <leader>er :FzfHistory<cr>
nnoremap <leader>eb :FzfBuffers<cr>
nnoremap <leader><leader>      :FzfBuffers<cr>
vnoremap <leader><leader> <Esc>:FzfBuffers<cr>

let g:fzf_tags_command = 'ctags -R -f .tags'
nnoremap <leader>et  :FzfTags<cr>
xnoremap <leader>et y:FzfTags <c-r>"<cr>

" type a search pattern
nnoremap <leader>f/         :FzfAg!<cr>
nnoremap <leader>ff         :FzfAg!<cr>
" search for word under cursor in working dir
nnoremap <leader>f*         :FzfAg! <c-r><c-w><cr>
nnoremap <leader>fw         :FzfAg! <c-r><c-w><cr>
nnoremap <leader>fW         :FzfAg! <c-r><c-a><cr>
" search for visual selection in working dir
xnoremap <leader>f*         y:<c-u>FzfAg! <c-r>"<cr>
xnoremap <leader>fw         y:<c-u>FzfAg! <c-r>"<cr>

" fuzzy search commands
nnoremap <leader>:          :FzfCommands<cr>
" fuzzy search command history
nnoremap <leader>h:         :FzfHistory:<cr>
" fuzzy search search history
nnoremap <leader>hs         :FzfHistory/<cr>
" fuzzy search helptags
nnoremap <leader>hh         :FzfHelptags<cr>

" autocomplete lines like a boss, even across multiple files
imap <c-x><c-l> <plug>(fzf-complete-line)


" adjust colors to colorscheme: gruvbox
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }


" Plug 'laher/fuzzymenu.vim'
nmap <leader>; <Plug>Fzm
vmap <leader>; <Plug>FzmVisual


"""""""""""""""""""""""""

" Plug 'yuki-yano/fzf-preview.vim', { 'branch': 'release/rpc' }
" TOO SLOW!

" " open files by name
" nnoremap <leader>fi :FzfPreviewProjectFilesRpc<cr>
" nnoremap <leader>ef :FzfPreviewProjectFilesRpc<cr>
" nnoremap <leader>eo :FzfPreviewGitFilesRpc<cr>
" nnoremap <leader>eb :FzfPreviewBuffersRpc<cr>
" nnoremap <leader><leader> :FzfPreviewBuffersRpc<cr>

" " jump to line in current buffer
" nnoremap <leader>el :FzfPreviewLinesRpc<cr>

" " project grep
" nnoremap <leader>/ :FzfPreviewProjectGrepRpc<space>
" xnoremap <leader>/ "sy:FzfPreviewProjectGrepRpc<Space>-F<Space>"<C-r>=substitute(substitute(@s, '\n', '', 'g'), '/', '\\/', 'g')<CR>"

" " search command history
" nnoremap <leader>h:         :FzfPreviewCommandPaletteRpc:<cr>

" " search TODO etc.
" nnoremap <leader>h:         :FzfPreviewTodoCommentsRpc:<cr>

" " open Github PR that introduced line
" " :FzfPreviewBlamePRRpc

" " [coc] jump to definitions
" nnoremap <leader>ed :CocCommand fzf-preview.CocTypeDefinitions<cr>



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Telescope - another highly extendable fuzzy finder
" TOO SLOW!

" Neovim Nightly (0.5) is required for telescope.nvim to work.

" if has('nvim')

"     Plug 'nvim-lua/popup.nvim'
"     Plug 'nvim-lua/plenary.nvim'
"     Plug 'nvim-telescope/telescope.nvim'

lua << EOF
--[[
require('telescope').setup{
  defaults = {
    vimgrep_arguments = {
      'rg',
      '--color=never',
      '--no-heading',
      '--with-filename',
      '--line-number',
      '--column',
      '--smart-case'
    },
    prompt_prefix = ">>> ",
  }
}
--]]

EOF

    " fzf-writer!
    " https://github.com/nvim-telescope/telescope-fzf-writer.nvim

    " cooler typ config?
    " https://github.com/smithbm2316/dotfiles/tree/main/nvim

    " nnoremap <leader>hh <cmd>Telescope help_tags<cr>
    " nnoremap <leader>ef <cmd>Telescope find_files<cr>
    " nnoremap <leader>j/ <cmd>Telescope live_grep<cr>
    " nnoremap <leader>eb <cmd>Telescope buffers<cr>
    " nnoremap <leader><leader> <cmd>Telescope buffers<cr>


" endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plug 'Shougo/vimproc.vim'
"Plug 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) {{{

" install 'ctags' package on the system

" generate tag file manually
" (fails with '–exclude=@.gitignore' when the file does not exist!)
" nnoremap <leader>eT :!ctags -R -f .tags .<cr>


" generate tag file automagically
Plug 'craigemery/vim-autotag'

let g:autotagTagsFile=".tags"



Plug 'majutsushi/tagbar'

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <leader>tb :TagbarToggle<cr>

"autocmd FileType vim nested :TagbarOpen()<cr>



" jump to definitions without relying on tags
Plug 'misterbuckley/vim-definitive'
" Plug 'flipsi/vim-definitive'

nnoremap <leader>fd :FindDefinition<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file management {{{

" write buffer with sudo
" (because the `:w !sudo tee % > /dev/null` does not work in neovim)
Plug 'lambdalisue/suda.vim'

cnoreabbrev w!! SudaWrite


" sugar for unix shell commands like move/rename/delete/find files etc.
Plug 'tpope/vim-eunuch'

nnoremap <leader>rn :Rename <c-r>=expand("%:t")<cr>
nnoremap <leader>rm :Confirm Delete!<cr>


" Plug 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show nerdtree from current file
" noremap <silent> <leader>tn :NERDTreeFind<cr>
" show/hide nerdtree
" noremap <silent> <leader>tN :NERDTreeToggle<cr>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'


" pimp netrw
" Plug 'tpope/vim-vinegar'

" delete a buffer in Vim without closing the window
" (required by ranger.vim)
if has('nvim')
    Plug 'rbgrouleff/bclose.vim'
    let g:bclose_no_plugin_maps = 1
    " let g:no_plugin_maps = true
endif

" use ranger file manager as file chooser etc.
Plug 'francoiscabrol/ranger.vim'

" open ranger when vim opens a directory
let g:ranger_replace_netrw = 1

" map keys explicitly
let g:ranger_map_keys = 0

" open ranger in a vertical split window at the left
nnoremap <silent> <leader>ir :vertical split <bar> wincmd H <bar> vertical resize 60 <bar> Ranger <cr>
nnoremap <silent> <leader>iR :vertical split <bar> wincmd H <bar> vertical resize 60 <bar> RangerWorkingDirectory <cr>

" close window when exiting ranger (and fix window width afterwards)
augroup ranger_autoclose
    au!
    au BufWipeout term://*ranger* quit | wincmd =
augroup END

" ranger alternative
Plug 'theniceboy/joshuto.nvim'

" open ranger in a vertical split window at the left
nnoremap <silent> <m-i>   :Joshuto <cr>
nnoremap <silent> <esc>i  :Joshuto <cr>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" close all other buffers {{{

Plug 'vim-scripts/BufOnly.vim'

nmap <leader>qO :BufOnly<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

" old school synchronous linter
" Plug 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex", "scala"] }
" let g:syntastic_cpp_compiler = 'clang++'
" let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_c_cppcheck_args = ' -std=c++11 -stdlib=libc++'

" nnoremap <silent> <leader>sc :SyntasticCheck<cr>
" nnoremap <silent> <leader>sr :SyntasticReset<cr>
" nnoremap <silent> <leader>st :SyntasticToggleMode<cr>
" nnoremap <silent> <leader>si :SyntasticInfo<cr>

" install linters on the system:
" - pylint
" - jslint / jshint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)
" - fsc
" - scalac
" - shellcheck
" - markdownlint

let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']
" let g:syntastic_javascript_checkers = ['eslint', 'jshint', 'jslint']
let g:syntastic_javascript_checkers = ['eslint', 'jshint']
let g:syntastic_scala_checkers = ['fsc']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mFile is being conditionally included;',
            \ '\mFile is being unconditionally included;',
            \ '\mLine indented incorrectly;.*',
            \ '\mMulti-line IF statement not indented correctly;.*',
            \ '\mEach line in a multi-line IF statement must begin with a boolean operator.*',
            \ '\mSpace after opening parenthesis of function call prohibited.*',
            \ '\mExpected 0 spaces before closing bracket; .* found.*',
            \ '\mExpected \\"foreach (...) {\\n\\"; found \\"foreach(...) {\\n\\".*',
            \ '\mExpected \\"if (...) {\\n\\"; found \\"if(...) {\\n\\".*',
            \ '\mExpected \\"} elseif (...) {\\n\\"; found \\"} elseif(...) {\\n\\".*',
            \ '\mOpening brace should be on a new line.*',
            \ '\mBad line breaking before .+..',
            \ '\mInline control structures are discouraged',
            \ '\mClosing parenthesis of a multi-line IF statement must be on a new line',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mDon.t use adjoining classes.',
            \ '\mDon.t use IDs in selectors.',
            \ '\mHeading (h.) should not be qualified.',
            \ '\mShort PHP opening tag used;',
            \ '\m.$. was used before it was defined.',
            \ '\mpossible unwanted space at "{"',
            \ '\mFunction name .* is prefixed with a package name but does not begin with a capital letter',
            \ '\m.$. was used before it was defined.'
            \ ] }



if !has('nvim')

    " asynchronous alternative to syntastic
    Plug 'w0rp/ale'

    let g:ale_list_window_size = 5
    let g:ale_lint_on_enter = 0
    let g:ale_linters = {
                \   'markdown': ['markdownlint'],
                \   'clojure': ['clj-kondo'],
                \   'javascript': ['eslint'],
                \   'typescript': ['tsserver', 'tslint'],
                \   'vue': ['eslint']
                \}
    let g:ale_fixers = {
                \    'javascript': ['eslint'],
                \    'typescript': ['prettier'],
                \    'vue': ['eslint'],
                \    'markdown': ['prettier'],
                \    'scss': ['prettier'],
                \    'html': ['prettier']
                \}

    " disable hints for certain languages,
    " because coc aleady provides this
    let g:ale_linters_ignore = {'clojure': ['clj-kondo']}

    " add some options
    let g:ale_python_pylint_options = '--rcfile $HOME/.vim/config/pylint.rc'

    nnoremap <silent> <leader>sc :ALELint<cr>
    nnoremap <silent> <leader>sn :ALENext<cr>
    nnoremap <silent> <leader>sN :ALEPrevious<cr>
    nnoremap <silent> <leader>sp :ALEPrevious<cr>
    nnoremap <silent> <leader>sr :ALEDisable<cr>
    nnoremap <silent> <leader>st :ALEToggle<cr>
    nnoremap <silent> <leader>si :ALEInfo<cr>

else

    Plug 'mfussenegger/nvim-lint'

    " With ale we already got an asynchronous linter, why write yet another one?
    " Because ale also includes its own language server client.
    " nvim-lint instead has a more narrow scope: It spawns linters, parses their output, and reports the results via the vim.diagnostic module.

endif

" evaluate expression live, which is awesome
" Plug 'metakirby5/codi.vim'



" lookup stuff
" Plug 'dbeniamine/cheat.sh-vim'

let g:CheatSheetDefaultMode=0

let g:CheatSheetDoNotMap=1

" use line as query and paste result after line
nnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 3, '!')<cr>
vnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", -1, -1, 3, 1, '!')<cr>


"result in buffer
nnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 0, '!')<cr>
vnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", -1, -1, 2, 0, '!')<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Treesitter (live AST of the code as you type) {{{
"
if has('nvim')

    Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}

    " list all available languages and their installation status with
    " :TSInstallInfo
    "
    " install language parser:
    " TSInstall <language>
    "
endif

" Show context / Sticky scroll
Plug 'wellle/context.vim'

let g:context_highlight_normal = 'Normal'
let g:context_highlight_border = 'Comment'
let g:context_highlight_tag    = 'Special'

let g:context_filetype_blacklist = [
            \ 'json',
            \ 'toml',
            \ ]

nnoremap <silent> <leader>yC :ContextToggle <cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Several (treesitter-enhanced) improvements {{{

if has('nvim')
    Plug 'echasnovski/mini.nvim'
else
    Plug 'tpope/vim-unimpaired'
endif



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" miscellaneous text editing plugins {{{

" adjustments for text (not code)
Plug 'preservim/vim-pencil'
nnoremap <leader>yi :TogglePencil<cr>


" replace some motion or text object or selection with current yank
Plug 'vim-scripts/ReplaceWithRegister'
nmap 'r  <plug>ReplaceWithRegisterOperator
nmap 'rl <plug>ReplaceWithRegisterLine
xmap 'r  <plug>ReplaceWithRegisterVisual


" preview register contents
" (seems buggy in neovim)
if !has('nvim')
    Plug 'junegunn/vim-peekaboo'
endif


" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plug 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <leader>pp <plug>yankstack_substitute_older_paste
nmap <leader>nn <plug>yankstack_substitute_newer_paste
"call yankstack#setup() " DOES NOT WORK HERE


if has('nvim')

    " Note: neovim has built-in commenting (since nvim 0.10) (see :help commenting)
    " https://www.reddit.com/r/neovim/comments/1bwlvrt/neovim_now_has_builtin_commenting/
    "
    nmap <leader>c gc

    " However, leading space padding (e.g. in vimscript) is 'broken'.
    "
    " enhance built-in commenting
    "Plug 'folke/ts-comments.nvim'
    "
    " ... so I use mini.comment (from 'echasnovski/mini.nvim')

else
    " alternative from the pope: Plug 'tpope/vim-commentary'
    "
    Plug 'scrooloose/nerdcommenter'
    " use leading space, but delete trailing space
    let g:NERDSpaceDelims = 1
    let g:NERDTrimTrailingWhitespace = 1
    " do not nest by default
    let g:NERDDefaultNesting = 1
    let g:NERDAltDelims_javascript = 0
    " align multiline comments
    let g:NERDDefaultAlign = 'left'
    " nmap 'c <leader>c
    " xmap 'c <leader>c
    " comment text objects and movements
    nmap <leader>c<down> V<down><plug>NERDCommenterInvert
    nmap <leader>c<up>   V<up><plug>NERDCommenterInvert
    nmap        'c<down> V<down><plug>NERDCommenterComment
    nmap        'c<up>   V<up><plug>NERDCommenterComment
    for mov in ['j', 'k', 'gg', 'G', '(', ')', '{', '}', 'as', 'is', 'ap', 'ip']
        exe "nmap \<leader\>c" . mov . " V" . mov . "\<plug\>NERDCommenterInvert"
        exe "nmap 'c"          . mov . " V" . mov . "\<plug\>NERDCommenterComment"
    endfor
    for i in range(1, 50)
        exe "nmap \<leader\>c" . i . "j        V" . i . "j\<plug\>NERDCommenterInvert"
        exe "nmap \<leader\>c" . i . "\<down\> V" . i . "j\<plug\>NERDCommenterInvert"
        exe "nmap \<leader\>c" . i . "k        V" . i . "k\<plug\>NERDCommenterInvert"
        exe "nmap \<leader\>c" . i . "\<up\>   V" . i . "k\<plug\>NERDCommenterInvert"
        exe "nmap 'c"          . i . "j        V" . i . "j\<plug\>NERDCommenterComment"
        exe "nmap 'c"          . i . "\<down\> V" . i . "j\<plug\>NERDCommenterComment"
        exe "nmap 'c"          . i . "k        V" . i . "k\<plug\>NERDCommenterComment"
        exe "nmap 'c"          . i . "\<up\>   V" . i . "k\<plug\>NERDCommenterComment"
    endfor

endif

" duplicate a line and comment out the first one
nmap <leader>cd yygccp

" do not comment on new lines (except when already in insert mode)
nnoremap o o<esc>S
nnoremap O O<esc>S


" automagically add closing braces etc
" Plug 'Raimondi/delimitMate'

" Plug 'jiangmiao/auto-pairs'
" Mappings are created even in insert mode, so with <space> as leader this sucks.
let g:AutoPairsShortcutToggle = '<leader>oap'
let g:AutoPairsShortcutJump = '<leader>]'
let g:AutoPairsMapSpace = 0
" remember <M-e> to move closing brace to end of word

" Plug 'rstacruz/vim-closer'
Plug 'tpope/vim-endwise'



" add a ; at the end of a line
"Plug 'lfilho/cosco.vim'
"inoremap <silent> <esc><enter> <esc>:call cosco#commaOrSemiColon()<cr>A<enter>
inoremap <silent> <esc><enter> <esc>A;<esc>^


" add/change/delete quotes/braces/... and more
Plug 'tpope/vim-surround'

" surround consistently in both modes and more comfortably on german keyboard
nmap 's ys
vmap 's S

" surround with quotes/parentheses/brackets quickly
vmap '' S'
vmap '" S"
nmap '' ysiw'
nmap '" ysiw"
nmap 'q ysiW'
nmap 'Q ysiW"
vmap 'b S)
vmap 'B S}
nmap 'b ysiw)
nmap 'B ysiw}
vmap '` S`
nmap '` ysiW`
nmap d' ds'
nmap d" ds"
nmap dq ds'
nmap dQ ds"

" toggle quotes {{{
function! ToggleQuotesWithVimSurround()
    let pos_cursor = getpos(".")[2]
    let linepart   = strpart(getline("."), pos_cursor - 1)
    let pos_single = stridx(linepart, "'")
    let pos_double = stridx(linepart, '"')
    if pos_single >= 0 && (pos_double < 0 || pos_single < pos_double)
        normal cs'"
    elseif pos_double >= 0 && (pos_single < 0 || pos_double < pos_single)
        normal cs"'
    endif
endfunction
" }}}
nnoremap <silent> 'tq :call ToggleQuotesWithVimSurround()<cr>


" swap ('transpose') two words or arbitrary things
Plug 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <leader>x <plug>(Exchange)
xmap <leader>x <plug>(Exchange)
nmap <leader>xc <plug>(ExchangeClear)
nmap <leader>xl <plug>(ExchangeLine)
nmap <leader>xx <leader>xiw


" " find and replace tool for multiple files (IDE like)
" Plug 'brooth/far.vim'
" nnoremap <leader>SS :Far  **<left><left><left>
" vnoremap <leader>SS :Far *  **<left><left><left>
" nnoremap <leader>SD :Fardo<cr>


" " add "printf" statements with shortcut
" Plug 'bergercookie/vim-debugstring'

" nmap <leader>ad <plug>DumpDebugString



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" multiple cursor like in Sublime {{{

" SEEMS NOT TO WORK PROPERLY FOR ME

" Plug 'terryma/vim-multiple-cursors'

" let g:multi_cursor_use_default_mapping=0

" " (only single keystrokes are possible at the moment)
" let g:multi_cursor_next_key='<c-n>'
" let g:multi_cursor_prev_key='<c-p>'
" let g:multi_cursor_skip_key='<c-x>'
" let g:multi_cursor_quit_key='<esc>'
" nnoremap '<c-c> :call multiple_cursors#quit()<cr>

" let g:multi_cursor_exit_from_visual_mode=1
" let g:multi_cursor_exit_from_insert_mode=0


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better diff {{{

" diff two visually selected blocks of code (in new tab)
Plug 'AndrewRadev/linediff.vim'
vnoremap <leader>dv :Linediff<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" run make or jobs asynchronously {{{

Plug 'tpope/vim-dispatch'
Plug 'radenling/vim-dispatch-neovim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better quickfix window {{{

" edit quickfix list (make changes directly after global search or linting)
Plug 'Olical/vim-enmasse'


" automatically resize quickfix window
Plug 'blueyed/vim-qf_resize'

let g:qf_resize_min_height = 1
let g:qf_resize_max_height = 8


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plug 'shinokada/dragvisuals.vim'
"vmap <expr> <c-h>  DVB_Drag('left')
"vmap <expr> <c-l>  DVB_Drag('right')
"vmap <expr> <c-j>  DVB_Drag('down')
"vmap <expr> <c-k>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plug 'zirrostig/vim-schlepp'

" vmap <up>    <plug>SchleppUp
" vmap <down>  <plug>SchleppDown
" vmap <left>  <plug>SchleppLeft
" vmap <right> <plug>SchleppRight

" duplicate
" (delete selection with x. by default, x and d do the same)
vmap 'u <plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plug 'vim-scripts/toggle_words.vim'

noremap <silent> 'tw :ToggleWord<cr>

let g:toggle_words_dict = {
            \ 'clojure': [
            \     ['true?', 'false?'],
            \ ],
            \ 'css': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['header', 'footer'],
            \ ],
            \ 'sql': [
            \     ['SET', 'DROP'],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ['0', '1'],
            \     ['add', 'remove'],
            \     ['and', 'or'],
            \     ['ascending', 'descending'],
            \     ['authentication', 'authorization'],
            \     ['ASC', 'DESC'],
            \     ['begin', 'end'],
            \     ['big', 'little'],
            \     ['black', 'white'],
            \     ['clean', 'dirty'],
            \     ['create', 'delete'],
            \     ['dark', 'bright'],
            \     ['deep', 'shallow'],
            \     ['dynamic', 'static'],
            \     ['enable', 'disable'],
            \     ['enabled', 'disabled'],
            \     ['fast', 'slow'],
            \     ['fat', 'thin'],
            \     ['first', 'last'],
            \     ['forward', 'backward'],
            \     ['get', 'set'],
            \     ['good', 'bad'],
            \     ['happy', 'sad'],
            \     ['hard', 'soft'],
            \     ['head', 'tail'],
            \     ['hide', 'show'],
            \     ['high', 'low'],
            \     ['header', 'footer'],
            \     ['in', 'out'],
            \     ['initialize', 'terminate'],
            \     ['initialization', 'termination'],
            \     ['inner', 'outer'],
            \     ['left', 'right'],
            \     ['light', 'dark'],
            \     ['local', 'global'],
            \     ['login', 'logout'],
            \     ['long', 'short'],
            \     ['love', 'hate'],
            \     ['many', 'few'],
            \     ['master', 'slave', 'develop'],
            \     ['min', 'max'],
            \     ['more', 'less'],
            \     ['new', 'old'],
            \     ['next', 'previous'],
            \     ['on', 'off'],
            \     ['online', 'offline'],
            \     ['open', 'close'],
            \     ['personal', 'group'],
            \     ['public', 'private'],
            \     ['present', 'absent'],
            \     ['question', 'answer'],
            \     ['red','orange','yellow','green','blue','purple'],
            \     ['setup', 'teardown'],
            \     ['single', 'double', 'multi'],
            \     ['start', 'stop'],
            \     ['started', 'stopped'],
            \     ['starting', 'stopping'],
            \     ['strong', 'weak'],
            \     ['testing', 'production'],
            \     ['this', 'that'],
            \     ['top', 'bottom'],
            \     ['true', 'false'],
            \     ['up', 'down'],
            \     ['vertical', 'horizontal'],
            \     ['wide', 'narrow'],
            \     ['width', 'height'],
            \     ['write', 'read'],
            \     ['yes', 'no'],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plug 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger='<c-k>'
"let g:UltiSnipsListSnippets='<esc>.'
let g:UltiSnipsJumpForwardTrigger='<c-i>'
let g:UltiSnipsJumpBackwardTrigger='<c-o>'
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'sflipsnippets']


" snippet packs
Plug 'honza/vim-snippets'

" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html

" fix indenting with == in PHP files
" https://stackoverflow.com/a/27017167/4568748
autocmd filetype php set filetype=html
autocmd filetype php set syntax=php


" For some files, I don't want fancy features that require snippets to contain escape sequences.
" But I want to substitute variables with personal data after expansion.
" So I built these custom functions:

function! InsertMyTemplate()
    let l:template_dir = expand('$HOME/dotfiles/vim/templates/')

    " List all files in the template directory
    let l:files = split(globpath(l:template_dir, '*'), "\n")
    if empty(l:files)
        echoerr "No templates found in " . l:template_dir
        return
    endif

    " Strip directory paths, keep only filenames
    let l:filenames = map(l:files, 'fnamemodify(v:val, ":t")')

    " Call rofi to select a template interactively
    let l:choice = system('printf "%s\n" ' . join(l:filenames, ' ') . ' | rofi -dmenu -i -p "Select template:"')
    let l:choice = substitute(l:choice, '\n$', '', '')  " Remove trailing newline

    if empty(l:choice)
        echo "No template selected."
        return
    endif

    let l:path = l:template_dir . l:choice
    call InsertMyTemplateByPath(l:path)
endfunction

function! InsertMyTemplateByPath(path)
    exe '.-1read ' . a:path
    let l:variable_substitution_prefix = 'FLIPSIS_PERSONAL_'
    call SubstituteVariables(l:variable_substitution_prefix)
endfunction

function! SubstituteVariables(prefix)
    let l:pattern = '\v' . escape(a:prefix, '\.^$*[]') . '\k*'
    let l:view = winsaveview()
    silent execute '%s/' . l:pattern . '/\=ReadTemplateValueFromDisk(submatch(0))/ge'
    call winrestview(l:view)
endfunction

function! ReadTemplateValueFromDisk(variable_name)
    call system('touch /tmp/vimtest/' . a:variable_name)
    let l:newline_join_string = "\\\\"
    let l:variable_file = expand('$HOME/dotfiles/vim/template_values/') . a:variable_name
    if filereadable(l:variable_file)
        let l:lines = readfile(l:variable_file)
        return join(l:lines, l:newline_join_string)
    else
        throw 'Could not find file for variable substitution: ' . l:variable_file . '. Please create it!'
    endif
endfunction


nnoremap 'S :call InsertMyTemplate()<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced autocompletion {{{
"
" Plug 'Valloric/YouCompleteMe'
" let g:ycm_server_python_interpreter = '/usr/bin/python3'
" let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
let g:ycm_key_invoke_completion = '<esc>.'
let g:ycm_key_list_select_completion   = ['<c-n>', '<down>', '<tab>', '<enter>']
let g:ycm_key_list_previous_completion = ['<c-p>', '<up>']
" let g:ycm_show_diagnostics_ui = 0


" autocompletion in command mode
Plug 'vim-scripts/CmdlineComplete'
cmap <c-p> <plug>CmdlineCompleteBackward
cmap <c-n> <plug>CmdlineCompleteForward


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" generate docs {{{

" generate javascript docs
" Plug 'heavenshell/vim-jsdoc'
" nnoremap <silent> 'adj ?function<cr>:noh<cr><plug>(jsdoc)
nnoremap <silent> 'adj :JsDoc<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

" show indentation level
Plug 'Yggdroot/indentLine'

let g:indentLine_enabled = 1
" let g:indentLine_char = '┊'
let g:indentLine_char = '|'
let g:indentLine_fileTypeExclude = ['text', 'sh']
let g:indentLine_bufTypeExclude = ['help', 'terminal']
let g:indentLine_bufNameExclude = ['_.*', 'NERD_tree.*']

nnoremap <leader>yI :IndentLinesToggle<cr>


" align plugin
Plug 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-L=)
xmap 'L <plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -LG=)
nmap 'L <plug>(EasyAlign)


" The tabular plugin must come before vim-markdown.
Plug 'godlygeek/tabular'

Plug 'tommcdo/vim-lion'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

if has('nvim')

    Plug 'stevearc/conform.nvim'

else

    Plug 'Chiel92/vim-autoformat'

    " install formatters on the system:
    " - js-beautify (for HTML, CSS, JavaScript, JSON)
    " - prettier (for JavaScript, TypeScript)
    " - scalafmt (for scala)

    nnoremap 'af :Autoformat<cr>:GitGutter<cr>
    vnoremap 'af :Autoformat<cr>:GitGutter<cr>
    nmap <leader>af 'af
    vmap <leader>af 'af

    let g:formatdef_php = '" php-cs-fixer.phar fix"'
    let g:formatters_php = ['php']

    let g:formatdef_scalafmt = '"scalafmt --stdin 2>/dev/null"'
    let g:formatters_scala = ['scalafmt']

    let g:formatdef_prettier_typescript = '"prettier --parser typescript"'
    let g:formatters_typescript = ['prettier_typescript']


    " autoformat for json does not work out with the plugin above. do this instead:
    augroup json_map_autoformat
        au!
        au FileType json nnoremap <buffer> 'af :%!python -m json.tool<cr>
        au FileType json nmap <buffer> <leader>af 'af
    augroup END

    " autoformat for sql
    augroup sql_map_autoformat
        au!
        au FileType sql nnoremap <buffer> 'af :%!sql-formatter-cli -<cr>
        au FileType sql nmap <buffer> <leader>af 'af
    augroup END

endif

" change wrapping of function arguments
Plug 'FooSoft/vim-argwrap'

nnoremap <silent> 'tf :ArgWrap<cr>



" coercion:
" - MixedCase (crm),
" - camelCase (crc),
" - snake_case (crs),
" - UPPER_CASE (cru),
" - dash-case (cr-),
" - dot.case (cr.),
" - space case (cr<space>),
" - Title Case (crt)
Plug 'tpope/vim-abolish'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" don't worry about 'shiftwidth' and 'expandtab' etc. {{{

Plug 'tpope/vim-sleuth'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plug 'vim-scripts/ShowTrailingWhiteSpace'
let g:ShowTrailingWhitespace = 1
command! -bar ShowTrailingWhitespaceOn  call ShowTrailingWhitespace#Set(1,1)
command! -bar ShowTrailingWhitespaceOff call ShowTrailingWhitespace#Set(0,1)
command! -bar ShowTrailingWhitespaceToggle call ShowTrailingWhitespace#Toggle(0)
        \ <bar>echo (ShowTrailingWhitespace#IsSet() ?
        \ 'Show trailing whitespace' : 'Not showing trailing whitespace')
nnoremap <silent> <leader>yA  :ShowTrailingWhitespaceToggle<cr>
nnoremap <silent> <leader>yst :ShowTrailingWhitespaceToggle<cr>

" (has a bug)
"Plug 'vim-scripts/JumpToTrailingWhiteSpace'


Plug 'vim-scripts/DeleteTrailingWhiteSpace'

" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'ask'

function! DeleteTrailingWhitespaceInGitRepo()
    if IsGitRepository(expand("%:p:h"))
        let b:DeleteTrailingWhitespace_Action = 'delete'
    end
endfunction

augroup delete_trailing_whitespace_in_git_repo
    autocmd!
    autocmd BufRead * call DeleteTrailingWhitespaceInGitRepo()
augroup END

" disable for specific files automatically
augroup delete_trailing_whitespace_disable
    au!
    au FileType mail let b:DeleteTrailingWhitespace = 0
    au BufRead /dev/shm/pass.* let b:DeleteTrailingWhitespace = 0
augroup END

" enable/disable plugin
nnoremap <leader>dst :let g:DeleteTrailingWhitespace = 1 - g:DeleteTrailingWhitespace<cr>
            \ :echo g:DeleteTrailingWhitespace == 1 ?
            \ 'DeleteTrailingWhitespace enabled' :
            \ 'DeleteTrailingWhitespace disabled'<cr>
" delete trailing whitespace for selected line
vnoremap <silent> 'dst :DeleteTrailingWhitespace<cr>
" delete trailing whitespace for whole buffer
nnoremap <silent> 'dst :%DeleteTrailingWhitespace<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make colors visible (e.g. '#DD8844' will have orange background)
if has('nvim')
    Plug 'brenoprata10/nvim-highlight-colors'
else
    Plug 'ap/vim-css-color'
endif

" convert between color formats (color under cursor or visually selected)
Plug 'amadeus/vim-convert-color-to'
nnoremap 'cch :ConvertColorTo hex<cr>
nnoremap 'ccr :ConvertColorTo rgb<cr>
nnoremap 'cca :ConvertColorTo rgba<cr>

" launch colorpicker and insert color code
" TODO: find something that is not old and broken
Plug 'blindFS/vim-colorpicker'
nnoremap <leader>icp :ColorPicker<cr>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plug 'KabbAmine/vCoolor.vim'
"nnoremap <leader>cp :VCoolor<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Completion and other smart IDE features via LSP {{{
"

" Looking up references is not needed when one has LSP, right?
" Plug 'thinca/vim-ref'
":Ref STUFF
"
"
if has('nvim')

    Plug 'neovim/nvim-lspconfig'
    Plug 'hrsh7th/cmp-nvim-lsp'
    Plug 'hrsh7th/nvim-cmp'
    Plug 'hrsh7th/cmp-buffer'
    Plug 'williamboman/mason.nvim'
    Plug 'williamboman/mason-lspconfig.nvim'

    " Plug 'mfussenegger/nvim-jdtls' " Java LSP
    " IMPORTANT: If you want all the features jdtls has to offer, [nvim-jdtls](https://github.com/mfussenegger/nvim-jdtls)
    " is highly recommended. If all you need is diagnostics, completion, imports, gotos and formatting and some code actions
    " you can keep reading here.

    " Plug 'VonHeikemen/lsp-zero.nvim', {'branch': 'v4.x'}
    " https://lsp-zero.netlify.app/docs/getting-started.html
    " Plot twist: You can get the same setup without lsp-zero.

    " Config see lsp.lua

    nnoremap <leader>ii  <nop>
    nnoremap <leader>iii :LspInstall<space>
    nnoremap <leader>iim :Mason<cr>

    nnoremap <leader>iis :LspInfo<cr>
    nnoremap <leader>iia :LspStart<cr>
    nnoremap <leader>iio :LspStop<cr>

    nnoremap <leader>idd    :lua vim.diagnostic.disable()<cr>
    nnoremap <leader>ide    :lua vim.diagnostic.enable()<cr>
    nnoremap <leader>in     :lua vim.diagnostic.goto_next()<cr>
    nnoremap <leader>iN     :lua vim.diagnostic.goto_prev()<cr>
    nnoremap <leader>igg  gg:lua vim.diagnostic.goto_next()<cr>
    nnoremap <leader>iG    G:lua vim.diagnostic.goto_prev()<cr>

    " for more (dynamic/buffer local) mappings also see lsp.lua

else

    Plug 'neoclide/coc.nvim', {'branch': 'release'}
    " Switched to the more modern built-in nvim LSP.
    " (I was hesitant because I wanted my setup to work with vanilla vim too, but let's be honest, I don't use it anymore for real development.)

    " Install CoC plugins manually on each host:

    " Scala:
    " vim (in Scala project):       :CocInstall coc-metals " DEPRECATED

    " Clojure:
    " system:                       yay -S clojure-lsp-bin
    " vim (in Clojure project):     :CocInstall coc-clojure

    " Golang:
    " system:                       yay -S gopls
    " vim (in Go project):          :CocInstall coc-go

    " Markdown:
    " system:                       yay -S markdownlint
    " vim (in Go project):          :CocInstall coc-markdownlint


    nnoremap <leader>i <nop>
    nnoremap <leader>j <nop>

    command! CocToggle :call CocToggle() " Enable or Disable COC

    function! CocToggle()
        if !exists('g:coc_workspace_initialized') || g:coc_workspace_initialized == 0
            CocStart
        elseif g:coc_enabled == 1
            CocDisable
        else
            CocEnable
        endif
    endfunction

    let g:coc_start_at_startup = 1

    " start/stop coc
    nnoremap <leader>ii  <nop>
    nnoremap <leader>iis :CocInfo<cr>
    nnoremap <leader>iia :CocStart<cr>
    nnoremap <leader>iio :CocStop<cr>
    nnoremap <leader>iit :CocToggle<cr>

    " choose coc command (fuzzy finder)
    nnoremap <leader>iic :CocList commands<cr>

    " hide error/warning popup
    nmap <leader>i<bs>      <Plug>(coc-float-hide)

    " show error/warning in a popup
    nmap <leader>ie         <Plug>(coc-diagnostic-info)

    " highlight symbol under cursor
    nnoremap <leader>ih             :call CocActionAsync('highlight')<cr>

    " show infos about function under cursor in popup
    nnoremap <silent> <leader>iq    :call <SID>show_documentation()<cr>

    " navigate to first/next/last error/warning
    nmap <leader>igg      gg<Plug>(coc-diagnostic-next)
    nmap <leader>iG        G<Plug>(coc-diagnostic-prev)
    nmap <leader>in         <Plug>(coc-diagnostic-next)
    nmap <leader>iN         <Plug>(coc-diagnostic-prev)

    " open errors in location list
    nnoremap <leader>iE         :CocDiagnostics<cr>

    " jump to specific error (fuzzy finder)
    nnoremap <leader>jE         :CocList diagnostics<cr>

    " jump to definition how I want it to behave
    command! JumpDefinition :call JumpDefinition()
    function! JumpDefinition()
        normal! mU
        let l:view = winsaveview()
        if CocAction('jumpDefinition', 'buffer') != v:false
            normal! mD
            normal! `U
            call winrestview(l:view)
            if winnr('#') && winnr('$') > 1
                wincmd p
                normal! `D
            else
                call CocAction('jumpDefinition', 'vsplit')
            endif
        endif
    endfunction

    " jump to definition etc.
    nnoremap <leader>jd         <nop>
    nnoremap <leader>jdl        :call CocActionAsync('jumpDefinition', 'vsplit')<cr>
    nnoremap <leader>jdb        :call CocActionAsync('jumpDefinition', 'buffer')<cr>
    nmap     <leader>jdd        :JumpDefinition<cr>
    " nmap     <leader>jdd        <Plug>(coc-definition)
    nmap     <leader>jD         <Plug>(coc-declaration)
    nmap     <leader>ji         <Plug>(coc-implementation)

    " jump to symbol (class, object, etc.)
    nnoremap <leader>es :CocList outline<cr>

    " find usages and show in quickfix list
    nmap <leader>fU <Plug>(coc-references)
    nmap <leader>fu :call SaveCursorAndWindowPosition()
                \ <bar> exe "normal \<Plug>(coc-references)"
                \ <bar> sleep 100m
                \ <bar> cclose <bar> bot copen
                \ <bar> echo 'Found ' . len(getqflist()) . ' usages (including declaration).'
                \ <bar> RestoreCursorAndWindowPosition <cr>

    " actions
    nmap <leader>ia         <Plug>(coc-codeaction)
    nnoremap <leader>ioi    :CocCommand editor.action.organizeImport<cr>
    nnoremap <leader>ifi    :call CocActionAsync('fold', 'imports')<cr>
    " nmap <leader>i<return>  <Plug>(coc-fix-current)
    nnoremap <leader>i<return>  :if g:coc_enabled == 1
                \ <bar> execute "normal \<Plug>(coc-fix-current)"
                \ <bar> else
                \ <bar> call AutoImportFake()
                \ <bar> endif <cr>

    " refactor/rename identifier
    nmap <leader>rf <Plug>(coc-rename)

    " cancel and confirm completion
    " inoremap <silent><expr> <C-e> coc#pum#visible() ? coc#pum#cancel() : "\<C-e>"
    " inoremap <silent><expr> <C-y> coc#pum#visible() ? coc#pum#confirm() : "\<C-y>"
    inoremap <silent><expr> <tab> coc#pum#visible() ? coc#pum#confirm() : "\<tab>"
    " (navigate with <c-n> and <c-p>)


    function! s:show_documentation()
    if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
    elseif (coc#rpc#ready())
        call CocActionAsync('doHover')
    else
        execute '!' . &keywordprg . " " . expand('<cword>')
    endif
    endfunction

    " Consider directories with those files project root
    autocmd FileType clojure let b:coc_root_patterns =
                \ ['.projectile', '.git', '.env']

    " echo project root
    nnoremap <leader>iir :CocCommand workspace.workspaceFolders<cr>
    " Hint: If this is wrong and .lsp dirs are created in the wrong dir, deleting .session.vim could help.
    " Hint: If afterwards, pwd is set to where .git is, not working dir, manually cd into working dir again.

endif


" show your current code context in statusline (like function name)
" TODO: configure
Plug 'SmiteshP/nvim-navic'


" Debugger
" Plug 'puremourning/vimspector'
nnoremap <leader>da     :call vimspector#Launch()<CR>
nnoremap <leader>dq     :call vimspector#Reset()<CR>
nmap     <leader>dj     <Plug>VimspectorStepInto
nmap     <leader>dl     <Plug>VimspectorStepOver
nmap     <leader>dk     <Plug>VimspectorStepOut
nmap     <leader>d_     <Plug>VimspectorRestart
nnoremap <leader>d<cr>  :call vimspector#Continue()<CR>
nmap     <leader>drc    <Plug>VimspectorRunToCursor
nmap     <leader>dbp    <Plug>VimspectorToggleBreakpoint
nmap     <leader>dcbp   <Plug>VimspectorToggleConditionalBreakpoint
nnoremap <leader>ddbp   :call vimspector#CleanLineBreakpoint()<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" AI coding assistance (chatbot integration etc.) {{{
"

if has('nvim')

    " system:
    "           pipx install aider-install
    "           aider-install
    Plug 'joshuavial/aider.nvim'

endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Language specific stuff {{{


Plug 'sheerun/vim-polyglot'

" helm is disabled so *.tpl files are considered smarty files
" markdown is disabled to use and configure the latest version explicitly
let g:polyglot_disabled = ['helm', 'markdown']


" Language: Clojure {{{

augroup is_keyword_clojure
    autocmd!
    autocmd FileType clojure setlocal iskeyword-=/
augroup END

augroup clojure_on_read
    au!
    au FileType clojure call SetupClojure()
    au FileType clojure call SetupClojureForCodeIntelligenceCore()
    au FileType clojure call SetupConjure()
augroup END

command! SetupClojure :call SetupClojure() " add mappings and settings for Clojure
function! SetupClojure()
    nnoremap <silent> 'at        :call append('.', '(tap> {:fun "' .  GetMostPreviousMatch('(\(defn-\?\\|deftest\)\s\+\(.*\)', '\2') . '" })')<cr>j==$hi
    nnoremap <silent> <leader>ct :call append('.', '(tap> {:fun "' .  GetMostPreviousMatch('(\(defn-\?\\|deftest\)\s\+\(.*\)', '\2') . '" })')<cr>j==$hi
    nnoremap <silent> <leader>co :call ToggleComment('n')<cr>
    vnoremap <silent> <leader>co :call ToggleComment('v')<cr>
    " specific coc clojure refactoring mappings
    " TODO: fix function call
    nnoremap <buffer> <silent> <leader>crcc :call LanguageClient#workspace_executeCommand('cycle-coll', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>crth :call LanguageClient#workspace_executeCommand('thread-first', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>crtt :call LanguageClient#workspace_executeCommand('thread-last', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>crtf :call LanguageClient#workspace_executeCommand('thread-first-all', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>crtl :call LanguageClient#workspace_executeCommand('thread-last-all', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>crml :call LanguageClient#workspace_executeCommand('move-to-let', [Expand('%:p'), line('.') - 1, col('.') - 1, input('Binding name: ')])<CR>
    nnoremap <buffer> <silent> <leader>cril :call LanguageClient#workspace_executeCommand('introduce-let', [Expand('%:p'), line('.') - 1, col('.') - 1, input('Binding name: ')])<CR>
    nnoremap <buffer> <silent> <leader>cril :CocCommand lsp-clojure-introduce-let<CR>
    nnoremap <buffer> <silent> <leader>crel :call LanguageClient#workspace_executeCommand('expand-let', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
    nnoremap <buffer> <silent> <leader>cram :call LanguageClient#workspace_executeCommand('add-missing-libspec', [Expand('%:p'), line('.') - 1, col('.') - 1])<CR>
endfunction

command! SetupClojureForCodeIntelligenceCore :call SetupClojureForCodeIntelligenceCore() " add mappings and settings for Clojure code at Code Intelligence
function! SetupClojureForCodeIntelligenceCore()
    let g:build_shell = ''
    let g:prompt_regex = '^bazel-wrapper: Executing gazelle$'
    " TODO: fix me (no real filenames in Clojure stacktraces unfortunately)
    set errorformat=ci_fuzz.backend%.%#\ (%f:%l)
    nnoremap <buffer> <leader>bdp :call RunCommandInBuildShell("bb build-backend-deps")<cr>
    nnoremap <buffer> <leader>bdP :call RunCommandInBuildShell("bazel build //backend:repl_runtime_deps_deploy.jar")<cr>
    nnoremap <buffer> <leader>bdd :call RunCommandInBuildShell("bb build:backend")<cr>
    nnoremap <buffer> <leader>btA :call RunCommandInBuildShell("clj -X:test")<cr>
    nnoremap <buffer> <leader>bta :call RunCommandInBuildShell("bb kaocha --focus-meta :backend")<cr>
    nnoremap <buffer> <leader>btn :call RunCommandInBuildShell("bb kaocha --focus " . CalculateKaochaFocusUnit('namespace'))<cr>
    nnoremap <buffer> <leader>bto :call RunCommandInBuildShell("bb kaocha --focus " . CalculateKaochaFocusUnit('singletest'))<cr>
    nnoremap <buffer> <leader>af  :exe "Dispatch! bb format fix " . expand("%")<cr>
    nnoremap <buffer> <leader>AF       :Dispatch! bb format<cr>
endfunction

function! CalculateKaochaFocusUnit(namespace_or_singletest)
    let l:deftest_pattern = '^(deftest\s\+\(.\+\)'
    " let l:lines_that_match_namespace_declaration = GetMatches('^(ns.*', 1, line('$'))
    let l:lines_that_match_namespace_declaration = GetMatches('\s\+ci-fuzz.*', 1, line('$')) " stupid workaround, because GetMatches does not work across line breaks
    let l:lines_that_match_deftest   = GetMatches(l:deftest_pattern, 1, line('$'))
    if len(l:lines_that_match_namespace_declaration) == 0 || len(l:lines_that_match_deftest) == 0
        throw "Could not find any test in current file."
    endif
    " let l:namespace  = substitute(l:lines_that_match_namespace_declaration[0], '^(ns\s\+\(\w\+\)', '\1', '')
    let l:namespace  = substitute(l:lines_that_match_namespace_declaration[0], '\s\+\(\w\+\)', '\1', '')
    if a:namespace_or_singletest == 'namespace'
        return l:namespace
    elseif a:namespace_or_singletest == 'singletest'
        let l:nearest_deftest_line = GetMostPreviousMatchingLine(l:deftest_pattern)
        let l:nearest_deftest_name = substitute(getline(l:nearest_deftest_line), l:deftest_pattern, '\1', '')
        return l:namespace . '/' . l:nearest_deftest_name
    else
        throw "Invalid argument for CalculateKaochaFocusUnit: " . a:namespace_or_singletest
    endif
endfunction

" https://thoughtbot.com/blog/writing-clojure-in-vim
" https://tomekw.com/nvim-for-clojure-development/
" https://smallsheds.garden/blog/clojure/2020/clj2-setting-up-vim/

" Fireplace is a 'Quasi-REPL' for Clojure
" Plug 'tpope/vim-fireplace'
" Plug 'ctford/vim-fireplace-easy'

" static project support (integrate Fireplace with Leiningen / Clojure CLI)
" Plug 'tpope/vim-salve'

" Some handy keybindings for working with the Clojure REPL
" Plug 'SevereOverfl0w/vim-replant'

" Semantic autocompletion
" Plug 'clojure-vim/async-clj-omni'
" Plug 'prabirshrestha/asyncomplete.vim'

" Alternative to Fireplace
" Clojure Interactive Development Environment
" Plug 'liquidz/vim-iced'

" Provides a couple of helper commands for 'jacking' in to a Clojure REPL by auto-starting it.
" (For Clojure CLI use :Clj)
Plug 'clojure-vim/vim-jack-in'
" Start an nREPL server with all of the appropriate middleware inside your Neovim instance
nnoremap <leader>la   <nop>
nnoremap <leader>laA  :Clj -M:ci-dev:repl
nnoremap <leader>laa  :Clj -M:ci-dev:repl<cr>
nnoremap <leader>lap  :Clj -M:ci-dev:repl:portal<cr>
nnoremap <leader>lac  :Clj -M:ci-dev:repl:clerk<cr>
nnoremap <leader>lxp  :ConjureEval (require '[portal.api :as portal]) (portal/open {:theme :portal.colors/zerodark})<cr>
nnoremap <leader>lxd  :ConjureEval (require '[clojure.repl :refer [doc]])<cr>
nnoremap <leader>lxc  :ConjureEval (require '[clojure.clerk :as :clerk])<cr>
nnoremap <leader>lcc  :ConjureConnect<cr>

" Yet another alternative to Fireplace
" Multi-language Interactive evaluation
" (uses the REPL started above for evaluation)
Plug 'Olical/conjure'
" Quick start for Clojure: https://github.com/Olical/conjure/wiki/Quick-start:-Clojure
" Use :ConjureSchool to get started
" See `:vertical help conjure-mappings` for (default) mappings

let g:conjure#mapping#prefix = "<leader>l"

let g:conjure#log#hud#ignore_low_priority = v:true
let g:conjure#log#jump_to_latest#enabled = v:false
let g:conjure#log#break_length = 120
let g:conjure#log#hud#minimum_lifetime_ms = 200
let g:conjure#log#hud#width = 1
let g:conjure#log#hud#anchor = "SW" " must be one of: NE, SE, SW, NW
let g:conjure#log#hud#border = "none"
let g:conjure#log#hud#zindex = 50

" TODO: why doesn't this setting have any effect?
command! ConjureLogsToggleWrap :call ConjureLogsToggleWrap()
function! ConjureLogsToggleWrap()
    let g:conjure#log#wrap = ! g:conjure#log#wrap
endfunction


" additional mappings
" TODO: run this in clj buffers after sourcing vimrc so that it overwrites the default mapping again
command! SetupConjure :call SetupConjure() " add Conjure mappings
function! SetupConjure()
    " TODO: make those work (eval before run)
    " nnoremap <buffer> <leader>ltt :ConjureCljRefreshAll <bar> ConjureCljRunAllTests<cr>
    " nnoremap <buffer> <leader>lto :ConjureEvalRootForm <bar> ConjureCljRunCurrentTest<cr>
    " nnoremap <buffer> <leader>ltn :ConjureEvalBuf <bar> ConjureCljRunCurrentNsTests<cr>
    nnoremap <buffer> <leader>ltt :call RunConjureCommand('ConjureCljRunAllTests')<cr>
    nnoremap <buffer> <leader>ltn :call RunConjureCommand('ConjureCljRunCurrentNsTests')<cr>
    nnoremap <buffer> <leader>lto :call RunConjureCommand('ConjureCljRunCurrentTest')<cr>
    nnoremap          <leader>lbb :call RunLastConjureCommand()<cr>

    nnoremap <buffer> <leader>lbc :exe "ConjureEval (nextjournal.clerk/show! \"" . expand("%:p") . "\")"<cr>

    nnoremap <leader>lo        :ConjureEval<space>
    nnoremap <leader>lev       :exe "ConjureEval " . @+ <cr> " contents from clipboard
    nnoremap <leader>lm        :ConjureEvalMarkedForm<CR>
    " TODO: eval root without `(comment `

    nnoremap <leader>l<c-c>    :ConjureCljInterrupt<CR>
    nnoremap <leader>lr        :ConjureCljRefreshChanged<CR>
    nnoremap <leader>lR        :ConjureCljRefreshAll<CR>
    nnoremap <leader>l<f5>     :ConjureCljRefreshAll<CR>

    nnoremap <leader>llw       :ConjureLogsToggleWrap<CR>
    nnoremap <leader>llG       :ConjureLogsScrollToBottom<CR>
    nnoremap <leader>llb       :ConjureLogsFindBeginningOfTestOutput<cr>
    nnoremap <leader>llf       :ConjureLogsFindErrorOrFailureForward<cr>
    nnoremap <leader>llF       :ConjureLogsFindErrorOrFailureBackward<cr>

    " ignore typos
    nnoremap <leader>l <nop>
endfunction

augroup conjure_output
    au!
    au BufWinEnter conjure-log-* call MatchConjureStuff()
augroup END

" highlight stuff in logs/output/stacktraces
command! MatchConjureStuff :call MatchConjureStuff() " highlight/match stuff (in Conjure output window)
function! MatchConjureStuff()
    highlight link ConjureInterestingStacktracePath DiagnosticFloatingInfo
    highlight link ConjureTestString DiagnosticFloatingWarn
    highlight link ConjureFailureOrError ErrorMsg
    highlight link ConjureExpected DiagnosticOk
    highlight link ConjureActual DiagnosticError
    call matchadd('ConjureInterestingStacktracePath', 'ci_fuzz\.backend')
    call matchadd('ConjureTestString', '\(_test\|test_\)')
    call matchadd('ConjureFailureOrError', '\(FAIL\|ERROR\)')
    call matchadd('ConjureExpected', 'expected: ')
    call matchadd('ConjureActual', 'actual: ')
endfunction

function! RunConjureCommand(cmd)
    normal! mY
    let g:last_conjure_command = a:cmd
    ConjureLogsScrollToBottom
    execute ":" . g:last_conjure_command
endfunction

function! RunLastConjureCommand()
    if !exists('g:last_conjure_command')
        echoerr "No last command found!"
    else
        normal! mZ
        normal! `Y
        ConjureLogsScrollToBottom
        execute ":" . g:last_conjure_command
        normal! `Z
    endif
endfunction

" Execute a command in the Conjure log window
command! -nargs=1 ConjureLogsExecute :call ConjureLogsExecute(<f-args>)
function! ConjureLogsExecute(cmd)
    let l:winid = win_getid()
    let l:conjure_log_buffer = GetBufferByPattern('conjure-log', 'list')[0]
    let l:conjure_log_window = bufwinnr(l:conjure_log_buffer)
    execute conjure_log_window . "windo " . a:cmd
    call win_gotoid(l:winid)
    " echo "Executed in log window: " . a:cmd
endfunction

" In the window with the conjure log buffer, scroll to the bottom (so that automatic tailing is enabled)
command! ConjureLogsScrollToBottom :ConjureLogsExecute normal G

" find/jump easily in log buffer
command! ConjureLogsFindBeginningOfTestOutput   ConjureLogsExecute normal! ?\(run-current-test\|run-ns-tests\)zt
command! ConjureLogsFindErrorOrFailureForward   ConjureLogsExecute normal! /\(FAIL\|ERROR\)zt
command! ConjureLogsFindErrorOrFailureBackward  ConjureLogsExecute normal! ?\(FAIL\|ERROR\)zt


" Vim-sexp brings the Vim philosophy of precision editing to S-expressions (as used in Lisps).
" It is less intrusive than the paredit plugin.
Plug 'guns/vim-sexp'

" Tpopes remaps for vim-sexp
" (I like some of them, but not all and do have the problem described below, so I steal some mapping manually)
" Plug 'tpope/vim-sexp-mappings-for-regular-people'

" Disable mapping hooks
" (because unmapping by adding empty string to the s:sexp_mappings dict as described in the docs doesn't work)
let g:sexp_filetypes = ''

let s:sexp_mappings = {
            \ 'sexp_round_head_wrap_element':   '',
            \ 'sexp_round_tail_wrap_element':   '',
            \ 'sexp_swap_list_backward':        'sk',
            \ 'sexp_swap_list_forward':         'sj',
            \ 'sexp_swap_element_backward':     'sh',
            \ 'sexp_swap_element_forward':      'sl',
            \ }

command! ReloadSexpMappings :call s:vim_sexp_mappings()

" Explicit mappings {{{
function! s:vim_sexp_mappings()
    xmap <silent><buffer> af              <Plug>(sexp_outer_list)
    omap <silent><buffer> af              <Plug>(sexp_outer_list)
    xmap <silent><buffer> if              <Plug>(sexp_inner_list)
    omap <silent><buffer> if              <Plug>(sexp_inner_list)
    xmap <silent><buffer> aF              <Plug>(sexp_outer_top_list)
    omap <silent><buffer> aF              <Plug>(sexp_outer_top_list)
    xmap <silent><buffer> iF              <Plug>(sexp_inner_top_list)
    omap <silent><buffer> iF              <Plug>(sexp_inner_top_list)
    xmap <silent><buffer> as              <Plug>(sexp_outer_string)
    omap <silent><buffer> as              <Plug>(sexp_outer_string)
    xmap <silent><buffer> is              <Plug>(sexp_inner_string)
    omap <silent><buffer> is              <Plug>(sexp_inner_string)
    xmap <silent><buffer> ae              <Plug>(sexp_outer_element)
    omap <silent><buffer> ae              <Plug>(sexp_outer_element)
    xmap <silent><buffer> ie              <Plug>(sexp_inner_element)
    omap <silent><buffer> ie              <Plug>(sexp_inner_element)
    nmap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
    xmap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
    omap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
    nmap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
    xmap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
    omap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
    nmap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
    xmap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
    omap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
    nmap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
    xmap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
    omap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
    nmap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
    xmap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
    omap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
    nmap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
    xmap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
    omap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
    nmap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
    xmap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
    omap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
    nmap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
    xmap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
    omap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
    nmap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
    xmap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
    omap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
    nmap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
    xmap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
    omap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
    nmap <silent><buffer> ==              <Plug>(sexp_indent)
    nmap <silent><buffer> =-              <Plug>(sexp_indent_top)
    nmap <silent><buffer> <LocalLeader>i  <Plug>(sexp_round_head_wrap_list)
    xmap <silent><buffer> <LocalLeader>i  <Plug>(sexp_round_head_wrap_list)
    nmap <silent><buffer> <LocalLeader>I  <Plug>(sexp_round_tail_wrap_list)
    xmap <silent><buffer> <LocalLeader>I  <Plug>(sexp_round_tail_wrap_list)
    nmap <silent><buffer> <LocalLeader>[  <Plug>(sexp_square_head_wrap_list)
    xmap <silent><buffer> <LocalLeader>[  <Plug>(sexp_square_head_wrap_list)
    nmap <silent><buffer> <LocalLeader>]  <Plug>(sexp_square_tail_wrap_list)
    xmap <silent><buffer> <LocalLeader>]  <Plug>(sexp_square_tail_wrap_list)
    nmap <silent><buffer> <LocalLeader>{  <Plug>(sexp_curly_head_wrap_list)
    xmap <silent><buffer> <LocalLeader>{  <Plug>(sexp_curly_head_wrap_list)
    nmap <silent><buffer> <LocalLeader>}  <Plug>(sexp_curly_tail_wrap_list)
    xmap <silent><buffer> <LocalLeader>}  <Plug>(sexp_curly_tail_wrap_list)
    " nmap <silent><buffer> <LocalLeader>w  <Plug>(sexp_round_head_wrap_element)
    " xmap <silent><buffer> <LocalLeader>w  <Plug>(sexp_round_head_wrap_element)
    " nmap <silent><buffer> <LocalLeader>W  <Plug>(sexp_round_tail_wrap_element)
    " xmap <silent><buffer> <LocalLeader>W  <Plug>(sexp_round_tail_wrap_element)
    nmap <silent><buffer> <LocalLeader>e[ <Plug>(sexp_square_head_wrap_element)
    xmap <silent><buffer> <LocalLeader>e[ <Plug>(sexp_square_head_wrap_element)
    nmap <silent><buffer> <LocalLeader>e] <Plug>(sexp_square_tail_wrap_element)
    xmap <silent><buffer> <LocalLeader>e] <Plug>(sexp_square_tail_wrap_element)
    nmap <silent><buffer> <LocalLeader>e{ <Plug>(sexp_curly_head_wrap_element)
    xmap <silent><buffer> <LocalLeader>e{ <Plug>(sexp_curly_head_wrap_element)
    nmap <silent><buffer> <LocalLeader>e} <Plug>(sexp_curly_tail_wrap_element)
    xmap <silent><buffer> <LocalLeader>e} <Plug>(sexp_curly_tail_wrap_element)
    nmap <silent><buffer> <I              <Plug>(sexp_insert_at_list_head)
    nmap <silent><buffer> >I              <Plug>(sexp_insert_at_list_tail)
    nmap <silent><buffer> <LocalLeader>@  <Plug>(sexp_splice_list)
    nmap <silent><buffer> <LocalLeader>o  <Plug>(sexp_raise_list)
    xmap <silent><buffer> <LocalLeader>o  <Plug>(sexp_raise_list)
    nmap <silent><buffer> <LocalLeader>O  <Plug>(sexp_raise_element)
    xmap <silent><buffer> <LocalLeader>O  <Plug>(sexp_raise_element)
    nmap <silent><buffer> <f              <Plug>(sexp_swap_list_backward)
    xmap <silent><buffer> <f              <Plug>(sexp_swap_list_backward)
    nmap <silent><buffer> >f              <Plug>(sexp_swap_list_forward)
    xmap <silent><buffer> >f              <Plug>(sexp_swap_list_forward)
    nmap <silent><buffer> <e              <Plug>(sexp_swap_element_backward)
    xmap <silent><buffer> <e              <Plug>(sexp_swap_element_backward)
    nmap <silent><buffer> >e              <Plug>(sexp_swap_element_forward)
    xmap <silent><buffer> >e              <Plug>(sexp_swap_element_forward)

    " "slurp"
    nmap <silent><buffer> <C-s><C-s>      <Plug>(sexp_capture_next_element)
    xmap <silent><buffer> <C-s><C-s>      <Plug>(sexp_capture_next_element)
    imap <silent><buffer> <C-s><C-s> <c-o><Plug>(sexp_capture_next_element)
    nmap <silent><buffer> <C-s>)          <Plug>(sexp_capture_next_element)
    xmap <silent><buffer> <C-s>)          <Plug>(sexp_capture_next_element)
    imap <silent><buffer> <C-s>)     <c-o><Plug>(sexp_capture_next_element)
    nmap <silent><buffer> <C-s>(          <Plug>(sexp_capture_prev_element)
    xmap <silent><buffer> <C-s>(          <Plug>(sexp_capture_prev_element)
    imap <silent><buffer> <C-s>(     <c-o><Plug>(sexp_capture_prev_element)
    " "barf"
    nmap <silent><buffer> <C-s>{          <Plug>(sexp_emit_head_element)
    xmap <silent><buffer> <C-s>{          <Plug>(sexp_emit_head_element)
    imap <silent><buffer> <C-s>{     <c-o><Plug>(sexp_emit_head_element)
    nmap <silent><buffer> <C-s>}          <Plug>(sexp_emit_tail_element)
    xmap <silent><buffer> <C-s>}          <Plug>(sexp_emit_tail_element)
    imap <silent><buffer> <C-s>}     <c-o><Plug>(sexp_emit_tail_element)

    imap <silent><buffer> <BS>            <Plug>(sexp_insert_backspace)
    imap <silent><buffer> "               <Plug>(sexp_insert_double_quote)
    imap <silent><buffer> (               <Plug>(sexp_insert_opening_round)
    " imap <silent><buffer> )               <Plug>(sexp_insert_closing_round)
    imap <silent><buffer> [               <Plug>(sexp_insert_opening_square)
    " imap <silent><buffer> ]               <Plug>(sexp_insert_closing_square)
    imap <silent><buffer> {               <Plug>(sexp_insert_opening_curly)
    " imap <silent><buffer> }               <Plug>(sexp_insert_closing_curly)
endfunction
" }}}

augroup VIM_SEXP_MAPPING
    autocmd!
    autocmd FileType clojure,scheme,lisp,timl call s:vim_sexp_mappings()
augroup END



" }}}

" Language: CSV {{{

Plug 'chrisbra/csv.vim'

augroup csv_on_read
    au!
    au FileType csv call SetupCSV()
augroup END

function! SetupCSV()
    nnoremap <buffer> <silent> <leader>yy :CSVHiColumn <cr>              " highlight current column
    nnoremap <buffer> <silent> <leader>yY :CSVHiColumn! <cr>             " undo highlight current column
    nnoremap <buffer> <silent> <leader>yh :CSVHeader <cr>                " add window with header row
    nnoremap <buffer> <silent> <leader>yH :CSVHeader! <cr>               " close window with header row
    nnoremap <buffer> <silent> <leader>af :%CSVArrangeColumn <cr>        " align columns by adding spaces
    nnoremap <buffer> <silent> <leader>AF :%CSVArrangeColumn! <cr>       " align columns by adding spaces recalculating widths
    nnoremap <buffer> <silent> <leader>au :%CSVUnArrangeColumn <cr>      " undo aligning columns by removing spaces
endfunction
command! SetupCSV :call SetupCSV() " add mappings for CSV handling


" }}}


" Language: fish {{{

Plug 'dag/vim-fish'


" }}}
" Language: java {{{

augroup java_on_read
    au!
    au FileType java call SetupMaven()
augroup END

function! SetupMaven()
    nnoremap <buffer> <leader>bI  :call RunCommand("mvn install")<cr>
    nnoremap <buffer> <leader>bi  :call RunCommand("mvn install -DskipTests")<cr>
    nnoremap <buffer> <leader>bv  :call RunCommand("mvn validate")<cr>
    nnoremap <buffer> <leader>bc  :call RunCommand("mvn compile")<cr>
    nnoremap <buffer> <leader>bp  :call RunCommand("mvn package")<cr>
    nnoremap <buffer> <leader>btt :call RunCommand("mvn test")<cr>
    nnoremap <buffer> <leader>bC  :call RunCommand("mvn clean")<cr>
endfunction
command! SetupMaven :call SetupMaven()

" }}}
" Language: javascript {{{

Plug 'ianks/vim-tsx'

" Plug 'Quramy/tsuquyomi'

augroup javascript_on_read
    au!
    au FileType javascript call SetupYarn()
    au FileType javascript call SetupTsuquyomi()
augroup END

augroup typescript_on_read
    au!
    " au FileType typescript call SetupYarn()
    au FileType typescript call SetupTsuquyomi()
    au FileType typescript.tsx call SetupYarn()
    au FileType typescript.tsx call SetupTsuquyomi()
    nnoremap <buffer> <leader>AF  :call RunCommand("prettier --parser typescript --write **.tsx")<cr>
    " nnoremap <buffer> <leader>AF  :call RunCommand("yarn format")<cr>
augroup END

function! SetupNpm()
    nnoremap <buffer> <leader>bi  :call RunCommand("npm install")<cr>
    nnoremap <buffer> <leader>br  :call RunCommand("npm start")<cr>
    nnoremap <buffer> <leader>btt :call RunCommand("npm test")<cr>
    nnoremap <buffer> <leader>btu :call RunCommand("npm test-unit")<cr>
    nnoremap <buffer> <leader>bti :call RunCommand("npm test-int")<cr>
endfunction
command! SetupNpm :call SetupNpm() " add mappings for development with NodeJS

function! SetupYarn()
    " yarn commands are project specific and defined in `package.json`.
    nnoremap <buffer> <leader>bi  :call RunCommand("yarn install")<cr>
    nnoremap <buffer> <leader>bd  :call RunCommand("yarn build")<cr>
    nnoremap <buffer> <leader>br  :call RunCommand("yarn dev")<cr>
    nnoremap <buffer> <leader>bll :call RunCommand("yarn lint")<cr>
    nnoremap <buffer> <leader>blf :call RunCommand("yarn lint:fix")<cr>
    nnoremap <buffer> <leader>bcf :call RunCommand("yarn run format:check")<cr>
    nnoremap <buffer> <leader>AF  :call RunCommand("yarn run format")<cr>
    nnoremap <buffer> <leader>btt :call RunCommand("yarn test")<cr>
    nnoremap <buffer> <leader>btu :call RunCommand("yarn test:unit")<cr>
    nnoremap <buffer> <leader>bto :call RunCommand("yarn test " . expand("%"))<cr>
    nnoremap <buffer> <leader>btw :call RunCommand("yarn test:watch " . expand("%"))<cr>
    nnoremap <buffer> <leader>btO :call RunCommand("yarn test:e2e --spec " . expand("%"))<cr>
    nnoremap <buffer> <leader>bti :call RunCommand("yarn test:e2e")<cr>
endfunction
command! SetupYarn :call SetupYarn() " add mappings for development with yarn

function! SetupTsuquyomi()
    nmap <leader>rf <Plug>(TsuquyomiRenameSymbolC)
    nmap <leader>rF <Plug>(TsuquyomiRenameSymbol)
    nmap <leader>iq : <C-u>echo tsuquyomi#hint()<CR>
endfunction
command! SetupTsuquyomi :call SetupTsuquyomi() " add mappings for development with Tsuquyomi



" }}}
" Language: LaTeX {{{

" TODO: use neovim builtin X window and window manager support to open pdf within vim
" https://www.reddit.com/r/neovim/s/gmyYf84Ydq
" https://github.com/altermo/nwm

Plug 'lervag/vimtex'

" let g:tex_flavor = 'latex'
let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'
let g:vimtex_quickfix_mode=0
let g:vimtex_syntax_conceal_disable=1

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

augroup latex_on_read
    au!
    au FileType latex SetupLatex
    au FileType tex   SetupLatex
augroup END

" Fix main file detection ("VimTeX: Compilation error due to failed mainfile detection!")
" See :help vimtex-multi-file
" FIXME  This is a stupid workaround and does not work for multi-file projects.
augroup VimTeX
    autocmd!
    autocmd BufReadPre *.tex let b:vimtex_main = expand('%')
augroup END

command! SetupLatex :call SetupLatex() " add mappings for LaTeX
function! SetupLatex()
    setlocal wrap
    nnoremap <buffer> <leader>bb :VimtexCompile<cr>
    nnoremap <buffer> <leader>br :VimtexCompileSS<cr>
    " fallback build if there's a shitty error again
    nnoremap <buffer> <leader>bp :call RunCommandInBuildShell('pdflatex ' . ExpandPrependThisDir('%'))<cr>
    " open PDF with zathura
    nnoremap <buffer> <leader>bz :execute 'Dispatch zathura ' . expand('%:r') . '.pdf'<cr>
    " print PDF
    nnoremap <buffer> <leader>bP :execute 'Dispatch lpr ' . expand('%:r') . '.pdf'<cr>
endfunction


" }}}
" Language: Markdown {{{

if has('nvim')

    Plug 'MeanderingProgrammer/render-markdown.nvim'

    " commands:
    " :RenderMarkdown enable
    " :RenderMarkdown disable
    " :RenderMarkdown toggle
    nmap <leader>syM :RenderMarkdown toggle<cr>

endif

" " depends on 'godlygeek/tabular'
Plug 'preservim/vim-markdown'

" Remember :Toc command

let g:vim_markdown_folding_style_pythonic = 1
let g:vim_markdown_folding_level = 0 " does not do what I want
let g:vim_markdown_conceal = 0
let g:vim_markdown_strikethrough = 1


" (partially stolen from https://codeinthehole.com/tips/writing-markdown-in-vim/)
"
" Indentation for new lists. We don't insert bullets as it doesn't play
" nicely with `gq` formatting. It relies on a hack of treating bullets
" as comment characters.
" See https://github.com/plasticboy/vim-markdown/issues/232
let g:vim_markdown_new_list_item_indent = 0
let g:vim_markdown_auto_insert_bullets = 0

" Filetype names and aliases for fenced code blocks.
let g:vim_markdown_fenced_languages = ['php', 'py=python', 'js=javascript', 'bash=sh', 'viml=vim']



Plug 'shime/vim-livedown'
" requires `npm install -g livedown`

let g:livedown_autorun = 0

" let g:livedown_browser = 'surf'
let g:livedown_browser = 'qutebrowser'


augroup markdown_on_read
    au!
    au FileType markdown normal zr
    au FileType markdown call SetupMarkdown()
augroup END
function! SetupMarkdown()
    nnoremap <buffer> <leader>br :LivedownPreview<cr>
    nnoremap <buffer> <leader>bx :LivedownKill<cr>
endfunction
command! SetupMarkdown :call SetupMarkdown() " add mappings for development with Markdown


" }}}
" Language: PHP {{{

augroup php_on_read
    au!
    au FileType php call SetupPHP()
augroup END
function! SetupPHP()
    nnoremap <buffer> <leader>bi  :call RunCommand("composer install")<cr>
    nnoremap <buffer> <leader>bu  :call RunCommand("composer update")<cr>
    nnoremap <buffer> <leader>btt :call RunCommand("composer test")<cr>
    nnoremap <buffer> <leader>btu :call RunCommand("composer test")<cr>
    nnoremap <buffer> <leader>bto :call RunCommand("composer test " . expand('%p'))<cr>
endfunction


" }}}
" Language: python {{{

augroup python_on_read
    au!
    au FileType python call SetupPython()
augroup END
function! SetupPython()
    nnoremap <buffer> <leader>br  :call RunCommand("python " . expand('%'))<cr>
    nnoremap <buffer> <leader>b2  :call RunCommand("python2 " . expand('%'))<cr>
    nnoremap <buffer> <leader>b3  :call RunCommand("python3 " . expand('%'))<cr>
endfunction


" }}}
" Language: R {{{

if v:version > 704 || v:version == 704 && has("patch1829")
    Plug 'jalvesaq/Nvim-R'
    " use with tmux
    let R_in_buffer = 0
    let R_applescript = 0
    let R_tmux_split = 1
    let R_vsplit = 1
    let R_rconsole_width = 80
    " custom keybindings
    let R_user_maps_only = 1
    augroup NvimR
        au!
        au FileType r nmap <c-r>s           <plug>RStart
        au FileType r nmap <c-r>q           <plug>RClose
        au FileType r nmap <c-r><c-l>       <plug>RClearConsole
        au FileType r nmap <leader><enter>  <plug>RSendFile
        au FileType r nmap <enter>          <plug>RSendLine
        au FileType r xmap <enter>          <plug>RSendSelection
    augroup END
endif


" }}}
" Language: rust {{{

augroup rust_on_read
    au!
    au FileType rust call SetupRust()
augroup END
function! SetupRust()
    let g:build_shell = 'bash'
    nnoremap <buffer> <leader>bd  :call RunCommandInBuildShell("cargo build")<cr>
    nnoremap <buffer> <leader>bD  :call RunCommandInBuildShell("cargo build --release")<cr>
    nnoremap <buffer> <leader>br  :call RunCommandInBuildShell("cargo run")<cr>
    nnoremap <buffer> <leader>btc :call RunCommandInBuildShell("cargo check")<cr>
endfunction
command! SetupRust :call SetupRust() " add mappings for development with Rust


" }}}
" Language: Scala {{{
"
Plug 'derekwyatt/vim-scala'
Plug 'derekwyatt/vim-sbt'


if has('nvim')
    Plug 'scalameta/nvim-metals'
endif

" ----- Scala legacy below

" Plug 'ervandew/eclim'

" start eclipse
noremap <leader>aea :Start! /usr/lib/eclipse/eclimd<cr>
" test connection to eclipse
noremap <leader>aep :PingEclim<cr>
noremap <leader>aev :EclimValidate<cr>
" shutdown eclipse
noremap <leader>aeo :ShutdownEclim<cr>

" automated imports
noremap <leader>aei :ScalaImport<cr>

" goto definition
noremap <leader>ae<return> :ScalaSearch<cr>



" Plug 'mdreves/vim-scaladoc' " uses python 2 which is ridiculous
" nnoremap <leader>sd :call scaladoc#Search(expand("<cword>"))<cr>

" Plug 'ensime/ensime-sbt', { 'branch': '2.0', 'for': 'scala' }
" Plug 'ensime/ensime-server', { 'branch': '2.0', 'for': 'scala' }
" Plug 'ensime/ensime-vim', { 'for': 'scala' }
" augroup map_scala
    " au!
    " au FileType scala
                " \ nnoremap <leader>9d :EnDeclaration<cr> |
                " \ nnoremap <leader>9D :EnDeclarationSplit v<cr> |
                " \ nnoremap <leader>9x :EnDocBrowse<cr> |
                " \ nnoremap <leader>9t :EnType<cr> |
                " \ " nnoremap <leader>9t :EnInspectType<cr> |
                " \ nnoremap <leader>9T :EnTypeCheck<cr> |
                " \ nnoremap <leader>9/ :EnSearch<space> |
                " \ nnoremap <leader>9r :EnRename<cr> |
                " \ nnoremap <leader>9i :EnOrganizeImports<cr> |
                " \ nnoremap <leader>9I :EnSugestImport<cr> |
                " \ nnoremap <leader>9 <nop>
" augroup END


" Scala Metals {{{

" Plug 'scalameta/coc-metals', {'do': 'yarn install --frozen-lockfile'}
" Plug 'ckipp01/coc-metals'

" The above lines (installing metals via vim plugin manager) do not work for me.
" So instead I need to do `:CocInstall coc-metals`
" (one should only use exactly one of those)



" }}}


" scala and ctags:
" https://advancedweb.hu/2017/01/10/vim-scala-ag-ctags/
" plugin that also creates ctags for libaries (can be slow and huge files):
" Plug 'ceedubs/sbt-ctags'

" show sbt errors in the quickfix window
" Plug 'dscleaver/sbt-quickfix'
" (does not work and is not necessary: https://gist.github.com/nkpart/5945278)

" :!sbt -Dsbt.log.noformat=true compile 2>&1 >/tmp/sbt.out
" let g:cfile = system('ag -l "\[(error|warn)\]" target/streams/ | head -n 1')
" let g:cfile_escaped = substitute(g:cfile, "\\$", "\\\\$", "g")

augroup scala_on_read
    au!
    au FileType scala call SetupScala()
augroup END

augroup sbt_on_read
    au!
    au FileType sbt.scala call SetupScala()
augroup END

function! IsScalaProject()
    return filereadable("build.sbt")
endfunction

command! SetupScala :call SetupScala() " add settings and mappings for development with Scala
function! SetupScala()
    let l:sbt_version = system('grep -E "sbt\.version" project/build.properties | sed -E "s/.*=(.*)/\1/"')
    " sbt shows column in compiler errors since version 1.0.0 so there are two " cases for errorformat:
    if l:sbt_version
        set errorformat=
                    \%E\ %#[error]\ %f:%l:%c:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:%c:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    else
        set errorformat=
                    \%E\ %#[error]\ %f:%l:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    endif
    " the lines above work for compiler errors
    " the lines below are for testing errors but do not work yet
    " (for example because the file path is not absolute)
    " (also, I'm a noob with the efm matching syntax)
    " TODO: fix
                " \%E\ \%#[info]%.%#was\ not\ equal\ to%.%#(%f:%l),%Z,
                " \%E\ \%#[info]\ %.%#\ was\ not\ equal\ to\ %.%#\ (%f:%l),%Z,
                " \%E\ %#[info]\ %.%#\ ***\ FAILED\ ***,%C\ %#[info]\ %m\ (%f:%l)%Z,
    match ErrorMsg '\*\*\* FAILED \*\*\*'

    " " TODO delete supershell escape sequences instead of supressing them
    " let g:build_shell = 'sbt --color=true --supershell=false'
    " let g:prompt_regex = '^sbt:.*>\|^>\.\.\.\.'
    "
    let g:build_shell = 'scala'
    let g:prompt_regex = '^scala>'

    highlight link SbtPrompt LineNr
    augroup sbt_prompt_highlighting
        au!
        au VimEnter,WinEnter * execute 'match SbtPrompt /' . g:prompt_regex . '/'
    augroup END

    nnoremap <buffer> <leader>AF     :Terminal scalafmt<cr>

    nnoremap <buffer> <leader>bd     :call RunCommandInBuildShell("compile")<cr>
    nnoremap <buffer> <leader>br     :call RunCommandInBuildShell("run")<cr>
    nnoremap <buffer> <leader>btd    :call RunCommandInBuildShell("Test / compile; IntegrationTest / compile")<cr>
    nnoremap <buffer> <leader>btt    :call RunCommandInBuildShell("test; IntegrationTest / test")<cr>
    nnoremap <buffer> <leader>btu    :call RunCommandInBuildShell("test")<cr>
    nnoremap <buffer> <leader>bti    :call RunCommandInBuildShell("IntegrationTest / test")<cr>
    nnoremap <buffer> <leader>bto    :call RunCommandInBuildShell(CalculateSbtTestOnlyCommand())<cr>
    nnoremap <buffer> <leader>btq    :call RunCommandInBuildShell("testQuick")<cr>
    nnoremap <buffer> <leader>bg     :call RunCommandInBuildShell("scapegoat")<cr>
    nnoremap <buffer> <leader>bx     :call RunCommandInBuildShell("clean")<cr>
    nnoremap <buffer> <leader>bR     :call RunCommandInBuildShell("console")<cr>
    nnoremap <buffer> <leader>b<f5>  :call RunCommandInBuildShell("reload")<cr>

endfunction

function! CalculateSbtTestOnlyCommand()
    let l:lines_that_match_package = GetMatches('^package.*', 1, line('$'))
    let l:lines_that_match_class   = GetMatches('^\(class\|object\).*', 1, line('$'))
    if len(l:lines_that_match_package) == 0 || len(l:lines_that_match_class) == 0
        throw "Could not find test class name."
    endif
    let l:package  = substitute(l:lines_that_match_package[0], '^package\s\+\(\w\+\)', '\1', '')
    let l:class    = substitute(l:lines_that_match_class[0], '^\(class\|object\)\s\+\(\w\+\).*', '\2', '')
    let l:itPrefix = match(@%, '.*/it/.*') == -1 ? '' : 'IntegrationTest / '
    return l:itPrefix . "testOnly " . l:package . "." . l:class
endfunction

function! IsSbtRunning()
    " This only checks if SBT is running globally, not in the adjacent tmux pane # TODO: improve
    " the space before 'java' is important (to match pure sbt but ignore IntelliJ's sbt)
    call system('ps -ef | grep -v grep | grep " java.*sbt-launch.jar"')
    " call system('ps -ef | grep -v grep | grep sbt-launch.jar')
    return !v:shell_error
endfunction

" augroup scala_on_write
    " au!
    " au BufWritePost *.scala Dispatch! sbt -Dsbt.log.noformat=true parse
" augroup END


" TODO: find fzf scala docs

" }}}
" Language: Smarty {{{

Plug 'vim-scripts/smarty-syntax'

augroup smarty_on_read
    au!
    au BufNewFile,BufReadPost *.tpl set syntax=smarty
augroup END


" }}}
" Language: SQL {{{

" See :help ft_sql.txt

" Set custom dialect for files with '.sql' extension
let g:sql_type_default = 'pgsql'
" or manually set with:
" :SQLSetType pgsql.vim


augroup is_keyword_sql
    autocmd!
    autocmd FileType sql setlocal iskeyword+=-
augroup END

augroup sql_on_read
    au!
    au FileType sql if !IsScalaProject() | call SetupSQLShellMappings() | endif
    au FileType sql if !IsScalaProject() | call SetupSQLDadBod() | endif
    " TODO: set to hugsql if WHAT CONDITION ???
augroup END

command! SetupSQL :call SetupSQLDadBod()<bar> call SetupSQLShellMappings() " add mappings for development with SQL

function! SetupSQLShellMappings()
    nnoremap <buffer> <m-enter>     yip:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
    nnoremap <buffer> <leader>bp    yip:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
    nnoremap <buffer> <leader>br    :call RunSQLFileInShell()<cr>
endfunction
command! SetupSQLShellMappings :call SetupSQLShellMappings() " add mappings for development with SQL (Vimux)

function! RunSQLFileInShell()
    " Detect SQL dialect by running client process and assume it is running in a vim-managed terminal. Most of the time, that's good enough for me.
    call system('pgrep psql')
    let l:psql_running = !v:shell_error
    call system('pgrep mysql')
    let l:mysql_running = !v:shell_error
    if l:psql_running
        call RunCommand("\\i " . expand('%:p'))
    elseif l:mysql_running
        call RunCommand("\\. " . expand('%:p'))
    else
        throw "Could not detect any running SQL shell. Please launch one."
    endif
endfunction
command! RunSQLFileInShell :call RunSQLFileInShell()


" more advanced syntax highlighting for PostgreSQL dialect and auto-completion
Plug 'lifepillar/pgsql.vim'


Plug 'tpope/vim-dadbod'

" For database connection, see ':help dadbod-variables'

function! SetupSQLDadBod()

    " sql query text object (aq)
    vnoremap <buffer> aq <esc>:call search(";", "cWz")<cr>:call search(";\\<bar>\\%^", "bsWz")<cr>:call search("\\v\\c^(select<bar>with<bar>insert<bar>update<bar>delete<bar>create)\>", "Wz")<cr>vg`'
    omap     <buffer> aq :normal vaq<cr>

    nnoremap <buffer>    <leader>bdo :DB<space>
    nnoremap <buffer>    <leader>bda :%DB<cr>
    xmap <expr> <leader>bd db#op_exec()
    "nmap        <leader>bdq vaq<leader>bd
    nmap        <leader>bdq vap<leader>bd

endfunction
command! SetupSQLDadBod :call SetupSQLDadBod() " add mappings for development with SQL (DadBod)



" Plug 'cosminadrianpopescu/vim-sql-workbench'
" (This plugin sound promising, but is shit)

" let g:sw_config_dir = '/home/flipsi/.sqlworkbench'
" let g:sw_exe = '/opt/SQLWorkbench/sqlwbconsole.sh'
" " let g:sw_cache = ''

" augroup sql_on_read_workbench
"     au!
"     au FileType sql call SetupSQLWorkbench()
" augroup END
" function! SetupSQLWorkbench()
"     nnoremap <buffer> <leader>br   <nop>
"     nnoremap <buffer> <leader>brc  :SWSqlBufferConnect<cr>
"     nnoremap <buffer> <leader>bre  :SWDbExplorer<space>
"     nnoremap <buffer> <leader>brr  :SWSqlExecuteCurrent<cr>
"     vnoremap <buffer> <leader>brr  :SWSqlExecuteSelected<cr>
"     nnoremap <buffer> <leader>bra  :SWSqlExecuteAll<cr>
" endfunction


" }}}
" Language: (Salesforce) Force/Apex {{{

Plug 'neowit/vim-force.com'

let g:apex_backup_folder = '/tmp/force.com/backup' " project backup folder
let g:apex_temp_folder = '/tmp/force.com/temp' " temporary folder
let g:apex_properties_folder = '/tmp/force.com/properties' " login/pass/token credentials

" Download from https://github.com/neowit/tooling-force.com/releases
let g:apex_tooling_force_dot_com_path = expand('~/.local/share/force.com/tooling-force.com-0.4.7.0.jar') " full path to tooling.jar


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plug 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <leader>uT :GundoToggle<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    call plug#end()

    " THE FOLLOWING MUST BE EXECUTED AFTER vim-plugin FINISHED:

    " call camelcasemotion#CreateMotionMappings(',')

    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping)
    call yankstack#setup()

endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" OPTIONS {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=3000

" always assume modern terminal
set ttyfast
" don't draw everything (e.g. when playing macros)
set ttyfast
set lazyredraw

" allow mouse usage for bad days
if has('mouse')
    set mouse=a
endif

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8
" <eol> line ending philosophies to try
" set fileformats=unix,dos,mac

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread


" don't normally use autosave
let g:autosave = 0 " enable via autocommand below or on demand with AutoSaveEnable

" but automatically save files if in git repository
augroup enable_autosave_in_git_repos
    au!
    au VimEnter * if IsGitRepository(getcwd())
    au VimEnter *   AutoSaveEnable
    au VimEnter * endif
augroup END

" actual autosave autocommand
augroup autosave
    au!
    " au BufLeave,FocusLost * if g:autosave | call SaveIfWritable() | endif
    au InsertLeave,CursorHold * if g:autosave | call SaveIfWritable() | endif
augroup END

function! SaveIfWritable()
    if filewritable(expand('%')) == 1 || ! findfile(expand('%:t'), expand('%:h'))
        silent! update
    endif
endfunction



" automatically change working directory to current file
" set autochdir

" command history size
set history=9999

" do not create swap files (they annoy me more than they help)
set noswapfile

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" meta files (like tagfiles)
set tags+=.tags

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable
let g:synmaxcol=500
augroup synmaxcol_per_filetype
    au!
    au BufEnter conjur*.cljc set synmaxcol=2500
augroup END
exe 'set synmaxcol=' . g:synmaxcol

" highlight matching bracket when typing
" set showmatch
" set matchtime=4

" do not wrap lines until I say so
set nowrap

" highlight conflict markers
" (TODO: let 'rhysd/conflict-marker.vim' plugin do that ?)
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = !exists("g:neovide")
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter *
                \ set nocursorline nocursorcolumn
    au WinEnter,InsertLeave *
                \ if g:cursorposition
                \ | set cursorline cursorcolumn
                \ | endif
    au FocusLost   *
                \ set nocursorline nocursorcolumn
    au FocusGained *
                \ if g:cursorposition && mode() != 'i' && !IsTerminalBuffer()
                \ | set cursorline cursorcolumn
                \ | endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2
set noshowmode

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignorecase
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
set wildignore+=*.o,*.obj,*.pyc,*.class
set wildignore+=*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.odt,*.ods
set wildignore+=*.jpg,*.jpeg,*.png
set wildignore+=*.mp3,*.mp4,*.mpg,*.mpeg,*.flv,*.wav
set wildignore+=*.aux,*.bbl,*.blg,*.fdb_latexmk,*.fls,*.loe,*.lof,*.out,*.toc

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=5
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
set gdefault " DEPRECATED TODO: check my vimrc usages
set nohlsearch
set nowrapscan

" allow the cursor to move where there is no character
set virtualedit=block,insert,onemore


" characters to show in list mode
set listchars=nbsp:⦸
" set listchars+=eol:$
set listchars+=extends:❯
set listchars+=precedes:❮
set listchars+=tab:--
if v:version > 704 || v:version == 704 && has("patch711")
    set listchars+=space:·
    " set listchars+=trail:•
endif

" how it looks like if we wrap lines
if v:version > 704 || v:version == 704 && has("patch338")
    set breakindent
endif
set showbreak=↪

" how other stuff looks like
set fillchars+=vert:\ "
set fillchars+=fold:─

" use 4 spaces instead of tabs
" (otherwise handled by sleuth)
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" only use multiples of 'shiftwidth' when indenting
set shiftround

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" 1 space, not 2, when joining sentences
set nojoinspaces

" allow <bs> to delete everything
set backspace=indent,eol,start

" when formatting / wrapping text, indent 'correctly' in numbered lists
set formatoptions+=n

" when incrementing numbers with leading zeros, don't interpret them as octal
set nrformats-=octal

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright
" (don't) resize remaining windows after closing one (keep window layout)
set equalalways

" preview-window (e.g. used by vim-dadbod)
set previewheight=40



" }}}

" FILETYPE SPECIFIC SETTINGS {{{


augroup SET_FILETYPE
    au!
    au BufNewFile,BufReadPost *.conf        set ft=conf
    au BufNewFile,BufReadPost *.yaml.tpl    set ft=yaml
    au BufNewFile,BufReadPost *.dmn         set ft=xml
augroup END


augroup FILETYPE_SPECIFIC_SETTINGS_QUICKFIX
    autocmd!
    autocmd filetype qf setlocal norelativenumber
    autocmd filetype qf setlocal colorcolumn=
augroup END


augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit let b:local_autosave = 0
    autocmd filetype gitcommit let b:DeleteTrailingWhitespace_Action = 'delete'
    autocmd filetype gitcommit normal gg
    autocmd filetype gitcommit call InsertCommitMsgPrefix()
augroup END

command! InsertCommitMsgPrefix :call InsertCommitMsgPrefix()
function! InsertCommitMsgPrefix()
    " only insert prefix for new commits (not when amending etc.)
    if empty(getline('.'))
        let l:branch_name = GitCurrentBranchName()
        let l:affected_code_part = system('git diff --cached --name-only | head -n1 | cut -d "/" -f1 | tr -d "\n"')
        let l:ticket_number_pattern = '\v^.*/\zs\u+-\d+\ze[/-].*'
        let l:ticket_number = matchstr(l:branch_name, l:ticket_number_pattern)
        if l:ticket_number != ''
            let l:commit_msg_prefix = l:ticket_number . ' #comment '
        else
            let l:commit_msg_prefix = l:affected_code_part . ': '
        endif
        call setline(1, l:commit_msg_prefix)
        normal $l
    endif
endfunction


augroup FILETYPE_SPECIFIC_SETTINGS_JSON
    autocmd!
    autocmd! FileType json setlocal conceallevel=0 foldmethod=syntax foldlevel=999
    autocmd! FileType json syntax match Comment +\/\/.\+$+
augroup END


" default textwidth
augroup auto_textwidth
    autocmd!
    autocmd FileType clojure         set textwidth=100 | call SetColorColumn('on')
    autocmd FileType dockerfile      set textwidth=100 | call SetColorColumn('on')
    autocmd FileType gitcommit       set textwidth=50  | call SetColorColumn('on')
    autocmd FileType mail            set textwidth=0   | call SetColorColumn('off')
    autocmd FileType markdown        set textwidth=100 | call SetColorColumn('on')
    autocmd FileType php             set textwidth=120 | call SetColorColumn('on')
    autocmd FileType scala           set textwidth=120 | call SetColorColumn('on')
    autocmd FileType sh              set textwidth=100 | call SetColorColumn('on')
    autocmd FileType sql             set textwidth=80  | call SetColorColumn('on')
augroup END



" }}}

" COLORSCHEME {{{

" Enables 24-bit RGB color in the |TUI|
set termguicolors


let g:light_or_dark_theme = 'dark'

" TODO: use this in custom hugsql syntax file
function! SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunction

" TODO: use this in custom hugsql syntax file
function! SynGroup()
    let l:s = synID(line('.'), col('.'), 1)
    echo synIDattr(l:s, 'name') . ' -> ' . synIDattr(synIDtrans(l:s), 'name')
endfunction


function! FixHighlighting()

    " check with :verbose hi GROUP

    if g:light_or_dark_theme == 'dark'
        let g:indentLine_setColors = 1
        let g:indentLine_color_term = 237
        " let g:indentLine_bgcolor_term =
        let g:indentLine_color_gui = '#3C3836'
        " let g:indentLine_bgcolor_gui = '#32302F'
        " highlight Cursor                  cterm=NONE guibg=#32302F
        highlight CursorLine              ctermbg=236 guibg=#32302F cterm=NONE
        highlight CursorColumn            ctermbg=236 guibg=#32302F
        highlight ColorColumn             ctermbg=236 guibg=#32302F                         " text exceeds textwidth
        highlight DiffAdd                 ctermbg=234
        highlight DiffDelete              ctermbg=234
        highlight DiffChange              ctermbg=234
        highlight DiffText                ctermbg=233
        highlight ShowTrailingWhitespace  ctermbg=235
        highlight VertSplit               ctermfg=238
        highlight Folded                  ctermfg=238 ctermfg=248 guibg=#32302F
        highlight LineNr                  ctermbg=237 ctermfg=243 guibg=#262626
        highlight SignColumn              ctermbg=237 ctermfg=243 guibg=#262626
        highlight GitGutterAdd            ctermbg=237 ctermfg=107 guibg=#262626 guifg=#79740e
        highlight GitGutterChange         ctermbg=237 ctermfg=107 guibg=#262626 guifg=#427b58
        highlight GitGutterDelete         ctermbg=237 ctermfg=107 guibg=#262626 guifg=#af3a03
        highlight GitGutterChangeDelete   ctermbg=237 ctermfg=107 guibg=#262626 guifg=#427b58
        " highlight Conceal                 ctermbg=236
        " highlight Search                  ctermbg=237 ctermfg=white
        " highlight Error                   ctermbg=162
        highlight Todo                      ctermfg=132
        highlight Sneak                     ctermfg=72 ctermbg=234
        highlight EasyMotionTarget          ctermfg=72
        highlight EasyMotionTarget2First    ctermfg=72
        highlight EasyMotionTarget2Second   ctermfg=108
        highlight TelescopeSelection        ctermfg=214
        highlight ALEErrorSign              ctermfg=203
        highlight ALEWarningSign            ctermfg=227
        highlight ALEInfoSign               ctermfg=227
        highlight ALEVirtualTextError       ctermfg=243
        " highlight Pmenu                     ctermbg=206 " popup (autocompletion) menu normal item   " Note this may be overriden by CocFloating
        " highlight PmenuSel                  ctermbg=206 " popup (autocompletion) menu selected item
        " highlight PmenuSbar                 ctermbg=206 " popup (autocompletion) menu scrollbar background
        " highlight PmenuThumb                ctermbg=206 " popup (autocompletion) menu scrollbar
        " highlight CocMenuSel                ctermbg=205
        highlight NormalFloat               ctermbg=240 " TODO: FIX (doesn't work as expected)
        " highlight CocFloating               ctermbg=245
        " highlight CocFloatActive            ctermbg=245 ctermfg=220
        " highlight CocFloatSbar              ctermbg=249
        " highlight CocFloatThumb             ctermbg=253
        highlight CocHighlightText          ctermfg=71 ctermbg=237
        highlight CocUnusedHighlight        ctermfg=192 " makes contrast for unused defs acceptable again, but doesn't pick up said color. TODO: FIX
        " highlight CocWarningHighlight       ctermfg=213
    elseif g:light_or_dark_theme == 'light'
        let g:indentLine_setColors = 1
        let g:indentLine_color_term = 250
        highlight CursorLine   ctermbg=252
        highlight CursorColumn ctermbg=252
        highlight ColorColumn  ctermbg=250
        highlight ShowTrailingWhitespace ctermbg=250

    else
        echoerr "Unknown value for g:light_or_dark_theme (" . g:light_or_dark_theme . ")"
    endif

endfunction
command! FixHighlighting :call FixHighlighting() " Overwrite some highlight group definitions


highlight PokemonPikachu ctermfg=233 ctermbg=184
match PokemonPikachu /pikachu/


function! SetColorscheme()

    if s:MyMode == 'mastery'

        if g:light_or_dark_theme == 'dark'
            set background=dark

            " dark colorschemes that I like or once liked:
            " ----------------------------------------------
            " apprentice badwolf blackboard blacklight candycode dante desertEx
            " gruvbox gruvbox-material iceberg jellybeans luna-term meta5
            " materialbox molokai onedark pride seoul256 Tomorrow-Night up woju

            colorscheme gruvbox-material

            " dark airlinethemes that I like or once liked:
            " ----------------------------------------------
            " base16 base16_summerfruit base16_grayscale behelit distinguished
            " kalisi laederon lucius minimalist raven serene tomorrow ubaryd wombat
            " zenburn

            let g:airline_theme='base16_grayscale'

        elseif g:light_or_dark_theme == 'light'
            set background=light

            " light colorschemes that I like or once liked:
            " ----------------------------------------------
            " lucius peaksea seoul256-light Tomorrow-Night

            colorscheme seoul256-light

            " light airlinethemes that I like or once liked:
            " ----------------------------------------------
            " bubblegum lucius sol

            let g:airline_theme='lucius'

        else
            echoerr "Unknown value for g:light_or_dark_theme (" . g:light_or_dark_theme . ")"
        endif

        FixHighlighting

    else

        colorscheme desert " fallback colorscheme

        let g:cursorposition = 0
        set nocursorcolumn nocursorline
        highlight CursorLine   ctermbg=233
        highlight CursorColumn ctermbg=233
        highlight ColorColumn  ctermbg=233

    endif

endfunction

call SetColorscheme()


command! ToggleColorschemeDarkOrLight :call ToggleColorschemeDarkOrLight() " Set colorscheme etc. to dark or light
function! ToggleColorschemeDarkOrLight()
    if g:light_or_dark_theme == 'dark'
        let g:light_or_dark_theme = 'light'
    else
        let g:light_or_dark_theme = 'dark'
    endif
    call SetColorscheme()
endfunction

nnoremap <leader>oC :ToggleColorschemeDarkOrLight<cr>


" }}}

" cursor change in insert mode (from block to i-beam) {{{
" http://stackoverflow.com/questions/6488683/how-do-i-change-the-vim-cursor-in-insert-normal-mode

" escape sequence depends on the terminal ('konsole', 'urxvt')
let terminal='alacritty'

if terminal == 'konsole'
    " (this also resets the terminal font size, which is annoying)
    if exists('$TMUX')
        let &t_SI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=1\x7\<esc>\\"
        let &t_EI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=0\x7\<esc>\\"
    else
        let &t_SI = "\<esc>]50;CursorShape=1\x7"
        let &t_EI = "\<esc>]50;CursorShape=0\x7"
    endif
elseif terminal == 'urxvt'
    let &t_SI = "\e[6 q"
    let &t_EI = "\e[2 q"
endif


" }}}


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" Execute a interactive shell command in full screen {{{
command! -nargs=1 Shell :call Shell(<q-args>)
function! Shell(commandline)
    if has('nvim')
        $tabnew
        execute 'terminal ' . a:commandline
        startinsert
    else
        execute '!' . a:commandline
    endif
endfunction
" }}}


" Like vim's builtin input() but only for a fixed amount of characters {{{
function! InputNChars(number_of_chars, prompt)
    echo a:prompt
    let l:number = a:number_of_chars
    let l:result = ""
    while l:number > 0
        let l:input = nr2char(getchar())
        let l:result .= l:input
        let l:number -= 1
        echon l:input
    endwhile
    return l:result
endfunction
" }}}

" Confirm before executing a command {{{
command! -nargs=1 Confirm :call Confirm(<q-args>)
function! Confirm(vimcommand)
    if confirm("Execute '" . a:vimcommand . "'?", "&Yes\n&No", 2) == 1
        execute a:vimcommand
    endif
endfunction
" }}}


" Generate a random alphanumeric string of a certain length. {{{
function! RandomString(length)
    return system("tr -dc A-Za-z0-9 </dev/urandom | head -c " . a:length)
endfunction
nnoremap 'tr i<c-r>=RandomString(32)<esc><esc>
" }}}


" URL encode a string. ie. Percent-encode characters as necessary. {{{
function! UrlEncode(string)

    let result = ""

    let characters = split(a:string, '.\zs')
    for character in characters
        if character == " "
            let result = result . "+"
        elseif CharacterRequiresUrlEncoding(character)
            let i = 0
            while i < strlen(character)
                let byte = strpart(character, i, 1)
                let decimal = char2nr(byte)
                let result = result . "%" . printf("%02x", decimal)
                let i += 1
            endwhile
        else
            let result = result . character
        endif
    endfor

    return result

endfunction

" Returns 1 if the given character should be percent-encoded in a URL encoded
" string.
function! CharacterRequiresUrlEncoding(character)

    let ascii_code = char2nr(a:character)
    if ascii_code >= 48 && ascii_code <= 57
        return 0
    elseif ascii_code >= 65 && ascii_code <= 90
        return 0
    elseif ascii_code >= 97 && ascii_code <= 122
        return 0
    elseif a:character == "-" || a:character == "_" || a:character == "." || a:character == "~"
        return 0
    endif

    return 1

endfunction

" }}}


function! Expand(exp) abort
    let l:result = expand(a:exp)
    return l:result ==# '' ? '' : "file://" . l:result
endfunction

" improved path expansion (prepend './' if necessary)  {{{
function! ExpandPrependThisDir(expr)
    if expand(a:expr . ':h') == '.'
        return './' . expand(a:expr)
    else
        return expand(a:expr)
    endif
endfunction
" }}}


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" determine whether directory (or some parent) is a git repository or not {{{
function! IsGitRepository(dir)
    call system('cd "'.expand(a:dir).'" && git rev-parse --is-inside-work-tree >/dev/null 2>&1')
    return !v:shell_error
endfunction
" }}}

" determine current branch name
function! GitCurrentBranchName()
    return system('git rev-parse --abbrev-ref HEAD | tr -d "\n"')
endfunction

" determine (Jira) ticket number like XYZ-123 from current branch name
function! GitTicketNumberFromBranch()
    let l:branch_name = GitCurrentBranchName()
    let l:affected_code_part = system('git diff --cached --name-only | head -n1 | cut -d "/" -f1 | tr -d "\n"')
    let l:ticket_number_pattern = '\v^.*/\zs\u+-\d+\ze[/-].*'
    let l:ticket_number = matchstr(l:branch_name, l:ticket_number_pattern)
    return l:ticket_number
endfunction

" determine whether current branch has a tracking remote or not {{{
function! HasRemoteBranch()
    call system('git rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1')
    return !v:shell_error
endfunction
" }}}

" name of the first (propably only) remote, e.g. `origin`
function! GitRemoteName()
    return system('git remote | head -n1 | tr -d "\n"')
endfunction

" URL of the first remote, e.g. `git@github.com:flipsi/dotfiles`
function! GitRemoteUrl()
    return system("git ls-remote --get-url " . GitRemoteName() . " | tr -d '\\n'")
endfunction

" Known host of the remote URL if any, e.g. `github` or `gitlab`.
" This helps to decide whether to use Gitlab CLI or Github CLI.
function! GitRemoteHoster()
    let l:remote_url = GitRemoteUrl()
    if match(l:remote_url, 'gitlab') >= 0
        return 'gitlab'
    elseif match(l:remote_url, 'github') >= 0
        return 'github'
    elseif match(l:remote_url, 'bitbucket') >= 0
        return 'bitbucket'
    else
        echoerr "Unknown remote hoster: " . l:remote_url
    endif
endfunction

" echo `main` if branch exists or `master` otherwise
function! GitRepoMainOrMaster()
    call system('git rev-parse --verify main >/dev/null 2>&1')
    if !v:shell_error
        return 'main'
    else
        return 'master'
    endif
endfunction

function! GitChooseBranchInteractively(sink_function_name)
    call fzf#run(fzf#wrap({
                \ 'source': 'git branch',
                \ 'sink': function(a:sink_function_name)
                \ }))
endfunction

function! GitCheckout(ref)
    exe 'Git checkout ' . a:ref
endfunction

function! GitMerge(branch)
    exe 'Confirm Git merge ' . a:branch
endfunction

function! GitRebase(branch)
    exe 'Confirm Git rebase ' . a:branch
endfunction

command! GitCheckoutInteractively :call GitChooseBranchInteractively('GitCheckout') " checkout git branch chosen with fzf
command! GitMergeChooseBranchInteractively :call GitChooseBranchInteractively('GitMerge') " merge git branch chosen with fzf
command! GitRebaseChooseBranchInteractively :call GitChooseBranchInteractively('GitRebase') " rebase on git branch chosen with fzf

command! GitPush :call GitPush() " Git push or GitPushNewBranch if necessary
function! GitPush()
    if HasRemoteBranch()
        Git push
    else
        GitPushNewBranch
    endif
endfunction

command! GitPushNewBranch :call GitPushNewBranch() " push a new branch to remote and set tracking upstream
function! GitPushNewBranch()
    let l:remote = GitRemoteName()
    let l:branch_name = GitCurrentBranchName()
    exe ':Git push -u ' . l:remote . ' ' . l:branch_name
endfunction

" Github CLI (`gh`) or Gitlab CLI (`glab`) functionality

command! GitRemoteDiffMergeRequest call GitRemoteDiffMergeRequest() " Show changes or Merge Request in pager
function! GitRemoteDiffMergeRequest()
    if GitRemoteHoster() == 'gitlab'
        Shell glab mr diff | delta
    else
        Shell gh pr diff | delta
    endif
endfunction

command! GitRemoteCreateOrViewMergeRequest call GitRemoteCreateOrViewMergeRequest() " Open (and create if not exists) Pull Request on Github/Gitlab
function! GitRemoteCreateOrViewMergeRequest()
    if !HasRemoteBranch()
        GitPushNewBranch
    endif
    if GitRemoteHoster() == 'gitlab'
        Dispatch! glab mr view --web || glab mr create --web --fill
    elseif GitRemoteHoster() == 'github'
        Dispatch! gh pr view --web || gh pr create --web
    elseif GitRemoteHoster() == 'bitbucket'
        GitRemoteCreateOrViewMergeRequestOnBitbucket
    else
        echoerr "Unknown remote hoster: " . l:remote_url
    endif
endfunction

command! GitRemoteCreateOrViewMergeRequestOnBitbucket call GitRemoteCreateOrViewMergeRequestOnBitbucket() " Open (and create if not exists) Pull Request on Github/Gitlab
function! GitRemoteCreateOrViewMergeRequestOnBitbucket()
    " TODO: check if PR already exists and open
    let l:branch_name = GitCurrentBranchName()
    let l:ticket_number = GitTicketNumberFromBranch()
    " Dispatch git branch " TODO: fix that input works with that
    let l:target_branch = input("Target branch: ")
    " cclose
    let l:title = l:ticket_number . ' ' . input("Pull request title:" . l:ticket_number . ' ')
    let l:description = input("Description: ")
    let l:repo = substitute(GitRemoteUrl(), '.*:\(.*\)', '\1', '')
    let l:api_url = 'https://api.bitbucket.org/2.0/repositories/' . l:repo . '/pullrequests'
    let l:payload = '{"title": "' . l:title . '", "source": {"branch": {"name": "' . l:branch_name . '"}}, "destination": {"branch": {"name": "' . l:target_branch . '"}}, "description": "' . l:description . '"}'
    " TODO: authenticate
    " either with       -u p.moers@reply.de:(pass reply/bitbucket/app-passwords/CLI)
    " or with           --header "Authorization: Bearer $(pass reply/bitbucket/api-tokens/workspace-sideup/CLI | head -n1 | tr -d '\n')" \
    " but both don't work
    let l:command = 'curl -X POST -H "Content-Type: application/json" -d ' . shellescape(l:payload) . ' ' . l:api_url
    exec 'Dispatch ' . l:command
    echo "Pull request created."
    OpenGitRepoWeb
endfunction

command! GitRemoteShowPipeline call GitRemoteShowPipeline() " Show pipeline progress
function! GitRemoteShowPipeline()
    if GitRemoteHoster() == 'gitlab'
        Dispatch! glab pipeline ci view
    else
        echoerr "Sorry, I only have this for Gitlab at the moment..."
    endif
endfunction

command! OpenGitRepoWeb :call OpenGitRepoWeb() " Open Github/Gitlab repo in browser
function! OpenGitRepoWeb()
    if GitRemoteHoster() == 'gitlab'
        Dispatch! glab repo view --web
    elseif GitRemoteHoster() == 'github'
        Dispatch! gh repo view --web
    else
        call GitWebUrl('pull-requests', 'open_in_web')
    endif
endfunction

" Get Github or Gitlab URL of file and position in current revision.
" Either return or yank_to_clipboard or open_in_web
" TODO: fix when working dir is dirty (added or removed lines)
function! GitWebUrl(line_or_range, return_or_yank_to_clipboard_or_open_in_web)
    let l:remote_name = system('git remote | head -n1')
    let l:revision = system('git rev-parse HEAD | tr -d "\n"')
    let l:remote_url = system('git ls-remote --get-url ' . l:remote_name)
    let l:url_matches = matchlist(l:remote_url, '\m\(github\.com\|gitlab.*\.com\|bitbucket.*\.org\)[:/]\(.\{-}\)\(\.git\)\?\n')
    if v:shell_error || len(l:url_matches) == 0
        echo "Could not extract web URL."
        return
    endif

    let l:git_root = system("git rev-parse --show-toplevel")
    let l:relative_path = expand("%:p")
    let l:absolute_path = strpart(l:relative_path, strlen(l:git_root))
    let l:web_domain = l:url_matches[1]

    if a:line_or_range == 'range'
        let [l:startline, l:startcol, l:endline, l:endcol] = GetVisPos()
        if match(l:web_domain, 'bitbucket\.org') >= 0
            let l:line_param = "#lines-" . l:startline . ':' . l:endline
            let l:path_prefix = '/src/' . l:revision . '/'
        else
            let l:line_param = "#L" . l:startline . '-L' . l:endline
            let l:path_prefix = '/blob/' . l:revision . '/'
        endif
    elseif a:line_or_range == 'line'
        if match(l:web_domain, 'bitbucket\.org') >= 0
            let l:line_param = "#lines-" . line('.')
            let l:path_prefix = '/src/' . l:revision . '/'
        else
            let l:line_param = "#L". line('.')
            let l:path_prefix = '/blob/' . l:revision . '/'
        endif
    elseif a:line_or_range == 'pull-requests'
        if match(l:web_domain, 'github\.com') >= 0
            let l:pull_requests_path = '/pulls'
        elseif match(l:web_domain, 'gitlab\.com') >= 0
            let l:pull_requests_path = '/-/merge_requests'
        elseif match(l:web_domain, 'bitbucket\.org') >= 0
            let l:pull_requests_path = '/pull-requests'
        else
            let l:pull_requests_path = '/pull-requests'
        endif
    endif

    if a:line_or_range == 'pull-requests'
        let l:web_url = 'https://' . l:web_domain . '/' . l:url_matches[2] . l:pull_requests_path
    else
        let l:web_url = 'https://' . l:web_domain . '/' . l:url_matches[2] . l:path_prefix . l:absolute_path . l:line_param
    endif

    if a:return_or_yank_to_clipboard_or_open_in_web == 'return'
        return l:web_url
    elseif a:return_or_yank_to_clipboard_or_open_in_web == 'yank_to_clipboard'
        echo "Yanking " . l:web_url
        let @+=l:web_url
    elseif a:return_or_yank_to_clipboard_or_open_in_web == 'open_in_web'
        echo "Opening " . l:web_url
        call system("$BROWSER " . l:web_url)
    endif
endfunction


" copy current filename/path/dir (unnamed register/clipboard/fucking everywhere) {{{
function! CopyFileNameOrPathOrDir(modifiers)
    let @" = expand(a:modifiers)
    let @+ = expand(a:modifiers)
    let @* = expand(a:modifiers)
    echo @"
endfunction
" }}}


" toggle syntax highlighting {{{

command! DisableSyntax :syntax off          " Disable syntax highlighting (globally)
command! EnableSyntax  :syntax enable       " Enable syntax highlighting (globally)

command! ToggleSyntax :call ToggleSyntax() " Disable or enable syntax highlighting (globally)
function! ToggleSyntax()
   if exists("g:syntax_on")
       DisableSyntax
   else
       EnableSyntax
   endif
endfunction

command! DisableSyntaxCurrentBuffer :setlocal syntax=OFF " Disable syntax highlighting (current buffer)
command! EnableSyntaxCurrentBuffer  :setlocal syntax=ON  " Enable syntax highlighting (current buffer)

command! ToggleSyntaxCurrentBuffer :call ToggleSyntaxCurrentBuffer() " Disable or enable syntax highlighting (current buffer)
function! ToggleSyntaxCurrentBuffer()
   if &syntax == "OFF"
       EnableSyntaxCurrentBuffer
   else
       DisableSyntaxCurrentBuffer
   endif
endfunction

" }}}

" get list of position of current visual selection {{{
function! GetVisPos()
  let l:startline = line("'<")
  let l:startcol = col("'<")
  let l:endline = line("'>")
  let l:endcol = col("'>")
  return [l:startline, l:startcol, l:endline, l:endcol]
endfunction
" }}}

" get a list of buffers {{{
function! GetBufferList()
    silent! redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction
" }}}

" get buffer number by filename pattern {{{
function! GetBufferByPattern(pattern, one_or_list)
    let bufcount = bufnr("$")
    let currbufnr = 1
    let matches = []
    while currbufnr <= bufcount
        if (bufexists(currbufnr))
            let currbufname = bufname(currbufnr)
            if (match(currbufname, a:pattern) > -1)
                let matches = add(matches, currbufnr)
            endif
        endif
        let currbufnr = currbufnr + 1
    endwhile
    if (a:one_or_list == 'one')
        if (len(matches) == 1)
            return matches[0]
        elseif (len(matches) > 1)
            throw "More than one matching buffer found"
        else
            throw "No matching buffers"
        endif
    elseif (a:one_or_list == 'list')
        return matches
    else
        throw "Argument should be 'one' or 'list'."
    endif
endfunction
" }}}

" Check wether current buffer is Terminal buffer or not. Returns 0 (false) if not, 1 (true) otherwise {{{
function! IsTerminalBuffer()
    if !has('nvim')
        " TODO: make this work in regular vim
        echoerr "Sorry, this is only implemented in neovim (right now)."
        return
    endif
    " terminals have b:terminal_job_id defined
    return getbufvar("", "terminal_job_id", 0) > 1
endfunction
" }}}

" find buffers with a running terminal (returns list of bufnum) {{{
function! GetTerminalBuffers()
    if !has('nvim')
        " TODO: make this work in regular vim
        echoerr "Sorry, this is only implemented in neovim (right now)."
        return
    endif
    " terminals have b:terminal_job_id defined
    let l:terminals = filter(range(1, bufnr('$')), 'bufexists(v:val) && getbufvar(v:val, "terminal_job_id", 0)')
    return l:terminals
endfunction
" }}}

" find bufnum of the first buffer with a running terminal (or 0) {{{
function! GetTerminalBuffer()
    let l:terminals = GetTerminalBuffers()
    if len(l:terminals) == 0
        return 0
    else
        return l:terminals[0]
    endif
endfunction
" }}}

" Close all buffers with a running terminal {{{
" With bang it also kills the running shell
command! -bang CloseTerminalBuffers :call CloseTerminalBuffers(<bang>0) " Close all buffers with a running terminal
function! CloseTerminalBuffers(bang)
    let l:terminals = GetTerminalBuffers()
    if a:bang
        let l:bang_string = '!'
    else
        let l:bang_string = ''
    endif
    for n in l:terminals
        exe n . 'bd' . l:bang_string
    endfor
endfunction
" }}}

" Execute a command only if the current buffer is a regular one (no terminal, quickfix, help page etc.) {{{
function! ExecuteIfRegularBuffer(cmd)
    if &buftype == ''
        exec a:cmd
    endif
endfunction
" }}}

" Execute a command in all regular windows and restore cursor position {{{
function! WindoInRegularBuffers(cmd)
    let l:winnr = winnr()
    windo call ExecuteIfRegularBuffer(a:cmd)
    exec l:winnr . 'wincmd w'
    stopinsert
endfunction
" }}}

command! SaveCursorAndWindowPosition :call SaveCursorAndWindowPosition()
function! SaveCursorAndWindowPosition()
    let g:saved_win_id = win_getid()
    normal! mZ
endfunction

command! RestoreCursorAndWindowPosition :call RestoreCursorAndWindowPosition()
function! RestoreCursorAndWindowPosition()
    call win_gotoid(g:saved_win_id)
    normal! `Z
endfunction


" Show a temporary message in a floating window with a border {{{
" From https://www.statox.fr/posts/2021/03/breaking_habits_floating_window/
" TODO: debug
function! ShowMessageInFloatingWindow(msg) abort
    " Define the size of the floating window
    let width = 50
    let height = 10

    " Create the scratch buffer displayed in the floating window
    let buf = nvim_create_buf(v:false, v:true)

    " Get the current UI
    let ui = nvim_list_uis()[0]

    " create the lines to draw a box
    let horizontal_border = '+' . repeat('-', width - 2) . '+'
    let empty_line = '|' . repeat(' ', width - 2) . '|'
    let lines = flatten([horizontal_border, map(range(height-2), 'empty_line'), horizontal_border])

    " Create the lines for the centered message and put them in the buffer
    let offset = 0
    for line in a:msg
        let start_col = (width - len(line)) / 2
        let end_col = start_col + len(line)
        let current_row = height / 2 - len(a:msg) / 2 + offset
        let offset = offset + 1
        call nvim_buf_set_text(buf, current_row, start_col, current_row, end_col, [line])
    endfor

    " Create the floating window
    let opts = {'relative': 'editor',
                \ 'width': width,
                \ 'height': height,
                \ 'col': (ui.width/2) - (width/2),
                \ 'row': (ui.height/2) - (height/2),
                \ 'anchor': 'NW',
                \ 'style': 'minimal',
                \ }
    let win = nvim_open_win(buf, 1, opts)

    " Change highlighting
    call nvim_win_set_option(win, 'winhl', 'Normal:ErrorFloat')
endfunction

" }}}

" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx . 'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    if a:pfx == 'c'
        bot copen
    else
        lopen
    endif
    if winnr() != winnr
        wincmd p
    endif
endfunction
" }}}

" return 1 iff the quickfix window is open  {{{
function! HasQuickfixList()
    for winnr in range(1, winnr('$'))
        if getwinvar(winnr, '&syntax') == 'qf'
            return 1
        endif
    endfor
    return 0
endfunction

" return 1 iff the active window contains a quickfix buffer and there are no other windows with normal buffers. {{{
function! IsOrphanQuickfixList()
    let winnr = winnr("$")
    while winnr >= 1
        if getbufvar(winbufnr(winnr), "&buftype") == ""
            return 0
        endif
        let winnr -=1
    endwhile
    return getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"
endfunction

" improve quickfix/location list
augroup quickfix
    au!
    " automatically close quickfix/location list when alone
    au BufEnter * if IsOrphanQuickfixList()
    au BufEnter *     bdelete
    au BufEnter * endif
augroup END
" }}}



" make columns after &textwidth visible or invisible {{{
function! SetColorColumn(mode)
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if (&colorcolumn == "" || &colorcolumn != expr) && a:mode == 'toggle' || a:mode == "on"
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}

"... and call this function when &textwidth is changed
if v:version > 704 || v:version == 704 && has("patch786") " if has ('patch-7.4.786')
    augroup colorcolumn
        au!
        au OptionSet textwidth if &textwidth != 0
        au OptionSet textwidth      call SetColorColumn('on')
        au OptionSet textwidth else
        au OptionSet textwidth      set colorcolumn=
        au OptionSet textwidth endif
    augroup END
endif


" Return list of matches for given pattern in given range.
" This only works for matches within a single line.
" Empty hits are skipped so search for '\d*\ze,' is not stuck in '123,456'.
" If omit match() 'count' argument, pattern '^.' matches every character.
" Using count=1 causes text before the 'start' argument to be considered.
function! GetMatches(pattern, line1, line2)
  let hits = []
  for line in range(a:line1, a:line2)
    let text = getline(line)
    let from = 0
    while 1
      let next = match(text, a:pattern, from, 1)
      if next < 0
        break
      endif
      let from = matchend(text, a:pattern, from, 1)
      if from > next
        call add(hits, strpart(text, next, from - next))
      else
        let char = matchstr(text, '.', next)
        if empty(char)
          break
        endif
        let from = next + strlen(char)
      endif
    endwhile
  endfor
  return hits
endfunction

" Search for pattern from the current line upwards and return the first matching line number.
" Returns 0 if no line matches the pattern.
" Poor man's solution to find the current function name etc. without heavy machinery.
function! GetMostPreviousMatchingLine(pattern)
    for l:line in range(line('.'), 1, -1)
        if match(getline(l:line), a:pattern) != -1
            return l:line
        endif
    endfor
    return 0
endfunction

" Search for pattern from the current line upwards and return the first match (text).
" Throws an exception if no line matches the pattern.
" Poor map's solution to find the current function name etc. without heavy machinery.
function! GetMostPreviousMatch(pattern, sub)
    let l:matching_line = GetMostPreviousMatchingLine(a:pattern)
    if l:matching_line == 0
        throw "Pattern not found: " . a:pattern
    else
        return substitute(getline(l:matching_line), a:pattern, a:sub, '')
    endif
endfunction


" Search across newlines {{{
" separated with whitespace (if no '!'),
" or with non-word characters (if '!' added to command).
" http://vim.wikia.com/wiki/Search_across_multiple_lines
function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag SearchMultiLine call SearchMultiLine(<bang>0, <f-args>)|normal! /<c-r>/<cr>

" }}}



" Search for current word and replace with given text for files in arglist. {{{
" http://vim.wikia.com/wiki/Search_and_replace_in_multiple_buffers
function! Replace(bang, replace)
    " (we use 'gdefault')
    " let flag = 'ge'
    let flag = 'gge'
    if !a:bang
        let flag .= 'c'
    endif
    let search = '\<' . escape(expand('<cword>'), '/\.*$^~[') . '\>'
    let replace = escape(a:replace, '/\&~')
    execute 'argdo %s/' . search . '/' . replace . '/' . flag
endfunction
command! -nargs=1 -bang Replace :call Replace(<bang>0, <q-args>)

" }}}

" comment the current line / form (without a plugin) {{{
" TODO: integrate ToggleHTMLComment (does not do filetype detection which is a feature, so filetype should maybe be an optional parameter)
function! ToggleComment(mode)

    let l:filetype = &filetype
    if l:filetype == 'clojure'
        let l:left_marker   = '#_'
        let l:right_marker  = ''
    elseif l:filetype == 'html'
        let l:left_marker   = '<!-- '
        let l:right_marker  = ' -->'
    endif

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    " TODO: escape | and ` in markers (and more, because \V doesn't work here)
    " let l:is_commented = stridx(l:text, '\V' . l:left_marker) > -1
    let l:is_commented = stridx(l:text, l:left_marker) > -1
    if !l:is_commented
        " TODO: fix for visual mode
        execute range . "substitute`\\v^(\\s*)(.*)$`\\1" . l:left_marker . "\\2" . l:right_marker . "`"
    else
        execute range . "substitute`\\V" . l:left_marker . "\\v(.*)\\V" . l:right_marker . "`\\1`"
    endif

endfunction

" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\s)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\s)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\s)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters below {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num
    let linenumber = line(".")
    call append(linenumber, repeat(char, num))
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    let linenumber = line(".")
    let line = getline(".")
    let len = strlen(line) + 2 + 2
    let borderline = repeat(char, len)
    execute '.substitute/^/' . char . ' /'
    execute '.substitute/$/ ' . char . '/'
    call append(linenumber, repeat(char, len))
    call append(linenumber-1, repeat(char, len))
endfunction
" }}}


" poor-man's (fake IDE) auto-import {{{
" searches for import statement for word under cursor and adds it to buffer
command! -bar AutoImportFake call AutoImportFake()
function! AutoImportFake()
    let word = expand("<cword>")
    call fzf#run(fzf#wrap({
                \ 'source': 'git grep -h "import.*' . word . '" | sort | uniq',
                \ 'sink': function('AddImportStatement')
                \ }))
endfunction
function! AddImportStatement(statement)
    normal gg
    let linenumber = search('import')
    put =a:statement
endfunction
" }}}


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" send buffer via slack {{{
function! SendBufferViaSlack(channel)
    let l:channel = substitute(a:channel, '\[.*\] \[.*\]\s\+', '', '')
    exec "write !slackcat --channel '" . l:channel . "' --filename " . expand("%:t")
endfunction
" }}}


" send buffer via slack after choosing channel interactively {{{
function! SendBufferViaSlackChooseChannel()
    " let content = system("slackcat --list")
    " echo content
    " let choice = input("Which channel: ")
    " call SendBufferViaSlack(choice)
    call fzf#run({
                \ 'source': 'slackcat --list',
                \ 'sink': function('SendBufferViaSlack')
                \ })
endfunction
nnoremap <leader>iS :call SendBufferViaSlackChooseChannel()<cr>
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.
" Now you can use ToggleHighlightInterestingWord(n) where n is a number from 1-9
" to highlight the current word in a specific color.

let g:match_id_base = 86750

function! ToggleHighlightInterestingWord(n)
    SaveCursorAndWindowPosition
    let match_id = g:match_id_base + a:n
    silent! windo let new_match = matchdelete(match_id)
    if new_match
        RestoreCursorAndWindowPosition
        normal! "zyiw
        let pattern = '\V\<' . escape(@z, '\') . '\>'
        windo call matchadd("InterestingWord" . a:n, pattern, 1, match_id)
    endif
    RestoreCursorAndWindowPosition
endfunction

function! RemoveAllInterestingWordHighlights()
    let l:win_id = win_getid()
    silent! windo call matchdelete(g:match_id_base + 1)<bar>
    silent! windo call matchdelete(g:match_id_base + 2)<bar>
    silent! windo call matchdelete(g:match_id_base + 3)<bar>
    silent! windo call matchdelete(g:match_id_base + 4)<bar>
    silent! windo call matchdelete(g:match_id_base + 5)<bar>
    silent! windo call matchdelete(g:match_id_base + 6)<cr>
    silent! windo call matchdelete(g:match_id_base + 7)<cr>
    silent! windo call matchdelete(g:match_id_base + 8)<cr>
    silent! windo call matchdelete(g:match_id_base + 9)<cr>
    call win_gotoid(l:win_id)
endfunction

" Mappings
nnoremap <silent> <leader>1 :call ToggleHighlightInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call ToggleHighlightInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call ToggleHighlightInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call ToggleHighlightInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call ToggleHighlightInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call ToggleHighlightInterestingWord(6)<cr>
nnoremap <silent> <leader>7 :call ToggleHighlightInterestingWord(7)<cr>
nnoremap <silent> <leader>8 :call ToggleHighlightInterestingWord(8)<cr>
nnoremap <silent> <leader>9 :call ToggleHighlightInterestingWord(9)<cr>
nnoremap <silent> <leader>0 :call RemoveAllInterestingWordHighlights()<cr>

" Highlights (color definitions)
hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#086A7E ctermbg=33
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#08471D ctermbg=28
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#C71640 ctermbg=200
hi def InterestingWord7 guifg=#000000 ctermfg=16 guibg=#5B0F74 ctermbg=57
hi def InterestingWord8 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord9 guifg=#000000 ctermfg=16 guibg=#553E26 ctermbg=220


" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" handle binary documents {{{

augroup read_special_files
    au!
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}
                \ call s:filter_special_files()
augroup END

fu! s:filter_special_files() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif
    let fname = shellescape(expand('%:p'), 1)
    let ext = expand('%:e')
    let ext2cmd = {
    \               'doc' : '%!antiword '.fname,
    \               'docx': '%!pandoc -f docx -t markdown '.fname,
    \               'epub': '%!pandoc -f epub -t markdown '.fname,
    \               'odp' : '%!odt2txt '.fname,
    \               'odt' : '%!odt2txt '.fname,
    \               'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
    \               'rtf' : '%!unrtf --text',
    \             }
    if has_key(ext2cmd, ext)
        setl ma noro
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl noma ro nomod
    endif
endfu

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  COMMAND AND KEYMAP SECTION                                                  "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


let mapleader=' '


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FIX AND SPEEDUP MY TYPING {{{

iabbrev asap        as soon as possible
iabbrev BE          backend
iabbrev CIG         Code Intelligence
iabbrev CIF         CI Fuzz
iabbrev CIS         CI Sense
iabbrev FE          frontend
iabbrev af          autoformat
iabbrev admini      administrator
iabbrev dpr         deprecated
iabbrev misc        miscellaneous
iabbrev ns          namespace
iabbrev pr          println
iabbrev sm          [SQUASHME]
iabbrev todo        TODO:
iabbrev todod       TODO: delete this debugging statement
iabbrev todof       TODO: FIX
iabbrev todoi       TODO: implement
iabbrev wip         [WIP]

" awkward rolling issue on Moonlander keyboard
iabbrev (9          ()

" password store
augroup abbreviations_password_store
    autocmd!
    autocmd BufRead /dev/shm/pass.* iabbrev auto autotype: email :tab pass :enter
augroup END


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GUI settings {{{

set guifont=PragmataPro\ Mono

if exists("g:neovide")

    let g:neovide_transparency = 0.9

    let neovide_position_animation_length = 0.1
    let neovide_cursor_animation_length = 0.05
    let neovide_cursor_trail_size = 0
    let neovide_cursor_animate_in_insert_mode = 0
    let neovide_cursor_animate_command_line = 0
    let neovide_scroll_animation_far_lines = 5
    let neovide_scroll_animation_length = 0.05


    " change font size in
    if !exists('g:neovide_scale_factor')
        let g:neovide_scale_factor=0.7
    endif
    function! ChangeScaleFactor(delta)
        let g:neovide_scale_factor = g:neovide_scale_factor * a:delta
    endfunction
    nnoremap <expr><C-+> ChangeScaleFactor(1.2)
    nnoremap <expr><C--> ChangeScaleFactor(1/1.2)

endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<cr>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<cr>
"endif
"nnoremap <leader><f5> :MyRefresh<cr>

" ignore typos with text edit leader
nnoremap ' <nop>

" show current working directory
nnoremap <leader>pwd :pwd<cr>

" show absolute path of current file (':help filename-modifiers')
nnoremap <leader><c-g> :echo expand("%:~")<cr>

" copy current filename/path/dir (unnamed register/clipboard/fucking everywhere) {{{
command! CopyFileName                   :call CopyFileNameOrPathOrDir("%:t")    " Copy name of current file
command! CopyFileNameWithoutExtension   :call CopyFileNameOrPathOrDir("%:t:r")  " Copy name of current file (without extension)
command! CopyFilePath                   :call CopyFileNameOrPathOrDir("%")      " Copy relative path to current file
command! CopyFilePathAbsolute           :call CopyFileNameOrPathOrDir("%:p")    " Copy absolute path to current file
command! CopyFileDirectory              :call CopyFileNameOrPathOrDir("%:p:h")  " Copy directory of current file
nnoremap <leader>yf :CopyFileName<cr>
nnoremap <leader>ye :CopyFileNameExpand<cr>
nnoremap <leader>yp :CopyFilePath<cr>
nnoremap <leader>yP :CopyFilePathAbsolute<cr>
nnoremap <leader>yd :CopyFileDirectory<cr>
" }}}

" open all files that are dirty according to git
command! EditGitDirtyFiles :call EditGitDirtyFiles() " open all files that are dirty according to git
function! EditGitDirtyFiles()
    let numberOfGitDirtyFiles = system("git status --porcelain 2>/dev/null \| egrep '^(M\| M)' \| wc -l")
    if numberOfGitDirtyFiles != 0
        silent! args `git diff --name-only`
        " if vim was just started, let's get rid of the first unnamed buffer:
        if empty(getbufinfo()[0]['name'])
            bd 1
        endif
        " TODO: avoid error with already openend windows
    else
        echo 'Working directory clean'
    endif
endfunction
" nnoremap <leader>eG :silent! args `git diff --name-only`<cr>:bd#<cr>
nnoremap <leader>eG :call EditGitDirtyFiles()<cr>

" open config file
"nnoremap <leader>ev :edit ~/dotfiles/vim/vimrc<cr>
nnoremap <leader>ev :execute 'edit ' . resolve(expand('~/.vimrc'))<cr>
nnoremap <leader>e3 :execute 'edit ' . resolve(expand('~/.i3/config'))<cr>

" reload config file
nnoremap <leader>sv :SourceMYVIMRC<cr><esc><esc>
nmap <f5> <leader>sv


" to follow links in help and jump to definition (ctags)
nnoremap <m-enter>    <c-]>
nnoremap <esc><enter> <c-]>
augroup map_enter_help
    au!
    au BufReadPost */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ nnoremap <buffer> <enter> <c-]>
augroup END
" nnoremap <leader><down> :tn<cr>
" nnoremap <leader><up>   :tp<cr>


" visual block mode is more useful than visual mode
nnoremap v <c-v>
nnoremap <c-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <c-c>


" copy to clipboard / primary selection
nnoremap    <c-c>                 "+y
nnoremap    <c-c>w        viw"*ygv"+y
nnoremap    <c-c>W        viW"*ygv"+y
nnoremap    <c-c><c-c>      V"*ygv"+y
nnoremap <leader><c-c>  mzggVG"*ygv"+y`z
vnoremap    <c-c>             "*ygv"+y

" paste from clipboard / primary selection {{{
function! PasteFromGUI()
    let clipbrd = @+
    let primary = @*
    if len(primary) == 0
        normal "+Pl
    elseif len(clipbrd) == 0
        normal "*Pl
    elseif primary == clipbrd
        normal "*Pl
    else
        ec "Paste (c)lipboard (default)    " . strtrans(strpart(clipbrd, 0, 50))
        ec "or    (p)rimary selection?     " . strtrans(strpart(primary, 0, 50))
        let c = getchar()
        if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
            redraw
        elseif nr2char(c) == 'c' || nr2char(c) == '+' || c == 13 || c == 22
            normal "+Pl
            redraw
        elseif nr2char(c) == 'p' || nr2char(c) == 's' || nr2char(c) == '*'
            normal "*Pl
            redraw
        endif
    endif
endfunction
" }}}
noremap <silent> <c-v><c-v> :call PasteFromGUI()<cr>
imap <c-v><c-v> <c-o><c-v><c-v>
noremap <silent> <c-v>j o<esc>:call PasteFromGUI()<cr>
noremap <silent> <c-v>k O<esc>:call PasteFromGUI()<cr>


" Convert Unix timestamp to datetime
function! UnixTimestampAsDateTime(timestamp)
    return system('date --iso-8601=seconds -d @' . a:timestamp . ' | tr -d "\n"')
endfunction

" Replace Unix timestamp with datetimes
function! ReplaceUnixTimestampWithDateTime(rangeString)
    "" in current line:
    " .substitute:\v(\d{9,15}):\='"' . UnixTimestampAsDateTime(submatch(1)) . '"':
    "" with range:
    exe a:rangeString . 'substitute:\v(\d{9,15}):\= ''"''. UnixTimestampAsDateTime(submatch(1)) . ''"'':'
endfunction

" Replace Unix timestamp with datetime in current line
command! ReplaceUnixTimestampWithDateTimeInCurrentLine :call ReplaceUnixTimestampWithDateTime('.') " Replace Unix timestamps with datetimes in current line
nnoremap 'utl :call ReplaceUnixTimestampWithDateTime('.')<cr>

" Replace Unix timestamps with datetimes in buffer
command! ReplaceUnixTimestampWithDateTimeInBuffer :call ReplaceUnixTimestampWithDateTime('%') " Replace Unix timestamps with datetimes in buffer
nnoremap 'utb :call ReplaceUnixTimestampWithDateTime('%')<cr>

" Show Unix timestamp under cursor as datetime
command! UnixTimestampAsDateTime :echo UnixTimestampAsDateTime(expand("<cword>"))
nnoremap <leader>ut :echo UnixTimestampAsDateTime(expand("<cword>"))<cr>


" macro ('complex repeat') without worrying about registers
" record macro (start and stop) with <leader>Q
" replay macro with <leader>q
" nnoremap @{ :nmap <leader<left><right>>Q @}<cr>qq
" nnoremap @} q:nmap <leader<left><right>>Q @{<cr>:echo ''<cr>
" nmap     <leader>Q @{
" nnoremap <leader>q @q

" macro ('complex repeat') with registers
" (remapping q is bad, because it is used to close stuff like plugin windows)
nnoremap Q @
nnoremap QQ @@

if exists('##RecordingLeave')
    augroup repeat_macros_with_enter
        au!
        au RecordingLeave * exec 'nnoremap <buffer> <cr> @' . reg_recorded()
    augroup END
endif


" alternative way to go back to normal mode
" (map double esc on custom keyboard layout to F9)
inoremap <F9> <esc>
cnoremap <F9> <esc>
inoremap jk <esc>
cnoremap jk <c-c>
cnoremap <c-g> <c-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll a little smoother
" (this actually is suggested in :help scroll-smooth)
noremap <PageDown>  <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <m-j>       <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <esc>j      <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <PageUp>    <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>
noremap <m-k>       <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>
noremap <esc>k      <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>

" scroll page-wise
noremap <m-down>    <c-f>
noremap <esc><down> <c-f>
noremap <m-up>      <c-b>
noremap <esc><up>   <c-b>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TERMINAL {{{

" nnoremap <leader>tt :Terminal! fish<cr>
" nnoremap <leader>to :Terminal<space>
" nnoremap <leader>tO :Terminal!<space>

" run a given (interactive) commandline in the builtin terminal in a vertical split (also see :Shell)
command! -nargs=1 -bang Terminal :call Terminal(<bang>0, <q-args>)
" with bang == 0: keep terminal open after exit
" with bang == 1: close terminal automatically after exit
" TODO: argument for keeping focus on current window
function! Terminal(bang, commandline)
    if !has('nvim')
        let l:open_or_close = a:bang ? "++close " : "++open "
        execute 'vertical terminal ' . l:open_or_close . a:commandline
    else
        let g:terminal_close_after_exit = a:bang
        execute 'vsplit | terminal ' . a:commandline
    endif
endfunction

if has('nvim')

    let g:terminal_close_after_exit = 0

    augroup terminal_autocommands
        au!

        " start terminal in insert mode, not normal mode
        " (in neoterm we have g:neoterm_autoinsert)
        " autocmd TermOpen * startinsert

        " enter insert mode when switching to terminal
        " autocmd BufEnter term://* startinsert
        autocmd BufEnter term://* if !exists('g:suppress_terminal_autoinsert') | startinsert | endif

        " don't show line numbers
        autocmd TermOpen * setlocal nonumber
        autocmd TermOpen * setlocal norelativenumber

        " don't list terminal buffers in buffer list
        autocmd TermOpen * setlocal nobuflisted

        " close terminal buffer automatically after shell exits
        " (https://www.reddit.com/r/neovim/comments/7xonzm/how_to_close_a_terminal_buffer_automatically_if/)
        autocmd TermClose * silent call s:OnTermClose()

    augroup END

    function! s:OnTermClose()
        if g:terminal_close_after_exit
            call s:PressKeyToCloseTerminal()
        endif
    endfunction

    function! s:PressKeyToCloseTerminal()
        " Try to move the cursor to the last line containing text
        try
            $;?.
        catch
            " The buffer is empty here. This shouldn't ever happen
            return
        endtry
        " Is the last line an error message?
        if match(getline('.'), 'make: \*\*\* \[[^\]]\+] Error ') == -1
            call feedkeys('<cr>')
        endif
    endfunction

endif

" maximize terminal window
tnoremap <c-y>z <c-\><c-n>:MaximizerToggle!<CR>i

" leave terminal insert mode
" (this is a bad idea if terminal applications use <esc> as well)
" tnoremap <esc> <c-\><c-n>
" tnoremap <expr> <esc> &filetype == 'fzf' ? "\<esc>" : "\<c-\>\<c-n>"
tnoremap <c-y><c-y> <c-\><c-n>

" leave terminal insert mode and scroll up
tnoremap <c-b>      <c-\><c-n><c-b>
" tnoremap <PageUp>   <c-\><c-n><c-b> " breaks TUI apps like tig
" tnoremap <PageDown> <c-\><c-n><c-b> " breaks TUI apps like tig

" leave terminal insert mode and move to last used or adjacent window
tnoremap <c-y><c-l>     <c-\><c-n><c-w>p
tnoremap <c-y><up>      <c-\><c-n><c-w>k
tnoremap <c-y><left>    <c-\><c-n><c-w>h

" leave terminal insert mode and move window to the bottom/right
tnoremap <c-y>J         <c-\><c-n><c-w>Ji
tnoremap <c-y>L         <c-\><c-n><c-w>Li



" TODO: checkout debugging feature (see :help terminal-debug)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)

" nnoremap ; : " don't know what to do with sneak then
" nnoremap : ;

" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))
autocmd FileType help wincmd L

" write changes with root permissions
" (does not work in neovim, so I use the suda.vim plugin now)
if s:MyMode == 'stripped'
    cnoreabbrev w!! w !sudo tee % >/dev/null
endif

" have the up/down search functionality without reaching to the arrow keys
cnoremap <c-j> <down>
cnoremap <c-k> <up>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{

" change undofile settings
command! DisableUndoFile :setlocal noundofile " don't persist undo history
command! EnableUndoFile  :setlocal undofile   " persist undo history
nnoremap <leader>ou :setlocal undofile! <bar> :setlocal undofile?<cr>

" change text width
command! -nargs=1 SetTextWidth  :set textwidth=<args> " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthDisable    :set textwidth=0      " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo50       :set textwidth=50     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo78       :set textwidth=78     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo80       :set textwidth=80     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo100      :set textwidth=100    " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo120      :set textwidth=120    " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo140      :set textwidth=140    " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
nnoremap <leader>ow0            :set textwidth=0<cr>
nnoremap <leader>ow5            :set textwidth=50<cr>
nnoremap <leader>ow7            :set textwidth=78<cr>
nnoremap <leader>ow8            :set textwidth=80<cr>
nnoremap <leader>ow1            :set textwidth=100<cr>
nnoremap <leader>ow2            :set textwidth=120<cr>
nnoremap <leader>ow4            :set textwidth=140<cr>

" change tab width (soft)
command! SetTabWidthTo2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2 " How many spaces a tab should be considered
command! SetTabWidthTo4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4 " How many spaces a tab should be considered
command! SetTabWidthTo8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4 " How many spaces a tab should be considered
nnoremap <leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<cr>
nnoremap <leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<cr>
nnoremap <leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<cr>

" toggle paste mode
nnoremap <leader>op :set paste! <bar> :set paste?<cr>

" autosave
command! AutoSaveDisable        :set noautowriteall<bar> let g:autosave = 0 " Don't save file automatically (globally)
command! AutoSaveEnable         :set autowriteall  <bar> let g:autosave = 1 " Save file automatically (globally)
command! AutoSaveToggle         :set autowriteall! <bar>
                                \ if !exists("g:autosave") <bar> let g:autosave = 0 <bar> endif <bar>
                                \ let g:autosave = 1 - g:autosave <bar>
                                \ echo g:autosave == 1 ?
                                \ 'Autosave enabled' :
                                \ 'Autosave disabled'

nnoremap <silent> <leader>oWA :AutoSaveToggle<cr>

" toggle search preferences
command! EnableHighlightSearch  :set hlsearch       " When there is a previous search pattern, highlight all its matches.
command! DisableHighlightSearch :set nohlsearch     " When there is a previous search pattern, don't highlight all its matches.
command! EnableWrapSearch       :set wrapscan       " Searches wrap around the end of the file.
command! DisableWrapSearch      :set nowrapscan     " Searches don't wrap around the end of the file.
nnoremap <leader>os :set hlsearch! <bar> :set hlsearch?<cr>
nnoremap <leader>oS :set wrapscan! <bar> :set wrapscan?<cr>

" ... but ignore typos
nnoremap <leader>o <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <leader>syn :ToggleSyntaxCurrentBuffer<cr>
nmap <silent> <leader>syt :TSToggle highlight<cr> " TreeSitter

" toggle syntax highlighting after g:synmaxcol characters
command! ToggleSyntaxLongLines :let &synmaxcol = g:synmaxcol - &synmaxcol " Disable or enable syntax highlighting (long lines)
nmap <silent> <leader>sym :ToggleSyntaxLongLines<cr>

" toggle line numbers
command! ToggleLineNumbers          :call WindoInRegularBuffers('set relativenumber! | set number!')    " Disable or enable line numbers
command! ToggleRelativeLineNumbers  :call WindoInRegularBuffers('set relativenumber!')                  " Disable or enable relative line numbers
nnoremap <silent> <leader>yL :ToggleLineNumbers<cr>
nnoremap <silent> <leader>yl :ToggleRelativeLineNumbers<cr>

" toggle word wrap
command! ToggleWordWrap :setlocal wrap! <bar> :set wrap? " This option changes how text is displayed. It doesn't change the text in the buffer, see 'textwidth' for that.
nnoremap <silent> <leader>yw :ToggleWordWrap <cr>

" toggle vertical ruler
command! ToggleRuler :call SetColorColumn('toggle') " toggle vertical ruler
nnoremap <silent> <leader>yr :ToggleRuler <cr>
" (quickfix ruler highlighting)
nnoremap <silent> <leader>yR :highlight ColorColumn ctermbg=235
              \ <bar> highlight clear BGdd8844
              \ <bar> highlight clear BG000000
              \ <bar> highlight clear BGffa724
              \ <bar> highlight clear BGaeee00
              \ <bar> highlight clear BG8cffba
              \ <bar> highlight clear BGb88853
              \ <bar> highlight clear BGff9eb8
              \ <bar> highlight clear BGff2c4b
              \ <cr>


" toggle highlight current cursor position
command! ToggleCursor :let g:cursorposition = 1 - g:cursorposition | normal i<esc> " toggle highlight current cursor position
nnoremap <silent> <leader>yc :ToggleCursor <cr>

" toggle show listchars (like whitespace)
command! ToggleListChars :set list! " toggle show listchars (like whitespace)
nnoremap <silent> <leader>ya :ToggleListChars <cr>


" spell checking {{{
command! ChangeSpellChecking :call ChangeSpellChecking() " Disable, enable or change spell checking
function! ChangeSpellChecking()
ec "<space>  Toggle spell checking"
ec "<e>      Set language to 'en'"
ec "<d>      Set language to 'de'"
ec ""
let c = getchar()
if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
    redraw
elseif nr2char(c) == ' ' || nr2char(c) == 'p'
    redraw
    set spell!
    redraw
elseif nr2char(c) == 'e'
    set spelllang=en
    redraw
elseif nr2char(c) == 'd'
    set spelllang=de
    redraw
endif
set spell?
endfunction
" }}}
nnoremap <leader>ysp :ChangeSpellChecking <cr>

" ... but ignore typos
nnoremap <leader>y <nop>
nnoremap <leader>ys <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{

" Now that I'm on a Moonlander where arrow keys are usable and I'm using the Norman keyboard layout, I don't want to use hjkl anymore.
" nmap h <nop>
" nmap j <nop>
" nmap k <nop>
" nmap l <nop>

" move intuitively when text is wrapped
nnoremap j      gj
nnoremap k      gk
nnoremap <down> g<down>
nnoremap <up>   g<up>

" move faster
nnoremap gj      8j
vnoremap gj      8j
nnoremap gk      8k
vnoremap gk      8k

" move faster or through quickfixlist or git hunks
nnoremap g<down> :call JumpDownSoToSpeak()<cr>
vnoremap g<down> 8j
nnoremap g<up>   :call JumpUpSoToSpeak()<cr>
vnoremap g<up>   8k

function! JumpDownSoToSpeak()
    if HasQuickfixList()
        call JumpThroughList(0, 0, 0)
    elseif g:gitguttermode == 1
        GitGutterNextHunk
        normal zz9<c-e>zv
    else
        normal 8j
    endif
endfunction

function! JumpUpSoToSpeak()
    if HasQuickfixList()
        call JumpThroughList(1, 0, 0)
    elseif g:gitguttermode == 1
        GitGutterPrevHunk
        normal zz9<c-e>zv
    else
        normal 8k
    endif
endfunction

" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <c-b>  <left>
noremap! <c-f>  <right>
noremap! <c-d>  <delete>
" ... by words
noremap! <m-b>  <s-left>
noremap! <m-f>  <s-right>
cnoremap <esc>b <s-left>
cnoremap <esc>f <s-right>


" move to BOL (beginning of line)
nnoremap <c-a> ^
" cnoremap <c-a> ^ " This is useful to complete patterns e.g. :bd foobar/<c-a>
xnoremap <c-a> ^

" TODO: FIX
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the very start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <home>
            \ col('.') == match(getline('.'),'\S')+0 ? '0' : '^'
imap <silent> <home> <c-o><home>

" move to EOL
nnoremap <c-e> $
vnoremap <c-e> $
onoremap <c-e> $
inoremap <c-e> <end>
" move to EOL with l instead of $
onoremap l $

" ... but current character movement is useful sometimes
nnoremap ch cl
nnoremap yh yl
nnoremap <c-c>h v"*ygv"+y

" swap g, and g; (jump through changelist)
nnoremap g, g;
nnoremap g; g,

" goto last edit
nnoremap <leader>. `.zzzv

" marks
nnoremap mm m
nnoremap m  `

" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{

" Search Mode and Search Direction {{{

nnoremap <silent> <leader>on :call <sid>ChangeSearchMode()<CR>
nnoremap          <leader>oN :call ToggleSearchDirection()<CR>

let g:n_always_forward = 0
let g:search_mode = 1

" Toggle search direction behavior
function! ToggleSearchDirection()
    let g:n_always_forward = !g:n_always_forward
    echo "Search direction: " . (g:n_always_forward ? "Always forward" : "Default (n/N depends)")
    call s:UpdateSearchMappings()
endfunction

" Cycle search mode
function! s:ChangeSearchMode(...)
    if !(a:0 > 0 && a:1 == 1)
        let g:search_mode = (g:search_mode + 1) % 3
    endif

    echo 'Search mode: ' . (g:search_mode == 1 ? 'scroll smartly (as few times as possible)'
                \ : g:search_mode == 2 ? 'scroll to middle'
                \ : 'normal')
    call s:UpdateSearchMappings()
endfunction

" Update n/N mappings based on mode and direction
function! s:UpdateSearchMappings()
    let l:scroll_cmd = g:search_mode == 1 ? ":call <sid>MaybeScroll()<CR>zv"
                \ : g:search_mode == 2 ? "zzzv"
                \ : "zv"

    if g:n_always_forward
        execute 'nnoremap <silent> <expr> n "Nn"[v:searchforward] . "' . l:scroll_cmd . '"'
        execute 'nnoremap <silent> <expr> N "nN"[v:searchforward] . "' . l:scroll_cmd . '"'
    else
        execute 'nnoremap <silent> n n' . l:scroll_cmd
        execute 'nnoremap <silent> N N' . l:scroll_cmd
    endif
endfunction

" If cursor is on top, scroll to bottom, if it is on bottom, scroll to top
function! s:MaybeScroll()
    if winline() == &scrolloff + 1
        normal! zb
    elseif winline() == winheight(0) - &scrolloff
        normal! zt
    endif
endfunction

" }}}

" restart search from BOF/EOF
" (is useful when 'nowrapscan' is set)
" nmap gt 1Gn
nmap g? G$N
" nmap gt :keepjumps normal 1G<cr>n " does not work
" nmap g? :keepjumps normal G$<cr>N " does not work
nmap <silent> gt :ijump! 1    /<c-r>/<cr>zv
" nmap g? :ijump! 9999 /<c-r>/<cr> " does not work

" number of occurrences
nnoremap <leader>n* *<c-o>:%s///ngg<cr>
nnoremap <leader>n/  :%s:<c-r>/::ngg<cr>
xnoremap <leader>n/ y:%s:\V<c-r>"::ngg<cr>


" search in multiple files
if s:MyMode == 'stripped'
    nnoremap <leader>/
            \ :call ToggleList("Quickfix List", 'c')<cr>
            \ :vimgrep // **/*<left><left><left><left><left><left>
endif


" 'goto definition' with viewport adjustments
nmap gd gdztzv
nmap gD gDztzv


" search across newlines
nnoremap <leader>fn :SearchMultiLine<space>


nnoremap * <nop>
nnoremap + <nop>

" find word under cursor in current buffer
nnoremap **  *zv
nnoremap ++  #zv
" find WORD under cursor in current buffer
nnoremap *w  yiW/\V<c-r>"<cr>zv
nnoremap *W  yiW/\V<c-r>"<cr>zv
nnoremap +w  yiW?\V<c-r>"<cr>zv
nnoremap +W  yiW?\V<c-r>"<cr>zv
" find word under cursor in current buffer starting at the top
nnoremap g** #gg/<c-p><cr>zv
nnoremap g++ #gg/<c-p><cr>zv
" find WORD under cursor in current buffer starting at the top
nnoremap g+w yiWgg/\V<c-r>"<cr>zv
nnoremap g+W yiWgg/\V<c-r>"<cr>zv


" find visual selection
" (i use this instead of g* and g# anyway)
xnoremap *  y/\V<c-r>"<cr>zv
xnoremap +  y?\V<c-r>"<cr>zv
xnoremap g+ ygg/\V<c-r>"<cr>zv


" find lines that are too long
nnoremap <leader>fL :exec '/\v^.{' . &textwidth . '}.'<cr>

" find trailing whitespace
nnoremap <leader>fst /\v\s+$<cr>

" find matching element (brackets/braces/parentheses)
nnoremap <leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <leader>f<leader> %

" find all lines with keyword under cursor and ask which one to jump to
nmap <leader>fj [I:let nr = input("Which one: ")
            \   <bar> exe "normal " . nr ."[\t"<cr>

" find git merge conflict markers
command! FindGitConflictMarkers /\v^[<|=>]{7}( .*|$)
nnoremap <leader>fc :FindGitConflictMarkers<cr>

" find errors and stuff
nnoremap <leader>fe /\v(error\|fail)<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is single quote (')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$"_dd

" delete line content (replacing with empty line to avoid 'Cumulative Layout Shift')
nnoremap 'dd         :.s:.*::<cr>
nnoremap 'd<down> :.,+1s:.*::<cr>
nnoremap 'dj      :.,+1s:.*::<cr>
nnoremap 'd<up>   :-1,.s:.*::<cr>
nnoremap 'dk      :-1,.s:.*::<cr>
nnoremap 'd}    :.,/^$/s:.*::<cr>
nnoremap 'd{    :?^$?,.s:.*::<cr>
vnoremap 'd           :s:.*::<cr>

" select last pasted/edited text
nnoremap gV `[v`]

" change case of word under cursor
nnoremap cC viw~

" autocompletion
inoremap <m-.>  <c-n>
inoremap <esc>. <c-n>
inoremap <m-:>  <c-p>
inoremap <esc>: <c-p>

" toggle complex completions (sometimes they are too slow)
nnoremap <leader>oc :if &complete =~ 't' <bar> set complete-=t,i <bar> else <bar> set complete+=t,i <bar> endif <bar> set complete? <cr>

" increment/decrement number
nnoremap 'i <c-a>
nnoremap 'I <c-x>


" indent lines
vnoremap < <gv
vnoremap > >gv
" indent block
nnoremap =p =ap
nnoremap =0 =ap

" change tab width (hard)
nnoremap 'rt2 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=2 <bar> :retab <cr>
nnoremap 'rt4 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=4 <bar> :retab <cr>
nnoremap 'rt8 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=8 <bar> :retab <cr>

" yank line with Enter (i do that so often)
" CANNOT MAP THIS BECAUSE OF SPECIAL PLUGIN BUFFERS AND STUFF
" nnoremap <enter> yy

" " autoformat with enter in normal buffers
" augroup map_enter_autoformat
"     au!
"     au BufReadPost *
"                 \ if ! strchars(&buftype) |
"                 \   nnoremap <buffer> <enter> gqap |
"                 \   vnoremap <buffer> <enter> gq |
"                 \ endif
" augroup END

" move line up or down
" (:m closes folds https://groups.google.com/forum/#!topic/vim_dev/QGgbjv4uyZc)
nnoremap <silent> '<down>   :set fdm=manual<cr>:m .+1<cr>:set fdm=marker<cr>
vnoremap <silent> '<down>   <esc>:set fdm=manual<cr>gv:m '>+1<cr>gv=gv:set fdm=marker<cr>
nnoremap <silent> '<up>     :set fdm=manual<cr>:m .-2<cr>:set fdm=marker<cr>
vnoremap <silent> '<up>     <esc>:set fdm=manual<cr>gv:m '<-2<cr>gv=gv:set fdm=marker<cr>
nnoremap <silent> 'j        :set fdm=manual<cr>:m .+1<cr>:set fdm=marker<cr>
vnoremap <silent> 'j        <esc>:set fdm=manual<cr>gv:m '>+1<cr>gv=gv:set fdm=marker<cr>
nnoremap <silent> 'k        :set fdm=manual<cr>:m .-2<cr>:set fdm=marker<cr>
vnoremap <silent> 'k        <esc>:set fdm=manual<cr>gv:m '<-2<cr>gv=gv:set fdm=marker<cr>

" join line TO the one below
nnoremap 'J ddpkJ

" split line (opposite of join line)
" (regular 'S' can be done with 'cc' instead)
nnoremap <leader><cr> i<cr><esc>
            \ ^mq
            \ :let searchregister=@/<cr>
            \ :silent! .-1s/\v +$//<cr>:nohlsearch<cr>
            \ :let @/=searchregister<cr>
            \ `q

" duplicate code
nnoremap 'uu yyp
nnoremap 'ul yyp
nnoremap 'up yap<s-}>p
vnoremap 'u yP

" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <m-o>  <esc>o<esc>k
"noremap <esc>o <esc>o<esc>k
"noremap <m-o>  <esc>O<esc>j
"noremap <esc>O <esc>O<esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k

" align next column in duplicated line when i don't use replace mode
" (very bad implementation)
nnoremap 'li kWjdwgE

" add space (one newline) below
" TODO: fix that mini.comment adds commentstrings, I don't want that
nnoremap <a-o> o<esc>k

" add space (a few newlines) below
"nnoremap <enter> :.+1insert \n\n\n<cr>
nnoremap 'as mno<esc>o<esc>o<esc>o<esc>`n

" add a line of characters
nnoremap 'al :call InsertCharLine(InputNChars(1, "Insert character: "), 80)<cr>
" add a box of characters ('comment box')
nnoremap 'ab :call InsertCharBox(InputNChars(1, "Insert character: "))<cr>
" add a line of characters below, just as long as the current line
nnoremap 'au- yyp^v$r-
nnoremap 'au= yyp^v$r=
nnoremap 'au# yyp^v$r#

" enter substitution mode quickly
nnoremap <c-s><c-s> :%s::c<left><left>


" in visual mode, use 's' for substitution
" (to change only a single occurence, use 'c'. by default they are the same)

" substitute occurrences of selection in this buffer (beginning from the top)
vmap     <c-s><c-s>     <c-s><c-s>
vnoremap <c-s>s         yms:%s`\V\C<c-r>"`<c-r>"`c<bar>norm!`s <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap <c-s>k         yms:%s`\V\C\<<c-r>"\>`<c-r>"`c<bar>norm!`s <left><left><left><left><left><left><left><left><left><left><left>

" substitute occurrences of selection in this buffer - beginning from current line (continue from top once bottom reached)
vnoremap ss             yms:,$s`\V\C<c-r>"`<c-r>"`c<bar>norm!`s <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap sk             yms:,$s`\V\C\<<c-r>"\>`<c-r>"`c<bar>norm!`s <left><left><left><left><left><left><left><left><left><left><left>

" " (these are actually two substitutions, so that we start at the current line
" " but continue from the first. source: http://stackoverflow.com/a/7608016)
" vnoremap ss            yms:,$s:\V\C<c-r>":<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>
" " the same, but with keyword matching
" vnoremap sk    yms:,$s:\V\C\<<c-r>"\>:<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>

" substitute text objects or word under cursor
nmap <c-s>iw viw<c-s>s
nmap <c-s>iW viW<c-s>s
nmap <c-s>w  viw<c-s>s
nmap <c-s>W  viW<c-s>s

" substitute word under cursor in multiple files (add them with ':arg **' before)
" (instead of using the far plugin)
nnoremap <c-s>a :call Replace(0, input('Replace '.expand('<cword>').' with: '))<cr>
" ... and then ':wa'

" substitute last search
nmap <c-s>/ gggn<c-s>


" sort lines
nnoremap 'o vip:sort<cr>
vnoremap 'o :sort<cr>

" reverse: revert order of lines in selection/paragraph
nnoremap 'O vip:!tac<cr>
vnoremap 'O :!tac<cr>

" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap 'tu      blguee
inoremap 'tu <esc>blgueea

" fix namespace for Clojure autocompletion
nnoremap 'tn      F/dF/e
inoremap 'tn <esc>F/dF/ea


if s:MyMode == 'stripped'
    " delete trailing whitespace for selected line
    vnoremap <silent> 'dst <esc>:.s:\v\s+$::<cr>
    " delete trailing whitespace for whole buffer
    nnoremap <silent> 'dst :%s:\v\s+$::<cr>
endif

" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> 'dsl :s:^\s\+::<cr>
" replace double/multiple spaces with one space
" TODO: make this repeatable with .
nnoremap <silent> 'dsd :.s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> 'dsD :%s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> 'dsm :.s:\v(\S) {2,}(\S):\1 \2:<cr>
nnoremap <silent> 'dsM :.s:\v(\S) {2,}(\S):\1 \2:<cr>

" delete whitespace before and after parentheses/brackets/braces in current line
" poor-man's auto formatting for current line, but without relying on plugins and language-agnostic
" TODO: make this repeatable with .
" e.g.    "foo ( bar: [ Int ] ) ( implicit x: X ) : { 42 }"
" becomes "foo (bar: [Int]) (implicit x: X) : {42}"
command! DeleteWhitespaceAroundParentheses :call DeleteWhitespaceAroundParentheses()
function! DeleteWhitespaceAroundParentheses()
    silent! .s:( :(:
    silent! .s: ):):
    silent! .s:\[ :[:
    silent! .s: \]:]:
    silent! .s:{ :{:
    silent! .s: }:}:
endfunction

nnoremap 'dsp :DeleteWhitespaceAroundParentheses<cr>

" convert a vim plugin github url into appropriate format for vim-plug
nnoremap 'pi :.s:\m.*http.*github\.com/\([^/]*/[^/]*\).*:Plug '\1':<cr>

" open plugin under cursor on Github
" better use gx-extended plugin for that!
command! OpenVimPlugOnInGithub :call OpenVimPlugOnInGithub()
function! OpenVimPlugOnInGithub()
    let l:line = getline(".")
    let l:plugin_identifier = matchstr(l:line, "\\m.*Plug '\\zs.\\+/.\\+\\ze'.*")
    if !empty(l:plugin_identifier)
        call system('xdg-open https://github.com/' . l:plugin_identifier)
    " else
        " normal! gx " TODO: fix (the ! is the problem)
    else
        echo "Sorry, this does not look like a line with a plugin name."
    endif
endfunction

augroup open_vim_plugins_on_github
    autocmd!
    autocmd BufRead vimrc nnoremap <buffer> <leader>px :call OpenVimPlugOnInGithub()<cr>
    " autocmd BufRead vimrc nnoremap <buffer>         gx :call OpenVimPlugOnInGithub()<cr>
augroup END


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <leader>ch :call ToggleHTMLComment("n")<cr>
vnoremap <silent> <leader>ch :call ToggleHTMLComment("v")<cr>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <leader>cd yyI#<esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <m-u>   :earlier<cr>
noremap <esc>u  :earlier<cr>
noremap <m-s-u> :later<cr>
noremap <esc>U  :later<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{

" compare open windows
nnoremap <leader>dt :windo diffthis<cr>
nnoremap <leader>do :windo diffoff<cr>

" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RUNNING COMMANDS, BUILDING, MAKING AND DEBUGGING {{{

command! SetRunCommandMethodBasedOnFiletype :call SetRunCommandMethodBasedOnFiletype()
function! SetRunCommandMethodBasedOnFiletype()
    let l:filetypes_for_output_window = ['typescript', 'clojure', 'scala']
    if index(l:filetypes_for_output_window, &ft) >= 0
        let g:run_command_method = "output-window"
    elseif has('nvim')
        let g:run_command_method = "terminal-buffer"
    else
        let g:run_command_method = "vimux"
    endif
    RefreshRunCommandMappings
endfunction

command! SetRunCommandMethodBasedOnFiletypeIfNotSet :call SetRunCommandMethodBasedOnFiletypeIfNotSet()
function! SetRunCommandMethodBasedOnFiletypeIfNotSet()
    if !exists('g:run_command_method')
        SetRunCommandMethodBasedOnFiletype
    endif
endfunction

augroup augroup_SetRunCommandMethodBasedOnFiletypeIfNotSet
    au!
    au BufReadPost * SetRunCommandMethodBasedOnFiletypeIfNotSet
augroup END

function! ToggleRunCommandMethod()
    if !exists('g:run_command_method') || g:run_command_method == "output-window"
        echo 'Set running method to `terminal-buffer`'
        let g:run_command_method = "terminal-buffer"
        RefreshRunCommandMappings
    elseif g:run_command_method == "terminal-buffer"
        echo 'Set running method to `vimux`'
        let g:run_command_method = "vimux"
        RefreshRunCommandMappings
    else
        echo 'Set running method to `output-window`'
        let g:run_command_method = "output-window"
        RefreshRunCommandMappings
    endif
endfunction

command! -nargs=1 -complete=file RunCommandInTerminal :call RunCommandInTerminal(<q-args>)
function! RunCommandInTerminal(commandline)
    let g:last_terminal_command = a:commandline
    if g:run_command_method == "terminal-buffer"
        call ExecuteInNeoTerminal(a:commandline)
    elseif g:run_command_method == "output-window"
        call jobstart('alacritty --title "Output" --hold --command fish -c "' . a:commandline . '"')
    else
      echoerr "Unknown g:run_command_method (" . g:run_command_method . ")"
    endif
endfunction

function! RunLastCommandInTerminal()
    if exists('g:last_terminal_command')
        execute 'RunCommandInTerminal ' . escape(g:last_terminal_command, '\\')
    else
        echoerr "No last command found!"
    endif
endfunction

function! GetBuildOutputFilename()
    if !empty(v:servername)
        let l:project_name = tolower(v:servername)
    else
        let l:project_name = system('basename "$(pwd)" | tr -d "\n"')
    endif
    let l:project_name = tolower(substitute(l:project_name, "[ /]", "_", "g"))
    " let l:git_branch_name = system('git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d "\n" || echo -n ""')
    " let l:git_branch_name_escaped = substitute(UrlEncode(l:git_branch_name), '%..', '-', 'g')
    let l:build_output_file = '/tmp/vim.' . l:project_name . '.make.out'
    return l:build_output_file
endfunction

function! IsBuildShellRunning()
    SetRunCommandMethodBasedOnFiletypeIfNotSet
    if g:run_command_method == "terminal-buffer"
        let l:terminal_bufnum = GetTerminalBuffer()
        return l:terminal_bufnum > 0
    elseif g:run_command_method == "vimux"
        " TODO: make this work for other shells
        return exists('g:build_shell') && match(g:build_shell, 'sbt') == 0
                    \ && IsSbtRunning()
    elseif g:run_command_method == "output-window"
        call system("i3-msg -t get_workspaces | tr , '\\n' | grep -q '\"name\":\"Output\"'")
        return !v:shell_error
    else
        return 0
    endif
endfunction

" open up build shell if not already opened before executing commandline
command! -nargs=1 RunCommandInBuildShell :call RunCommandInBuildShell(<q-args>)
function! RunCommandInBuildShell(command)
    let l:build_output_file = GetBuildOutputFilename()
    if !IsBuildShellRunning() && exists('g:build_shell') && strlen(g:build_shell) > 0
        let l:neoterm_autoinsert = g:neoterm_autoinsert
        let g:neoterm_autoinsert = 0
        let l:shell_cmd = g:build_shell . " | tee (tty) > " . l:build_output_file
        call RunCommand(l:shell_cmd)
        let g:neoterm_autoinsert = l:neoterm_autoinsert
        let l:commandline = a:command
    else
        let l:commandline = a:command . " | tee (tty) > " . l:build_output_file
    endif
    call RunCommand(l:commandline)
endfunction

command! -nargs=1 RunCommand :call RunCommand(<q-args>)
function! RunCommand(command)
    SetRunCommandMethodBasedOnFiletypeIfNotSet
    if g:run_command_method == "vimux"
        call VimuxRunCommand(a:command)
    else
        call RunCommandInTerminal(a:command)
    endif
endfunction


" old-school make
nnoremap <leader>bm :make<cr>

" run custom build script if present
nnoremap <leader>bd :call RunCommand(FindCustomBuildScript())<cr>
function! FindCustomBuildScript()
    let l:filenames = ["./make.sh", "./build.sh", "../build.sh"]
    for file in l:filenames
        if filereadable(file)
            return file
        endif
    endfor
    throw "No build script found."
endfunction

" change how commands are run
nnoremap <leader>or :call ToggleRunCommandMethod()<cr>

" type command to run
nnoremap <leader>to :RunCommandInTerminal<space>

" run current line or selection as shell command
nnoremap <leader>bss :call RunCommand(getline('.'))<cr>
vnoremap <leader>bss y:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>gv
nnoremap <leader>bsp yip:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>bsw yiw:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>b'  yi':call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>b"  yi":call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>b`  yi`:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>bsb yi(:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>b(  yi(:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>
nnoremap <leader>b)  yi(:call RunCommand(substitute(@", "\n", "\r", "g"))<cr>

" inspect built errors somewhere
nnoremap <silent> <leader>bee :OpenBuildErrorsInQuickfixList<cr><esc>hj
nnoremap <silent> <leader>beo :OpenBuildErrorsInBuffer<cr><esc>hj
nnoremap <silent> <leader>bex :WebSearchForBuildError<cr>

command! RefreshRunCommandMappings :call RefreshRunCommandMappings()
function! RefreshRunCommandMappings()
    if g:run_command_method == "terminal-buffer"
        nnoremap <leader>bo         :RunCommandInBuildShell<space>
        nnoremap <leader>bf         :execute 'RunCommandInTerminal  ' . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
        nnoremap <leader>bF         :execute 'RunCommandInTerminal ' . ExpandPrependThisDir('%') . ' '<left>
        nnoremap <leader>bb         :update<cr> :call RunLastCommandInTerminal()<cr>
        nnoremap <leader>b<c-l>     :ExecuteInNeoTerminal Tclear<cr>
        nnoremap <leader>b<c-c>     :ExecuteInNeoTerminal Tkill<cr>
        nnoremap <leader>bq         :Tclose<cr>         " only hides buffer, we can still send commands to it
        nnoremap <leader>b<bs>      :Tclose<cr>         " only hides buffer, we can still send commands to it
    elseif g:run_command_method == "output-window"
        nnoremap <leader>bo         :RunCommandInBuildShell<space>
        nnoremap <leader>bf         :execute 'RunCommandInTerminal  ' . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
        nnoremap <leader>bF         :execute 'RunCommandInTerminal ' . ExpandPrependThisDir('%') . ' '<left>
        nnoremap <leader>bb         :update<cr> :call RunLastCommandInTerminal()<cr>
        nnoremap <leader>b<c-l>     :echoerr "Not implemented"<cr>
        nnoremap <leader>b<c-c>     :echoerr "Not implemented"<cr>
        nnoremap <leader>bq         :echoerr "Not implemented"<cr>
        nnoremap <leader>b<bs>      :echoerr "Not implemented"<cr>
    elseif g:run_command_method == "vimux"
        nnoremap <leader>bo         :VimuxRunCommand ""<left>
        nnoremap <leader>bf         :VimuxRunCommand " " . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
        nnoremap <leader>bF         :VimuxRunCommand ExpandPrependThisDir('%') . " "<left>
        nnoremap <leader>bb         :update<cr>:VimuxRunLastCommand<cr>
        nnoremap <silent> <leader>b<c-l> :VimuxClearTerminalScreen<cr>
        nnoremap <leader>b<c-c>     :VimuxInterruptRunner<cr>
        nnoremap <leader>b<c-d>     :call VimuxSendKeys("C-d")<cr>
        nnoremap <leader>bz         :call VimuxZoomRunner()<cr>
        nnoremap <leader>b<c-b>     :VimuxInspectRunner<cr>
        nnoremap <leader><c-b><c-b> :VimuxInspectRunner<cr>
        nnoremap <leader>bq         :VimuxCloseRunner<cr>
        nnoremap <leader>b<bs>      :VimuxCloseRunner<cr>
    else
        echoerr "Unknown g:run_command_method (" . g:run_command_method . ")"
    endif
endfunction

function! RemoveEscapeSequencesFromFile(filename)
    " color escape sequences
    exec ':silent !sed -i -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" ' . a:filename
    exec ':silent !sed -i -r "s/\\x1b\\[[0-9;]*[a-zA-Z]//g" ' . a:filename
    " magic control sequences
    exec ':silent !sed -i -r "s/[\\x01-\\x1F\\x7F]//g" ' . a:filename
    exec ':silent !sed -i -r "s/[\\x?1-\\x1F\\x7F]//g" ' . a:filename
    " weird sbt shell sequences
    exec ':silent !sed -i -r "s/\[\?1h=\[\?2004h//g" ' . a:filename
endfunction

" copy the build output file content to a new vim error file (of the last run)
function! PrepareErrorFile(errorfile)
    " let l:terminal_bufnum = GetTerminalBuffer()
    " if l:terminal_bufnum == 0
    "     echoerr 'No terminal buffer found.'
    "     return
    " let l:lines = getbufline(l:terminal_bufnum, 1, '$')
    "
    " " Unfortunately, the terminal (or more specifically libvterm) inserts hard
    " " linebreaks when the width of the terminal window is reached, so it's
    " " hardly usable for parsing build output.
    " " See https://github.com/neovim/neovim/issues/2514
    " " So I use the tee to build output file solution instead:
    "
    let l:build_output_file = GetBuildOutputFilename()
    let l:lines = readfile(l:build_output_file)

    call writefile(l:lines, a:errorfile)
    call RemoveEscapeSequencesFromFile(a:errorfile)
    let l:lines = readfile(a:errorfile)

    let l:last_prompt_line = 1
    if exists('g:prompt_regex')
        for i in range(len(l:lines) - 2 , 1, -1)
            if match(l:lines[i], g:prompt_regex) == 0
                let l:last_prompt_line = i
                break
            endif
        endfor
    endif
    if l:last_prompt_line != 1
        call writefile(l:lines[l:last_prompt_line:], a:errorfile)
    endif
endfunction

" open quickfix list with build errors from the terminal
command! OpenBuildErrorsInQuickfixList :call OpenBuildErrorsInQuickfixList()
function! OpenBuildErrorsInQuickfixList()
    let l:errorfile = '/tmp/vim.errorfile.txt'
    call PrepareErrorFile(l:errorfile)
    cclose
    exe 'cfile' . l:errorfile
    if len(getqflist()) > 0
        let g:jumplist = 'quickfixlist'
        bot copen
        cfirst
    else
        echomsg "No build errors."
    endif
endfunction

command! OpenBuildErrorsInBuffer :call OpenBuildErrorsInBuffer()
function! OpenBuildErrorsInBuffer()
    " let l:build_output_file = GetBuildOutputFilename()
    " execute "edit " . l:build_output_file
    let l:errorfile = '/tmp/vim.errorfile.txt'
    call PrepareErrorFile(l:errorfile)
    execute "edit " . l:errorfile
endfunction

command! WebSearchForBuildError :call WebSearchForBuildError()
function! WebSearchForBuildError()
    let l:errorfile = '/tmp/vim.errorfile.txt'
    call PrepareErrorFile(l:errorfile)
    let l:lines = readfile(l:errorfile)
    let l:errorpattern = '\m^\[error\] .\+: \zs.*\ze' " only for Scala/sbt
    for i in range(0, len(l:lines) - 1)
        let l:error = matchstr(l:lines[i], l:errorpattern)
        if len(l:error) > 0
            break
        endif
    endfor
    if len(l:error) > 0
        echo "Searching the web for error: " . l:error
        call WebSearch(l:error)
    else
        echomsg "No build errors."
    endif
endfunction


command! -nargs=1 WebSearch :call WebSearch(<q-args>)
function! WebSearch(query)
    call system("$BROWSER 'https://google.com/search?q=" . UrlEncode(a:query) . "'")
endfunction

" search the web for selection
vnoremap <leader>ws y:call WebSearch(@")<cr>gv


" execute shell script
command! ExecuteShellscript :call ExecuteShellscript() " Execute shellscript (current file) in a new tmux pane
function! ExecuteShellscript()
    call system('test -x ' . expand('%'))
    if v:shell_error
        call system('chmod +x ' . expand('%'))
    endif
    if s:MyMode == 'mastery'
        call RunCommand(ExpandPrependThisDir("%"))
    else
        exec '!' . ExpandPrependThisDir('%')
    endif
endfunction
augroup shellscript_on_read
    au!
    au FileType sh      call SetupShellscript()
    au FileType fish    call SetupShellscript()
augroup END
function! SetupShellscript()
    nnoremap <leader>br :call ExecuteShellscript()<cr>
endfunction


" jump to (syntastic) errors
command! JumpToFirstSyntaxError :lfirst
command! JumpToLastSyntaxError  :llast
nnoremap <leader>sg :lfirst<cr>
nnoremap <leader>sG :llast<cr>
" nnoremap <leader>sn :lnext<cr>
" nnoremap <leader>sN :lprevious<cr>

" jump through both, quickfix and location list, with the same keys
" @param direction: 0 for next, 1 for previous
" @param perFile: 0 for jumping per occurence, 1 for jumping per file
" @param switch: 0 for the same list as before, 1 for the other
let g:jumplist = 'quickfixlist'
function! JumpThroughList(direction, perFile, switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (g:jumplist == 'locationlist')
        if (a:perFile == 0)
            if (a:direction == 0)
                silent! lnext
            else
                silent! lprevious
            endif
        else
            if (a:direction == 0)
                silent! lnfile
            else
                silent! lpfile
            endif
        endif
    else
        if (a:perFile == 0)
            if (a:direction == 0)
                silent! cnext
            else
                silent! cprevious
            endif
        else
            if (a:direction == 0)
                silent! cnfile
            else
                silent! cpfile
            endif
        endif
    endif
endfunction

" jump to first result of quickfix and location list, with the same keys
" @param switch: 0 for the same list as before, 1 for the other
function! JumpToFirstInList(switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (g:jumplist == 'locationlist')
        lfirst
    else
        cfirst
    endif
endfunction

" jump to last result of quickfix and location list, with the same keys
" @param switch: 0 for the same list as before, 1 for the other
function! JumpToLastInList(switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (g:jumplist == 'locationlist')
        llast
    else
        clast
    endif
endfunction

" first/last result in list
nnoremap <silent> <leader>kgg        :call JumpToFirstInList(0)<cr>
nnoremap <silent> <leader>kG         :call JumpToLastInList(0)<cr>
" first/last result in other list
nnoremap <silent> <leader>kkgg       :call JumpToFirstInList(1)<cr>
nnoremap <silent> <leader>kkG        :call JumpToLastInList(1)<cr>
" next/previous result in list
nnoremap <silent> <leader>kn         :call JumpThroughList(0, 0, 0)<cr>
nnoremap <silent> <leader>k<down>    :call JumpThroughList(0, 0, 0)<cr>
nnoremap <silent> <leader>kN         :call JumpThroughList(1, 0, 0)<cr>
nnoremap <silent> <leader>k<up>      :call JumpThroughList(1, 0, 0)<cr>
" next/previous result in next file in list
nnoremap <silent> <leader>kgn        :call JumpThroughList(0, 1, 0)<cr>
nnoremap <silent> <leader>kg<down>   :call JumpThroughList(0, 1, 0)<cr>
nnoremap <silent> <leader>kgN        :call JumpThroughList(1, 1, 0)<cr>
nnoremap <silent> <leader>kg<up>     :call JumpThroughList(1, 1, 0)<cr>
" next/previous result in other list
nnoremap <silent> <leader>kkn        :call JumpThroughList(0, 0, 1)<cr>
nnoremap <silent> <leader>kk<down>   :call JumpThroughList(0, 0, 1)<cr>
nnoremap <silent> <leader>kkN        :call JumpThroughList(1, 0, 1)<cr>
nnoremap <silent> <leader>kk<up>     :call JumpThroughList(1, 0, 1)<cr>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <leader>sl :lclose<bar>:cclose<cr>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <leader>sL :lopen<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS, WINDOWS AND TABS {{{

" open new file in /tmp
nnoremap <leader>en :exe "e" . system("mktemp $HOME/tmp/XXXXX.txt")<cr>
nnoremap <leader>eN :exe "e" . system("mktemp /tmp/XXXXX.txt")<cr>

" change or open new buffer by searching for file name
if s:MyMode == 'stripped'
    nnoremap <leader><leader>      :buffers<cr>:buffer<space>
    vnoremap <leader><leader> <esc>:buffers<cr>:buffer<space>
    nnoremap <leader>fi :find<space>
endif

" change to LRU buffer
nnoremap <leader>e<leader> :buffer #<cr>
nnoremap <leader><tab>     :buffer #<cr>

" navigate through buffers
nnoremap <m-n>  :bnext<cr>
nnoremap <esc>n :bnext<cr>
nnoremap <m-p>  :bprevious<cr>
nnoremap <esc>p :bprevious<cr>

"" change window - via directions
" NOTE that I use vim-tmux-navigator now (CTRL-<arrow>)
" TODO: now that <leader><arrow> mappings are free, I could use them for jumping quickfixlist/LSP errors etc.
"nnoremap <silent> <leader><right>      :wincmd l<cr>
"vnoremap <silent> <leader><right> <c-c>:wincmd l<cr>
"nnoremap <silent> <leader><left>       :wincmd h<cr>
"vnoremap <silent> <leader><left>  <c-c>:wincmd h<cr>
"nnoremap <silent> <leader><down>       :wincmd j<cr>
"vnoremap <silent> <leader><down>  <c-c>:wincmd j<cr>
"nnoremap <silent> <leader><up>         :wincmd k<cr>
"vnoremap <silent> <leader><up>    <c-c>:wincmd k<cr>

" change window - last recently used
nnoremap <silent> <c-y><c-l>           :wincmd p<cr>
vnoremap <silent> <c-y><c-l>      <c-c>:wincmd p<cr>
inoremap <silent> <c-y><c-l>      <esc>:wincmd p<cr>

" move buffer to a new window
nnoremap <silent> <leader><c-l> :vsplit<cr><c-w>p:buffer #<cr><c-w>p<cr>
nnoremap <silent> <leader><c-s> :vertical split<cr>

" swap/rotate windows
nnoremap <silent> <c-w>> <c-w>r
nnoremap <silent> <c-w>< <c-w>R

" resize windows to equal size, even when in terminal
nnoremap <silent> <c-y>=           <c-w>=
tnoremap <silent> <c-y>= <c-\><c-n><c-w>=

" resize window mode
nnoremap <silent> <c-w>r     :ResizeWindows<cr>
nnoremap <silent> <c-w><c-r> :ResizeWindows<cr>
command! ResizeWindows  :call ResizeWindows('enter') " Open a mode to resize windows with h,j,k,l
function! ResizeWindows(enter_or_leave)
    " TODO: save and restore existing mappings without redefining / unmapping here
    if a:enter_or_leave == "enter"
        nnoremap <return> :call ResizeWindows('leave')<cr>
        nnoremap <esc>    :call ResizeWindows('leave')<cr>
        nnoremap <c-c>    :call ResizeWindows('leave')<cr>
        nnoremap <silent> j         :resize -2<cr>
        nnoremap <silent> <down>    :resize -2<cr>
        nnoremap <silent> k         :resize +2<cr>
        nnoremap <silent> <up>      :resize +2<cr>
        nnoremap <silent> h         2<c-w><
        nnoremap <silent> <left>    2<c-w><
        nnoremap <silent> l         2<c-w>>
        nnoremap <silent> <right>   2<c-w>>
        AirlineIndicateCustomMode RESIZE MODE
        echo "[RESIZE MODE] (press h,j,k,l or arrow keys to resize and <enter> or <esc> to leave move)"
    else
        nnoremap    j       gj
        nnoremap    k       gk
        nunmap      h
        nunmap      l
        nnoremap    <down>  g<down>
        nnoremap    <up>    g<up>
        nunmap      <left>
        nunmap      <right>
        nunmap      <return>
        nunmap      <esc>
        nunmap      <c-c>
        echo "Windows resized."
        AirlineResetCustomMode
    endif
endfunction

" clear windows (close quickfix and location list) and refresh screen
" TODO: add <Plug>(coc-float-hide)
" TODO: unmap <cr>
nnoremap <silent> <bs> :nohlsearch \| :lclose \| :cclose \| :redraw! \| :DisableGitGutterMode <cr> :<c-c>
xmap     <silent> <bs> <bs>gv

" toggle quickfix or location list
nnoremap <silent> <leader>tq :call ToggleList("Quickfix List", 'c')<cr>
nnoremap <silent> <leader>tl :call ToggleList("Location List", 'l')<cr>

" TODO:
" Normally the quickfix window is at the bottom of the screen.  If there are
" vertical splits, it's at the bottom of the rightmost column of windows.  To
" make it always occupy the full width: >
" :botright cwindow


" I can use <c-y> as a mapping prefix for tab-related things, because I mostly
" use tabs for terminal buffers and I don't really use <c-y> as terminal
" suspend *or* as vim per-line scrolling, so it works everywhere.

" create tab
nnoremap <c-y><c-t>           :NewTab<cr>
nnoremap <c-y>t               :NewTab<cr>
tnoremap <c-y><c-t> <c-\><c-n>:NewTab<cr>
tnoremap <c-y>t     <c-\><c-n>:NewTab<cr>

" open current buffer in a new tab
nnoremap <leader><c-t>        :tab split<cr>
nnoremap <c-y>!               :tab split<cr>
tnoremap <c-y>!     <c-\><c-n>:tab split<cr>i

" close tab
nnoremap <c-y>q               :CloseTab<cr>
nnoremap <c-y><c-w>           :CloseTab<cr>
nnoremap <c-y><bs>            :CloseTab<cr>
tnoremap <c-y>q     <c-\><c-n>:CloseTab<cr>
tnoremap <c-y><c-w> <c-\><c-n>:CloseTab<cr>
tnoremap <c-y><bs>  <c-\><c-n>:CloseTab<cr>

" change tab
command! ChangeTabInteractively :call ChangeTabInteractively()
function! ChangeTabInteractively()
    tabs
    let l:input = InputNChars(1, 'Switch to tab number? ')
    if !empty(gettabinfo(l:input))
        exe ':tabn ' . l:input
    endif
    redraw " only so I don't have to hit <cr> one more time
endfunction
nnoremap <c-y><tab>               :ChangeTabInteractively<cr>
tnoremap <c-y><tab>     <c-\><c-n>:ChangeTabInteractively<cr>
nnoremap <c-y><space>             g<tab>
tnoremap <c-y><space>   <c-\><c-n>g<tab>
nnoremap <c-y><c-n>           :tabnext<cr>
nnoremap <c-y>n               :tabnext<cr>
tnoremap <c-y><c-n> <c-\><c-n>:tabnext<cr>
tnoremap <c-y>n     <c-\><c-n>:tabnext<cr>
nnoremap <c-y><c-p>           :tabprevious<cr>
nnoremap <c-y>p               :tabprevious<cr>
tnoremap <c-y><c-p> <c-\><c-n>:tabprevious<cr>
tnoremap <c-y>p     <c-\><c-n>:tabprevious<cr>
nnoremap <c-y>1               :tabn 1<cr>
tnoremap <c-y>1     <c-\><c-n>:tabn 1<cr>
nnoremap <c-y>2               :tabn 2<cr>
tnoremap <c-y>2     <c-\><c-n>:tabn 2<cr>
nnoremap <c-y>3               :tabn 3<cr>
tnoremap <c-y>3     <c-\><c-n>:tabn 3<cr>
nnoremap <c-y>4               :tabn 4<cr>
tnoremap <c-y>4     <c-\><c-n>:tabn 4<cr>
nnoremap <c-y>5               :tabn 5<cr>
tnoremap <c-y>5     <c-\><c-n>:tabn 5<cr>
nnoremap <c-y>6               :tabn 6<cr>
tnoremap <c-y>6     <c-\><c-n>:tabn 6<cr>
nnoremap <c-y>7               :tabn 7<cr>
tnoremap <c-y>7     <c-\><c-n>:tabn 7<cr>
nnoremap <c-y>8               :tabn 8<cr>
tnoremap <c-y>8     <c-\><c-n>:tabn 8<cr>
nnoremap <c-y>9               :tabn $<cr>
tnoremap <c-y>9     <c-\><c-n>:tabn $<cr>

" ... but ignore typos
tnoremap <c-y> <nop>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" builtin file explorer (netrw) {{{
" (who needs NERDTree anyway)

let g:netrw_liststyle = 3
let g:netrw_winsize = 20
let g:netrw_banner = 0
let g:netrw_browse_split = 4


function! ToggleNetRW(from_current_file)
    if exists("g:netrw_buffer") && bufexists(g:netrw_buffer)
        exe "bd".g:netrw_buffer | unlet g:netrw_buffer
    else
        if (a:from_current_file == 1)
            exe 'Lexplore ' . expand('%:p:h') | let g:netrw_buffer=bufnr("%")
        else
            Lexplore | let g:netrw_buffer=bufnr("%")
        endif
    endif
endfunction

command! ToggleFileBrowserFromCurrentFile :call ToggleNetRW(1) " Open (or close) netrw in side bar (current file)
command! ToggleFileBrowserFromProjectDir  :call ToggleNetRW(0) " Open (or close) netrw in side bar (project root)
nnoremap <silent> <leader>te :ToggleFileBrowserFromCurrentFile<cr>
nnoremap <silent> <leader>tE :ToggleFileBrowserFromProjectDir<cr>


augroup netrw_autocmds
    autocmd!
    autocmd filetype netrw call NetrwMappings()
    autocmd filetype netrw setlocal bufhidden=wipe
augroup END

function! NetrwMappings()
    silent! nunmap <buffer> qL
    silent! nunmap <buffer> qF
    silent! nunmap <buffer> qf
    silent! nunmap <buffer> qb
    silent! nunmap <buffer> q
    silent! nunmap <buffer> <c-l>
    nnoremap <buffer> q   :bd<cr>
    nnoremap <buffer> h   :help netrw-quickmap<cr>
    nmap     <buffer> .   gh
    nmap     <buffer> u   -
    " TODO: nnoremap u or locally unmap all - bindings to prevent odd bugs
    nmap     <buffer> af  %
    nmap     <buffer> ad  d
endfunction



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{

" search the web with selection
" TODO: escape and combine with WebSearch()
vnoremap <leader>isl :<c-w>!$BROWSER 'https://dict.leo.org/ende/?lang=en&search=<c-r>*'<cr><cr>
vnoremap <leader>isd :<c-w>!$BROWSER 'https://duckduckgo.com/?q=<c-r>*'<cr><cr>
vnoremap <leader>isg :<c-w>!$BROWSER 'https://google.com/?q=<c-r>*'<cr><cr>

" shell in working dir or dir of current file
nnoremap <leader>if :Shell fish<cr>
nnoremap <leader>iF :call Shell('cd ' . expand('%:p:h') . '; fish')<cr>
nnoremap <leader>ib :Shell bash<cr>
nnoremap <leader>iB :call Shell('cd ' . expand('%:p:h') . '; bash')<cr>

" file manager in working dir or dir of current file
" nnoremap <leader>ir :call RunCommand("ranger")<cr>
" nnoremap <leader>ir :exe "!ranger " . shellescape(expand("%p:h"))

" tig - an ncurses git interface
function! Tig(from_current_file)
    if (a:from_current_file)
        let l:command = 'cd "' . expand('%:p:h') . '"; tig status'
        let l:command = 'fish -c ''' . l:command . ''''
        " execute 'Shell fish -c ''' . l:command . ''''
    else
        let l:command = 'tig status'
    endif
    if exists("g:neovide") || !exists("$TMUX")
        call RunCommandInTerminal(l:command)
    else
        call VimuxRunCommand(l:command)
        call VimuxZoomRunner()
    endif
endfunction
command! TigFromWorkingDir  :call Tig(0) " Interactive Git interface (from working directory)
command! TigFromCurrentFile :call Tig(1) " Interactive Git interface (from current file)
nnoremap <leader>it :TigFromWorkingDir<cr>
nnoremap <leader>iT :TigFromCurrentFile<cr>


" Translate word to German via Google Translate CLI
function! Translate(word) abort
    let target_language = 'de'
    let result = system('trans :' . target_language . ' "' . a:word . '"')
    let result = substitute(result, '\e\[[0-9]*m', '', 'g') " remove formatting escape sequences
    " if has('nvim')
    "     call ShowMessageInFloatingWindow(result)
    " else
        echo result
    " endif
endfunction
command! Translate :call Translate(expand("<cword>")) " Translate word under Cursor
nnoremap <leader>tr :echo Translate(expand("<cword>"))<cr>


" insert google contacts with name and mail addresses (with goobook)
command! -nargs=1 InsertGoogleContact :r!goobook-query-mail.sh <args> " Interactively search for Google contacts and insert name and email
" nnoremap <leader>igm :InsertGoogleContact
" nnoremap <leader>igm         :r!goobook-query-mail.sh<space>
" inoremap <leader>igm <esc>diw:r!goobook-query-mail.sh<space><c-r>"<cr><cr>


" print current buffer
nnoremap <leader>pr :exec 'Dispatch lpr ' . expand('%')<cr>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{


" ignore typos
nnoremap <leader>q <nop>
nnoremap <leader>Q <nop>


function! MkdirIfNotExists(dir)
    if !isdirectory(a:dir)
        silent! call system('mkdir -p "' . a:dir . '"')
    endif
endfunction

silent! function! Save(force)
    call MkdirIfNotExists(expand("%:h"))
    if (a:force)
        if !exists('b:DeleteTrailingWhitespace_Action') || b:DeleteTrailingWhitespace_Action == 'ask'
            update!
        else
            silent update!
            GitGutter
            echo '"' . expand("%") . '" ✔'
        end
    else
        if !exists('b:DeleteTrailingWhitespace_Action') || b:DeleteTrailingWhitespace_Action == 'ask'
            update
        else
            silent update
            GitGutter
            echo '"' . expand("%") . '" ✔'
        end
    endif
endfunction

command! ReloadBuffer       :checktime              " Check for file changes (and 'reload' them or get asked with autoread)
command! Reset              :e!                     " Discard changes in buffer
command! Save               :call Save(0)           " Write buffer changes to file
command! SaveForce          :call Save(1)           " Write buffer changes to file ignoring 'readonly' etc.
command! SaveAndClose       :wq                     " Write buffer changes to file and close window
command! CloseBuffer        :bn | :bd#              " Close current buffer (without closing window)
command! CloseBufferWindow  :bd                     " Close current buffer (with closing window)
command! CloseBufferForce   :bdelete!               " Close current buffer discarding changes
command! CloseAllBuffers    :silent bufdo bdelete   " Close all buffers (not vim)
command! CloseWindow        :quit                   " Close current window (not buffer)
command! CloseOtherWindows  :only                   " Close all but current window (not buffers)
command! NewTab             :$tabnew                " Create a new tab
command! CloseTab           :tabclose               " Close current tab (not buffer)
command! QuitVim            :quitall                " Quit Vim (closing all windows)
command! QuitVimForce       :quitall!               " Quit Vim (closing all windows) discarding changes

nnoremap <leader>rl         :ReloadBuffer<cr>
nnoremap <leader>rs         :Reset<cr>
nnoremap <leader>w          :Save<cr>
nnoremap <leader>WW         :SaveForce<cr>
nnoremap <leader>qq         :SaveAndClose<cr>
nnoremap <leader>qa         :CloseAllBuffers<cr>
nnoremap <leader>qb         :CloseBufferWindow<cr>
nnoremap <leader><bs>       :CloseBuffer<cr>
nnoremap <leader>QQ         :CloseBufferForce<cr>
nnoremap <leader>qw         :CloseWindow<cr>
nnoremap <leader>qo         :CloseOtherWindows<cr>
nnoremap <c-d>              :exe 'CloseTerminalBuffers!' <bar> :QuitVim<cr>
nnoremap <leader><c-d><c-d> :exe 'CloseTerminalBuffers!' <bar> :QuitVimForce<cr>

" fix ZQ when in visual mode
vnoremap ZQ <esc>ZQ

" How to delete multiple buffers:
" You can use <C-a> to complete all matches. So if you type :bd *.xml and then hit <C-a>, vim will complete the command to :bd file1.xml file2.xml file3.xml.
" Source: https://stackoverflow.com/a/9499234/4568748

augroup map_q_in_read_only_buffers
    autocmd!
    autocmd BufReadPost * if &readonly
    autocmd BufReadPost *   nnoremap <buffer> q :bd<cr>
    autocmd BufReadPost * endif
augroup END

augroup map_q_in_certain_buffers
    autocmd!
    " TODO: FIX this for conjure log
    autocmd BufReadPost conjure-log-*    nnoremap <buffer> q :bd<cr>
    autocmd BufReadPost fugitive://*     nnoremap <buffer> q :bd<cr>
    autocmd BufReadPost output://*       nnoremap <buffer> q :bd<cr>
    autocmd filetype git                 nnoremap <buffer> q :bd<cr>
    autocmd filetype fugitiveblame       nnoremap <buffer> q :bd<cr>
augroup END

" Close all floating windows, useful for cleaning up messed up pop-ups
nnoremap <leader>qf :CloseAllFloatingWindows<cr>


" }}}


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" LOCAL SECTION                                                                "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{

" Check for local vimrc files and source them.
" (project files take precedence over global files)
" (non-hidden files take precedence over hidden files)
" (child directory takes precedence over parent directory)
let vimrcs = []
for vimrc_name in ['vimrc.local', '.vimrc.local']
    let dir = getcwd()
    while dir != '/'
        let vimrc = glob(dir . '/' . vimrc_name)
        if filereadable(vimrc)
            let vimrcs = vimrcs + [vimrc]
        endif
        let dir = fnamemodify(dir . '..', ':h')
    endwhile
endfor
let vimrcs = vimrcs + ['~/.vimrc.local']
for vimrc in reverse(vimrcs)
    if filereadable(vimrc)
        exec 'source ' . vimrc
    endif
endfor


" }}}

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=0:ts=4:sts=4:sw=4:fdm=marker:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
