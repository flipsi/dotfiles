"  Author:  Philipp Moers
"           soziflip@gmail.com
"           http://github.com/sflip/dotfiles
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
" If you are reading this configuration file on whe web and want use it right
" away, start vim like this:
"
"       bash -c "vim -u <(curl https://raw.githubusercontent.com/sflip/dotfiles/master/vim/vimrc) FILE"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins.
" I use   VUNDLE    to manage my plugins.
" It seems to be best package manager for me. For a discussion see here:
"       http://quyennguyen.com/code/Sync-Vim-With-Github-and-Vundle/
"       http://lepture.com/en/2012/vundle-vs-pathogen

" I install vundle like this:
"
"       git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install some of the vim configuration files and from inside vim I call
" :PluginInstall on each host to let vundle handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a KEYMAP SECTION
"                           where characters are bound.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (' ')
"                           - text edit leader is minus ('-')
"                           - interface leader is control+g ('<C-G>')
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"       a LOCAL SECTION
"                           where potential other vimrc files are loaded.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash
" (fish is not posix compatible and makes problems)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" always search recursively (e.g. when using :find)
set path+=**

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
" (TODO: current implementation is very simple and should be improved)
function! ComputeMyMode()
    if isdirectory(expand("~/.vim/bundle/vundle"))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc source $MYVIMRC
    autocmd BufWritePost vimrc AirlineRefresh
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


if s:MyMode == 'mastery'


    " start vundle
    filetype off
    set rtp+=~/.vim/bundle/vundle/
    "call vundle#rc()
    call vundle#begin()



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let Vundle manage Vundle (required!) {{{

Plugin 'gmarik/vundle'

" package control mappings from vundle itself
nnoremap <Leader>pl :PluginList<CR>
nnoremap <Leader>pi :PluginInstall<CR>
nnoremap <Leader>pc :PluginClean<CR>
nnoremap <Leader>pu :PluginUpdate<CR>
nnoremap <Leader>ps :PluginSearch<Space>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plugin 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" colorschemes
Plugin 'flazz/vim-colorschemes'
Plugin 'christophermca/meta5'
Plugin 'joshdick/onedark.vim'
Plugin 'sjl/badwolf'


" cycle through colorschemes
Plugin 'vim-scripts/ScrollColors'
nnoremap <C-G>o :COLORSCROLL<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" distraction free mode {{{

Plugin 'junegunn/goyo.vim'

let g:goyo_width="120"
let g:goyo_height="100%"

nnoremap <C-G>f :Goyo<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" statusline {{{

" https://powerline.readthedocs.org/en/latest/usage/other.html#vim-statusline
"
" instead of this deprecated vimscript plugin...:
" Plugin 'Lokaltog/vim-powerline
" ... we use this rewritten one in python:
" Plugin 'powerline/powerline'

" disable powerline if it is installed
let g:powerline_loaded = 1

" on arch linux, installed python-powerline
" and fix import error with
"let $PYTHONPATH="/usr/lib/python3.5/site-packages"


" lightweight alternative to powerline

Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts=0


" TODO simple statusline like this
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plugin 'tpope/vim-fugitive'

nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gU :Gread<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gA :Gwrite<CR>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gp :Gpull<CR>
nnoremap <Leader>gP :Gpush<CR>

" in Gdiff view, navigate and stage/checkout easily
augroup gitdiff
    au!
    au BufRead fugitive://* nnoremap <buffer> <Down>  ]c
    au BufRead fugitive://* nnoremap <buffer> <Up>    [c
    au BufRead fugitive://* nnoremap <buffer> <Left>  do
    au BufRead fugitive://* nnoremap <buffer> <Right> dp
augroup END


" show git status of lines on the left

Plugin 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

" do not map ic/ac text objects etc because I decide how I use them
let g:gitgutter_map_keys = 0

omap ih <Plug>GitGutterTextObjectInnerPending
omap ah <Plug>GitGutterTextObjectOuterPending
xmap ih <Plug>GitGutterTextObjectInnerVisual
xmap ah <Plug>GitGutterTextObjectOuterVisual

nnoremap <C-G>g       :GitGutterToggle<CR>
nnoremap <Leader>gg gg:GitGutterNextHunk<CR>zv
nnoremap <Leader>gG  G:GitGutterPrevHunk<CR>zv
nnoremap <Leader>gn   :GitGutterNextHunk<CR>zv
nnoremap <Leader>gN   :GitGutterPrevHunk<CR>zv
nnoremap <Down>       :GitGutterNextHunk<CR>zv
nnoremap <Up>         :GitGutterPrevHunk<CR>zv
nnoremap <Leader>ga   :GitGutterStageHunk<CR>
nnoremap <Leader>gu   :GitGutterUndoHunk<CR>
nnoremap <Leader>gi   :GitGutterPreviewHunk<CR>


" commit messages are special
augroup gitcommit
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit setlocal textwidth=50
    autocmd filetype gitcommit setlocal colorcolumn=""
augroup END


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plugin 'easymotion/vim-easymotion'

" prefix
map ä <Plug>(easymotion-prefix)
" keys to move to target
let g:EasyMotion_keys = 'asdfgh,.qwertuiocvbnmjkl'


" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
Plugin 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<CR>", "\<Tab>"]
let g:clever_f_chars_match_any_signs = 'ö'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" custom text objects {{{

Plugin 'kana/vim-textobj-user'

" lines with the same indent level (ai/ii)
Plugin 'kana/vim-textobj-indent'

" quotes (aq/iq)
Plugin 'beloglazov/vim-textobj-quotes'

" functions (af/if)
Plugin 'kana/vim-textobj-function'
Plugin 'thinca/vim-textobj-function-javascript'

" lines with ( [ { pairs (ac/ic)
" Plugin 'Chun-Yang/vim-textobj-chunk'

" css rules (ac/ic)
Plugin 'jasonlong/vim-textobj-css'
" Plugin 'stephenway/vim-textobj-css'

" HTML/XML attributes (ax/ix)
Plugin 'whatyouhide/vim-textobj-xmlattr'

" PHP Tags (aP/iP)
Plugin 'akiyan/vim-textobj-php'

" folds (az/iz)
Plugin 'kana/vim-textobj-fold'

" git hunks (ih) (now managed by gitgutter plugin)
" Plugin 'gilligan/textobj-gitgutter'
" omap ah <Plug>(textobj-gitgutter-i)
" vmap ah <Plug>(textobj-gitgutter-i)

" entire buffer / 'all' (aa/ia)
Plugin 'kana/vim-textobj-entire'
let g:textobj_entire_no_default_key_mappings = 1
omap aE <Plug>(textobj-entire-a)
vmap aE <Plug>(textobj-entire-a)
omap iE <Plug>(textobj-entire-i)
vmap iE <Plug>(textobj-entire-i)
" load dynamically with :TextobjEntireDefaultKeyMappings

" note that vimtex also defines mappings ic/id/ie/i$


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

Plugin 'haya14busa/incsearch.vim'

"nnoremap ö  <Plug>(incsearch-forward)
"nnoremap Ö  <Plug>(incsearch-backward)
"nnoremap gö <Plug>(incsearch-stay)

nnoremap ö :call incsearch#call()<CR>
nnoremap Ö :call incsearch#call({'command': '?'})<CR>


" searching in multiple files
" install 'the_silver_searcher' package on the system
Plugin 'rking/ag.vim'

" command to execute
let g:ag_prg="ag --vimgrep --smart-case"
" always start in project root instead of cwd
let g:ag_working_path_mode="r"

" type a search pattern
nnoremap / :Ag<Space>""<Left>
" search for word under cursor
nnoremap <Leader>* :Ag "\b<C-R><C-W>\b"<CR>:cw<CR>
" search for visual selection
xnoremap  / y:<c-u>Ag <C-R>=shellescape(expand(@"),1)<CR><CR>
"nnoremap  K :<c-u>Ag <c-r>=shellescape(expand("<cword>"),1)<cr>:copen<cr>


" % also matches HTML-tags/words etc
Plugin 'matchit.zip'


" hide (fold) everything except search string etc
Plugin 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <Leader>zs :Fs<CR>
nnoremap <Leader>z/ :Fs<CR>
nnoremap <Leader>zö :Fs<CR>
nnoremap <Leader>zz :Fs<CR>

" show word under cursor
nnoremap <Leader>z* :Fw<CR>
nnoremap <Leader>zw :Fw<CR>

" show visual selection
vnoremap <Leader>z y:Fp<Space>\V<C-R>"<CR>

" change context size (number of lines around matches)
nnoremap <Leader>z+ :Fi<CR>
nnoremap <Leader>zi :Fi<CR>
nnoremap <Leader>z- :Fd<CR>
nnoremap <Leader>zd :Fd<CR>

" restore folds
nnoremap <Leader>ze :Fe<CR>
nnoremap <Leader>Z  :Fe<CR>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

Plugin 'kien/ctrlp.vim'

let g:ctrlp_map = '#'
let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap #          :CtrlPBuffer<CR>
nnoremap <Leader>#  :CtrlPRoot<CR>
nnoremap <Leader>er :CtrlPMRUFiles<CR>
nnoremap <Leader>em :CtrlPMixed<CR>
nnoremap <Leader>eo :CtrlPRoot<CR>
nnoremap <Leader>eb :CtrlPBuffer<CR>

" ignore some stuff (in addition to 'wildignore')
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<Esc><Enter>', '<c-l>', '<c-v>', '<RightMouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<right>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<left>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plugin 'Shougo/vimproc.vim'
"Plugin 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) overview {{{

Plugin 'majutsushi/tagbar'

" install 'ctags' package on the system

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <Leader>tt :TagbarToggle<CR>

"autocmd FileType vim nested :TagbarOpen()<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file browser {{{

Plugin 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show nerdtree from current file
noremap <silent> <Leader>tn :NERDTreeFind<CR>
" show/hide nerdtree
noremap <silent> <Leader>tN :NERDTreeToggle<CR>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

Plugin 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 4
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex"] }
" let g:syntastic_cpp_compiler = 'clang++'
" let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_c_cppcheck_args = ' -std=c++11 -stdlib=libc++'

nnoremap <silent> <Leader>sc :SyntasticCheck<CR>
nnoremap <silent> <Leader>sr :SyntasticReset<CR>
nnoremap <silent> <Leader>st :SyntasticToggleMode<CR>
nnoremap <silent> <Leader>si :SyntasticInfo<CR>


" install linters on the system:
" - pylint
" - jslint / jshint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)

let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']
" let g:syntastic_javascript_checkers = ['jshint', 'jslint']
let g:syntastic_javascript_checkers = ['jshint']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mLine indented incorrectly;.*',
            \ '\mBad line breaking before .+..',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mShort PHP opening tag used;',
            \ '\m.$. was used before it was defined.',
            \ '\mpossible unwanted space at "{"'
            \ ] }



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" text editing {{{


" replace some motion or text object or selection with current yank
" Plugin 'ReplaceWithRegister'
" nmap -rr <Plug>ReplaceWithRegisterOperator
" nmap -re <Plug>ReplaceWithRegisterLine
" xmap -r  <Plug>ReplaceWithRegisterVisual
" I DON'T REALLY USE THIS BUT v3wp or -rw OCCASIONALLY


" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plugin 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <C-p> <Plug>yankstack_substitute_older_paste
nmap <C-n> <Plug>yankstack_substitute_newer_paste
"call yankstack#setup()


" add and toggle comments with <Leader>c<space> etc
Plugin 'scrooloose/nerdcommenter'
" use leading space, but delete trailing space
let g:NERDSpaceDelims = 1
let g:NERDTrimTrailingWhitespace = 1
" do not nest by default
let g:NERDDefaultNesting = 1
let g:NERDAltDelims_javascript = 0
" comment text objects and movements
for mov in ['j', 'k', 'gg', 'G', '(', ')', '{', '}', 'as', 'is', 'ap', 'ip']
    exe "nmap \<Leader\>c" . mov . " V" . mov . "\<Plug\>NERDCommenterInvert"
endfor
for i in range(1, 50)
    exe "nmap \<Leader\>c" . i . "j V" . i . "j\<Plug\>NERDCommenterInvert"
    exe "nmap \<Leader\>c" . i . "k V" . i . "k\<Plug\>NERDCommenterInvert"
endfor
" duplicate a line and comment out the first one
nmap <Leader>cd yy<Leader>ccp
" do not comment on new lines (except when already in insert mode)
nnoremap o o<Esc>S
nnoremap O O<Esc>S


" automagically add closing braces etc
Plugin 'Raimondi/delimitMate'


" add a ; at the end of a line
"Plugin 'lfilho/cosco.vim'
"inoremap <silent> <Esc><Enter> <Esc>:call cosco#commaOrSemiColon()<CR>A<Enter>
inoremap <silent> <Esc><Enter> <Esc>A;<Esc>^


" add/change/delete quotes/braces/... and more
Plugin 'tpope/vim-surround'
" surround consistently in both modes and more comfortably on german keyboard
nmap -s ys
vmap -s S
" surround with quotes quickly
vmap -q S'
nmap -q ysiw'
" toggle quotes {{{
function! ToggleQuotesWithVimSurround()
    let pos_cursor = getpos(".")[2]
    let linepart   = strpart(getline("."), pos_cursor - 1)
    let pos_single = stridx(linepart, "'")
    let pos_double = stridx(linepart, '"')
    if pos_single >= 0 && (pos_double < 0 || pos_single < pos_double)
        normal cs'"
    elseif pos_double >= 0 && (pos_single < 0 || pos_double < pos_single)
        normal cs"'
    endif
endfunction
" }}}
nnoremap <silent> -tq :call ToggleQuotesWithVimSurround()<CR>


" swap ('transpose') two words or arbitrary things
Plugin 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <Leader>x <Plug>(Exchange)
xmap <Leader>x <Plug>(Exchange)
nmap <Leader>xc <Plug>(ExchangeClear)
nmap <Leader>xl <Plug>(ExchangeLine)
nmap <Leader>xx <Leader>xiw


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" edit quickfix list (make changes directly after global search or linting) {{{

Plugin 'Olical/vim-enmasse'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plugin 'shinokada/dragvisuals.vim'
"vmap <expr> <C-H>  DVB_Drag('left')
"vmap <expr> <C-L>  DVB_Drag('right')
"vmap <expr> <C-J>  DVB_Drag('down')
"vmap <expr> <C-K>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plugin 'zirrostig/vim-schlepp'

vmap <up>    <Plug>SchleppUp
vmap <down>  <Plug>SchleppDown
vmap <left>  <Plug>SchleppLeft
vmap <right> <Plug>SchleppRight

" duplicate
" (delete selection with x. by default, x and d do the same)
vmap -u <Plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plugin 'vim-scripts/toggle_words.vim'

noremap <silent> -tw :ToggleWord<CR>

let g:toggle_words_dict = {
            \ 'css': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['header', 'footer'],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ['0', '1'],
            \     ['add', 'remove'],
            \     ['big', 'little'],
            \     ['black', 'white'],
            \     ['clean', 'dirty'],
            \     ['create', 'delete'],
            \     ['dark', 'light'],
            \     ['deep', 'shallow'],
            \     ['dynamic', 'static'],
            \     ['fast', 'slow'],
            \     ['fat', 'thin'],
            \     ['forward', 'backward'],
            \     ['get', 'set'],
            \     ['good', 'bad'],
            \     ['happy', 'sad'],
            \     ['hard', 'soft'],
            \     ['head', 'tail'],
            \     ['hide', 'show'],
            \     ['high', 'low'],
            \     ['header', 'footer'],
            \     ['in', 'out'],
            \     ['initialize', 'terminate'],
            \     ['initialization', 'termination'],
            \     ['inner', 'outer'],
            \     ['left', 'right'],
            \     ['light', 'dark'],
            \     ['local', 'global'],
            \     ['long', 'short'],
            \     ['love', 'hate'],
            \     ['many', 'few'],
            \     ['min', 'max'],
            \     ['more', 'less'],
            \     ['new', 'old'],
            \     ['next', 'previous'],
            \     ['on', 'off'],
            \     ['open', 'close'],
            \     ['present', 'absent'],
            \     ['question', 'answer'],
            \     ['red','orange','yellow','green','blue','purple'],
            \     ['setup', 'teardown'],
            \     ['single', 'double', 'multi'],
            \     ['strong', 'weak'],
            \     ['this', 'that'],
            \     ['top', 'bottom'],
            \     ['true', 'false'],
            \     ['up', 'down'],
            \     ['wide', 'narrow'],
            \     ['width', 'height'],
            \     ['yes', 'no'],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plugin 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger='<C-k>'
"let g:UltiSnipsListSnippets='<Esc>.'
let g:UltiSnipsJumpForwardTrigger='<C-i>'
let g:UltiSnipsJumpBackwardTrigger='<C-o>'
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'sflipsnippets']


" snippet packs
Plugin 'honza/vim-snippets'


" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced auto completion engine {{{
"
" Remember: YCM is a plugin with a compiled component. If you update YCM using
" Vundle and the ycm_support_libs library APIs have changed (happens rarely),
" YCM will notify you to recompile it. You should then rerun the install
" process.

" Plugin 'Valloric/YouCompleteMe'
" let g:ycm_server_python_interpreter = '/usr/bin/python3'
" let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
let g:ycm_key_invoke_completion = '<Esc>.'
let g:ycm_key_list_select_completion   = ['<C-N>', '<Down>', '<Tab>', '<Enter>']
let g:ycm_key_list_previous_completion = ['<C-P>', '<Up>']
" let g:ycm_show_diagnostics_ui = 0

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" generate docs {{{

" generate javascript docs
Plugin 'heavenshell/vim-jsdoc'
" nnoremap <silent> -adj ?function<cr>:noh<cr><Plug>(jsdoc)
nnoremap <silent> -adj :JsDoc<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

Plugin 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-l=)
xmap -l <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -lG=)
nmap -l <Plug>(EasyAlign)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

Plugin 'Chiel92/vim-autoformat'

" install formatters on the system:
" - js-beautify (for HTML, CSS, JavaScript, JSON)

nnoremap -af :Autoformat<CR>
vnoremap -af :Autoformat<CR>
nmap <Leader>af -af
vmap <Leader>af -af


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plugin 'vim-scripts/ShowTrailingWhiteSpace'
let g:ShowTrailingWhitespace = 1
command! -bar ShowTrailingWhitespaceOn  call ShowTrailingWhitespace#Set(1,1)
command! -bar ShowTrailingWhitespaceOff call ShowTrailingWhitespace#Set(0,1)
command! -bar ShowTrailingWhitespaceToggle call ShowTrailingWhitespace#Toggle(0)
        \ <Bar>echo (ShowTrailingWhitespace#IsSet() ?
        \ 'Show trailing whitespace' : 'Not showing trailing whitespace')
nnoremap <silent> <C-G>A :ShowTrailingWhitespaceToggle<CR>

" (has a bug)
"Plugin 'vim-scripts/JumpToTrailingWhiteSpace'

Plugin 'vim-scripts/DeleteTrailingWhiteSpace'
" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'ask'
" delete trailing whitespace for selected line
vnoremap <silent> -dst :DeleteTrailingWhitespace<CR>
" delete trailing whitespace for whole buffer
nnoremap <silent> -dst :%DeleteTrailingWhitespace<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make #DD8844 appear orange etc
Plugin 'ap/vim-css-color'

" launch colorpicker and insert color code
Plugin 'blindFS/vim-colorpicker'
nnoremap <Leader>cp :ColorPicker<CR>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plugin 'KabbAmine/vCoolor.vim'
"nnoremap <Leader>cp :VCoolor<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lots of syntax support {{{

Plugin 'sheerun/vim-polyglot'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fish stuff {{{

Plugin 'dag/vim-fish'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" LaTeX stuff {{{

Plugin 'lervag/vimtex'

let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'
let g:vimtex_quickfix_ignore_all_warnings=1
let g:vimtex_quickfix_mode=0

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

nnoremap <Leader>bl :VimtexCompileToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" R stuff {{{

if v:version > 704 || v:version == 704 && has("patch1829")
    Plugin 'jalvesaq/Nvim-R'
    " use with tmux
    let R_in_buffer = 0
    let R_applescript = 0
    let R_tmux_split = 1
    let R_vsplit = 1
    let R_rconsole_width = 80
    " custom keybindings
    let R_user_maps_only = 1
    augroup NvimR
        au!
        au FileType r nmap <C-r>s           <Plug>RStart
        au FileType r nmap <C-r>q           <Plug>RClose
        au FileType r nmap <C-r><C-l>       <Plug>RClearConsole
        au FileType r nmap <Leader><Enter>  <Plug>RSendFile
        au FileType r nmap <Enter>          <Plug>RSendLine
        au FileType r xmap <Enter>          <Plug>RSendSelection
    augroup END
endif



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" scala stuff {{{

Plugin 'derekwyatt/vim-scala'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plugin 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <Leader>ut :GundoToggle<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    " finish vundle
    call vundle#end()
    filetype plugin indent on


    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping
    " but cannot be executed in the vundle block)
    call yankstack#setup()

endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" options {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=1200

" always assume modern terminal
set ttyfast
" don't draw everything (e.g. when playing macros)
set ttyfast
set lazyredraw

" allow mouse usage for bad days
set mouse=a

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8
" <EOL> line ending philosophies to try
" set fileformats=unix,dos,mac

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread

" automatically change working directory to current file
" set autochdir

" command history size
set history=9999

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable

" highlight matching bracket when typing
" set showmatch
" set matchtime=4

" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = 1
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter * set nocursorline nocursorcolumn
    au WinEnter,InsertLeave * if g:cursorposition
    au WinEnter,InsertLeave *     set cursorline cursorcolumn
    au WinEnter,InsertLeave * endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2
set noshowmode

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignorecase
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
set wildignore+=*.o,*.obj,*.pyc,*.class
set wildignore+=*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.odt,*.ods
set wildignore+=*.jpg,*.jpeg,*.png
set wildignore+=*.mp3,*.mp4,*.mpg,*.mpeg,*.flv,*.wav
set wildignore+=*.aux,*.bbl,*.blg,*.fdb_latexmk,*.fls,*.loe,*.lof,*.out,*.toc

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=8
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
" never have to append 'g' to a search/substitute again
set gdefault

" allow the cursor to move where there is no character
set virtualedit=block,insert,onemore

" characters to show in list mode
if v:version > 704 || v:version == 704 && has("patch711")
    set listchars=space:·,tab:--,extends:❯,precedes:❮
else
    set listchars=tab:--,extends:❯,precedes:❮
endif

" how it looks like if we wrap lines
if v:version > 704 || v:version == 704 && has("patch338")
    set breakindent
endif
set showbreak=↪

" use 4 spaces instead of tabs
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" allow <BS> to delete everything
set backspace=indent,eol,start

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright



" }}}


" colorscheme {{{

if s:MyMode == 'mastery'

    " DARK THEMES

    set background=dark

    colorscheme badwolf
    " colorscheme candycode
    " colorscheme dante
    " colorscheme desertEx
    " colorscheme jellybeans
    " colorscheme meta5
    " colorscheme molokai
    " colorscheme onedark
    " colorscheme pride
    " colorscheme seoul256
    " colorscheme up

    let g:airline_theme='base16_summerfruit'
    " let g:airline_theme='behelit'
    " let g:airline_theme='kalisi'
    " let g:airline_theme='lucius'
    " let g:airline_theme='serene'
    " let g:airline_theme='tomorrow'

    highlight CursorLine   ctermbg=234
    highlight CursorColumn ctermbg=234
    highlight ColorColumn  ctermbg=234
    highlight ShowTrailingWhitespace ctermbg=238

    " LIGHT THEMES

    " set background=light

    " colorscheme lucius
    " colorscheme peaksea
    " colorscheme seoul256-light

    " let g:airline_theme='bubblegum'
    " let g:airline_theme='lucius'
    " let g:airline_theme='sol'

    " highlight CursorLine   ctermbg=252
    " highlight CursorColumn ctermbg=252
    " highlight ColorColumn  ctermbg=250
    " highlight ShowTrailingWhitespace ctermbg=250

else

    " fallback colorscheme
    colorscheme desert

    let g:cursorposition = 0
    set nocursorcolumn nocursorline
    highlight CursorLine   ctermbg=233
    highlight CursorColumn ctermbg=233
    highlight ColorColumn  ctermbg=233

endif

" }}}


" allows cursor change in tmux mode {{{

if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" toggle syntax highlighting {{{
function! ToggleSyntax()
   if exists("g:syntax_on")
      syntax off
   else
      syntax enable
   endif
endfunction
" }}}


" get a list of buffers {{{
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction
" }}}



" redraw the screen in case some git things don't keep up with shit {{{
function! GitRedraw()
    GitGutterAll
endfunction
" }}}



" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}


" return 1 iff the active window contains a quickfix buffer and there are no
" other windows with normal buffers.
function! IsOrphanQuickfixList()
    let winnr = winnr("$")
    while winnr >= 1
        if getbufvar(winbufnr(winnr), "&buftype") == ""
            return 0
        endif
        let winnr -=1
    endwhile
    return getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"
endfunction
" improve quickfix/location list
augroup quickfix
    au!
    " automatically close quickfix/location list when alone
    au BufEnter * if IsOrphanQuickfixList()
    au BufEnter *     bdelete
    au BufEnter * endif
augroup END




" make columns after &textwidth visible or invisible {{{
function! ToggleColorColumn()
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if &colorcolumn == "" || &colorcolumn != expr
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}

"... and call this function when &textwidth is changed
if v:version > 704 || v:version == 704 && has("patch786") " if has ('patch-7.4.786')
    augroup colorcolumn
        au!
        au OptionSet textwidth if &textwidth != 0
        au OptionSet textwidth      call ToggleColorColumn()
        au OptionSet textwidth else
        au OptionSet textwidth      set colorcolumn=
        au OptionSet textwidth endif
    augroup END
endif


" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\S)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\S)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\S)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters below {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num
    let linenumber = line(".")
    call append(linenumber, repeat(char, num))
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    let linenumber = line(".")
    let line = getline(".")
    let len = strlen(line) + 2 + 2
    let borderline = repeat(char, len)
    execute '.substitute/^/' . char . ' /'
    execute '.substitute/$/ ' . char . '/'
    call append(linenumber, repeat(char, len))
    call append(linenumber-1, repeat(char, len))
endfunction
" }}}



" ranger as a file chooser {{{
function! RangerChooser()
    let temp = tempname()
    " The option "--choosefiles" was added in ranger 1.5.1. Use the next line
    " with ranger 1.4.2 through 1.5.0 instead.
    "exec 'silent !ranger --choosefile=' . shellescape(temp)
    if has("gui_running")
        exec 'silent !xterm -e ranger --choosefiles=' . shellescape(temp)
    else
        exec 'silent !ranger --choosefiles=' . shellescape(temp)
    endif
    if !filereadable(temp)
        redraw!
        " Nothing to read.
        return
    endif
    let names = readfile(temp)
    if empty(names)
        redraw!
        " Nothing to open.
        return
    endif
    " Edit the first item.
    exec 'edit ' . fnameescape(names[0])
    " Add any remaning items to the arg list/buffer list.
    for name in names[1:]
        exec 'argadd ' . fnameescape(name)
    endfor
    redraw!
endfunction
command! -bar RangerChooser call RangerChooser()
" }}}



" change search mode (what happens when hitting n) {{{
" http://vim.wikia.com/wiki/Make_search_results_appear_in_the_middle_of_the_screen
function! s:SearchMode()
  if !exists('s:searchmode') || s:searchmode == 0
    echo 'Search next: scroll hit to middle if not on same page'
    nnoremap <silent> n n:call <SID>MaybeMiddle()<CR>zv
    nnoremap <silent> N N:call <SID>MaybeMiddle()<CR>zv
    let s:searchmode = 1
  elseif s:searchmode == 1
    echo 'Search next: scroll hit to middle'
    nnoremap n nzzzv
    nnoremap N Nzzzv
    let s:searchmode = 2
  else
    echo 'Search next: normal'
    " nunmap n
    " nunmap N
    nnoremap n nzv
    nnoremap N Nzv
    let s:searchmode = 0
  endif
endfunction
" If cursor is on top or bottom, scroll to middle line.
function! s:MaybeMiddle()
  if winline() == &scrolloff + 1 || winline() == winheight(0) - &scrolloff
    normal! zzzv
  endif
endfunction

" }}}




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" I copied this great piece of code from Steve Losh (sjl):




" Next and Last {{{
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B.
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# "b" || c ==# "(" || c ==# ")"
        let c = "("
    elseif c ==# "B" || c ==# "{" || c ==# "}"
        let c = "{"
    elseif c ==# "r" || c ==# "[" || c ==# "]"
        let c = "["
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute "normal! " . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute "normal! va" . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# "("
            let open = "("
            let close = ")"
        elseif c ==# "{"
            let open = "{"
            let close = "}"
        elseif c ==# "["
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute "normal! vi" . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute "normal! vi" . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute "normal! va" . c . "hol"

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}



" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

" add highlighted word
nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" remove highlighted words
nnoremap <silent> <leader>0
    \ :silent! call matchdelete(86751)<bar>
    \ :silent! call matchdelete(86752)<bar>
    \ :silent! call matchdelete(86753)<bar>
    \ :silent! call matchdelete(86754)<bar>
    \ :silent! call matchdelete(86755)<bar>
    \ :silent! call matchdelete(86756)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  KEYMAP SECTION                                                              "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{



let mapleader=' '



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" (for compatibility)
nnoremap <C-G><C-G> <C-G>

" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<CR>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<CR>
"endif
"nnoremap <Leader><F5> :MyRefresh<CR>


" show absolute path of current file (':help filename-modifiers')
nnoremap <Leader><C-G> :echo expand("%:~")<CR>

" if in a git directory and there are dirty files, open them
nnoremap <Leader>eg :silent! args `git diff --name-only`<CR>

" open config file
"nnoremap <Leader>ev :edit ~/dotfiles/vim/vimrc<CR>
nnoremap <Leader>ev :execute 'edit ' . resolve(expand($MYVIMRC))<CR>
nnoremap <Leader>e3 :edit ~/.i3/config<CR>

" reload config file
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <F5>       :source $MYVIMRC<CR>


" to follow links in help and jump to definition (ctags)
nnoremap <M-Enter>    <C-]>
nnoremap <Esc><Enter> <C-]>
augroup map_enter_help
    au!
    au BufReadPost */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ nnoremap <buffer> <Enter> <C-]>
augroup END


" visual block mode is more useful than visual mode
nnoremap v <C-v>
nnoremap <C-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <C-c>


" copy to clipboard / primary selection in visual modemode
vnoremap <C-c>      "*ygv"+y
nnoremap <C-c> gg0VG"*ygv"+y

" paste from clipboard / primary selection {{{
function! PasteFromGUI()
    let clipbrd = @+
    let primary = @*
    if len(primary) == 0
        normal "+P
    elseif len(clipbrd) == 0
        normal "*P
    elseif primary == clipbrd
        normal "*P
    else
        ec "Paste (c)lipboard (default)    " . strtrans(strpart(clipbrd, 0, 50))
        ec "or    (p)rimary selection?     " . strtrans(strpart(primary, 0, 50))
        let c = getchar()
        if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
            redraw
        elseif nr2char(c) == 'c' || nr2char(c) == '+' || c == 13 || c == 22
            normal "+P
            redraw
        elseif nr2char(c) == 'p' || nr2char(c) == 's' || nr2char(c) == '*'
            normal "*P
            redraw
        endif
    endif
endfunction
" }}}
noremap <silent> <C-v><C-v> :call PasteFromGUI()<CR>
imap <C-v><C-v> <Esc><C-v><C-v>


" macro ('complex repeat') helper mappings
nnoremap @{ :nmap <Leader<Left><Right>>rm @}<CR>qq
nnoremap @} q:nmap <Leader<Left><Right>>rm @{<CR>:echo ''<CR>
" record macro (start and stop)
nmap     <Leader>rm @{
nnoremap <Leader>rM q
" replay macro
nnoremap <Leader>m @q
nnoremap <Leader>M @


" alternative way to go back to normal mode
inoremap jk <Esc>
cnoremap jk <C-c>
cnoremap <C-g>  <C-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll with arrow keys if i lay back
"nnoremap <Down> <C-E>
"nnoremap <Up>   <C-Y>

" scroll a little smoother (but still without plugin)
" (this actually is suggested in :help scroll-smooth)
noremap <M-j>  <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <Esc>j <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
noremap <M-k>  <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
noremap <Esc>k <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)


" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))

" write changes with root permissions
cnoremap w!! w !sudo tee % >/dev/null
"cnoreabbrev w!! w !sudo tee % >/dev/null

" have the up/down search functionality with C-p too
cnoremap <C-n> <down>
cnoremap <C-p> <up>





" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{


" change text width
nnoremap <Leader>ow0 :set textwidth=0<CR>
nnoremap <Leader>ow5 :set textwidth=50<CR>
nnoremap <Leader>ow7 :set textwidth=78<CR>
nnoremap <Leader>ow8 :set textwidth=80<CR>
nnoremap <Leader>ow1 :set textwidth=100<CR>
nnoremap <Leader>ow2 :set textwidth=120<CR>

" change tab width (soft)
nnoremap <Leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>
nnoremap <Leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
nnoremap <Leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<CR>

" toggle paste mode
nnoremap <Leader>op :set paste! <bar> :set paste?<CR>

" ... but ignore typos
nnoremap <Leader>o <NOP>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <C-G>y :call ToggleSyntax()<CR>

" toggle line numbers
noremap <silent> <C-G>l :set number! <bar> :set relativenumber! <CR>
noremap <silent> <C-G>L :set relativenumber! <CR>

" toggle word wrap
nnoremap <silent> <C-G>w :setlocal wrap! <bar> :set wrap? <CR>

" toggle vertical ruler
nnoremap <silent> <C-G>r :call ToggleColorColumn()<CR>
nnoremap <silent> <C-G>R :highlight ColorColumn ctermbg=234<CR>

" toggle highlight current cursor position
" (switch to insert mode to apply changes)
nnoremap <silent> <C-G>c :let g:cursorposition = 1 - g:cursorposition <CR>

" toggle show listchars (like whitespace)
nnoremap <silent> <C-G>a :set list!<CR>


" spell checking
nnoremap <C-G>ss :setlocal spell! <bar> :set spell? <CR>
nnoremap <C-G>se :setlocal spelllang=en<CR>
nnoremap <C-G>sd :setlocal spelllang=de<CR>
nmap <C-G>sg <C-G>sd


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{


" move intuitively when text is wrapped
nnoremap j gj
nnoremap k gk

" move faster
nnoremap gj 8j
nnoremap gk 8k
vnoremap gj 8j
vnoremap gk 8k


" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <C-b>  <Left>
noremap! <C-f>  <Right>
noremap! <C-d>  <Delete>
" ... by words
noremap! <M-b>  <S-Left>
noremap! <M-f>  <S-Right>
cnoremap <Esc>b <S-Left>
cnoremap <Esc>f <S-Right>


" move to BOL
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <C-A> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <C-A> <C-O><C-A>

" move to EOL
nnoremap <C-E> $
vnoremap <C-E> $
onoremap <C-E> $
inoremap <C-E> <End>
cnoremap <C-A> <Home>
" move to EOL with l instead of $
onoremap l $


" swap , and ;
" (makes more sense on german keyboard)
nnoremap , ;
nnoremap ; ,
nnoremap g, g;
nnoremap g; g,


" swap ` and ' (jump to markers)
" (by default, ' marked line, ` marked line and column)
nnoremap ' `
nnoremap ` '

" goto mark
nnoremap Ä `

" goto last edit
nnoremap <Leader>. `.zzzv


" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{


" search in this buffer
if s:MyMode == 'stripped'
    nnoremap ö /
    nnoremap Ö ?
endif

" search in multiple files
if s:MyMode == 'stripped'
    nnoremap / :call ToggleList("Quickfix List", 'c')<CR>
             \ :vimgrep // **/*<Left><Left><Left><Left><Left><Left>
endif

" search for visual selection
vnoremap * y/<C-R>"<CR>
if s:MyMode == 'stripped'
    vnoremap / y/<C-R>"<CR>
endif


" find next and previous occurence like usual when we searched backwards
" nnoremap <expr> n  'Nn'[v:searchforward]
" nnoremap <expr> N  'nN'[v:searchforward]

" keep search matches in the middle of the window and open folds
" nnoremap n nzzzv
" nnoremap N Nzzzv
" nnoremap * *zzzv
" nnoremap g* g*zzzv
" nnoremap g# g#zzzv
silent call <SID>SearchMode()
nnoremap <silent> <Leader>on :call <SID>SearchMode()<CR>
nmap * *nN
nmap g* g*nN
nmap g# g#nN


" find lines that are too long
nnoremap <Leader>fw :exec '/\v^.{' . &textwidth . '}.'<CR>

" find trailing whitespace
nnoremap <Leader>fst /\v\s+$<CR>

" find matching element (brackets/braces/parentheses)
nnoremap <Leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <Leader>fm %
nmap <Leader>ff %

" find all lines with keyword under cursor and ask which one to jump to
nmap <Leader>fj [I:let nr = input("Which one: ")
            \   <Bar> exe "normal " . nr ."[\t"<CR>

" find git merge conflict markers
nnoremap <Leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is minus ('-')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$j

" autocompletion
inoremap <M-.>  <C-N>
inoremap <Esc>. <C-N>
inoremap <M-:>  <C-P>
inoremap <Esc>: <C-P>

" increment/decrement number
nnoremap +  <C-A>
nnoremap -- <C-X>


" indent lines
vnoremap < <gv
vnoremap > >gv

" change tab width (hard)
nnoremap -rt2 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=2 <bar> :retab <CR>
nnoremap -rt4 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=4 <bar> :retab <CR>
nnoremap -rt8 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=8 <bar> :retab <CR>

" autoformat with enter in normal buffers
augroup map_enter_autoformat
    au!
    au BufReadPost *
                \ if ! strchars(&buftype) |
                \   nnoremap <buffer> <Enter> gqap |
                \   vnoremap <buffer> <Enter> gq |
                \ endif
augroup END

" move line up or down
" (:m closes folds https://groups.google.com/forum/#!topic/vim_dev/QGgbjv4uyZc)
nnoremap <silent> -k :set fdm=manual<CR>:m .-2<CR>:set fdm=marker<CR>
nnoremap <silent> -j :set fdm=manual<CR>:m .+1<CR>:set fdm=marker<CR>
vnoremap <silent> -j <Esc>:set fdm=manual<CR>gv:m '>+1<CR>gv=gv:set fdm=marker<CR>
vnoremap <silent> -k <Esc>:set fdm=manual<CR>gv:m '<-2<CR>gv=gv:set fdm=marker<CR>


" split line (opposite of 'J'oin lines)
" (regular 'S' can be done with 'cc' instead)
nnoremap S i<CR><esc>
            \ ^mq
            \ :let searchregister=@/<CR>
            \ :silent! .-1s/\v +$//<CR>:nohlsearch<CR>
            \ :let @/=searchregister<CR>
            \ `q

" duplicate line or selection
nnoremap -u yyp
vnoremap -u yP

" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <M-o>  <Esc>o<Esc>k
"noremap <Esc>o <Esc>o<Esc>k
"noremap <M-O>  <Esc>O<Esc>j
"noremap <Esc>O <Esc>O<Esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k


" add space (a few newlines) below
"nnoremap <Enter> :.+1insert \n\n\n<CR>
nnoremap -as mno<Esc>o<Esc>o<Esc>o<Esc>`n

" add a line of characters
nnoremap -al :call InsertCharLine(input("Insert character: "), 80)<CR>
" add a box of characters ('comment box')
nnoremap -ab :call InsertCharBox(input("Insert character: "))<CR>


" enter substitution mode quickly
nnoremap <C-S><C-S> :%s::<Left>


" in visual mode, use 's' for substitution
" (to change only a single occurence, use 'c'. by default they are the same)

" substitute occurences of selection in this buffer
vnoremap <C-S>         yms:%s:\V\C<C-R>":<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" the same, but with keyword matching
vnoremap <Leader><C-S> yms:%s:\V\C\<<C-R>"\>:<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" substitute occurences of selection in this buffer from current line and below
vnoremap s             yms:,$s:\V\C<C-R>":<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" the same, but with keyword matching
vnoremap <Leader>s     yms:,$s:\V\C\<<C-R>"\>:<C-R>":c<Bar>norm!`s
    \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" " (these are actually two substitutions, so that we start at the current line
" " but continue from the first. source: http://stackoverflow.com/a/7608016)
" vnoremap s             yms:,$s:\V\C<C-R>":<C-R>":c<Bar>1,''-&&<Bar>norm!`s
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left>
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
" " the same, but with keyword matching
" vnoremap <Leader>s     yms:,$s:\V\C\<<C-R>"\>:<C-R>":c<Bar>1,''-&&<Bar>norm!`s
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left>
    " \ <Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" substitution motions and text objects
nmap <C-S>e ves
nmap <C-S>E vEs
nmap <C-S>w viw<Leader>s
nmap <C-S>W viWs


" replace something with yank
nnoremap -rw viwp
nnoremap -rW viWp
nnoremap -rl v$hp


" sort lines
nnoremap -o vip:sort<CR>
vnoremap -o :sort<CR>


" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap -tu blguee
inoremap -tu <Esc>blgueea


if s:MyMode == 'stripped'
    " delete trailing whitespace for selected line
    vnoremap <silent> -dst <Esc>:.s:\v\s+$::<CR>
    " delete trailing whitespace for whole buffer
    nnoremap <silent> -dst :%s:\v\s+$::<CR>
endif

" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> -dsl :s:^\s\+::<CR>
" replace double/multiple spaces with one space
nnoremap <silent> -dsd :.s:\v(\S) {2}(\S):\1 \2:<CR>
nnoremap <silent> -dsD :%s:\v(\S) {2}(\S):\1 \2:<CR>
nnoremap <silent> -dsm :.s:\v(\S) {2,}(\S):\1 \2:<CR>
nnoremap <silent> -dsM :.s:\v(\S) {2,}(\S):\1 \2:<CR>


" convert a vim plugin github url into appropriate format for vundle
nnoremap -pi :.s:\m.*http.*github\.com/\([^/]*/[^/]*\).*:Plugin '\1':<CR>


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <Leader>ch :call ToggleHTMLComment("n")<CR>
vnoremap <silent> <Leader>ch :call ToggleHTMLComment("v")<CR>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <Leader>cd yyI#<Esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <M-u>  :earlier<CR>
noremap <Esc>u :earlier<CR>
noremap <M-U>  :later<CR>
noremap <Esc>U :later<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{


" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUILDING AND DEBUGGING {{{


" make
nnoremap <Leader>bm :make<CR>

" execute shell script
nnoremap <Leader>bs :!./%<CR>

" jump to (syntastic) errors
nnoremap <Leader>sg :lfirst<CR>
nnoremap <Leader>sG :llast<CR>
nnoremap <Leader>sn :lnext<CR>
nnoremap <Leader>sN :lprevious<CR>

" perform a :cnext or :lnext
" so we jump through both quickfix and location list with one keystroke
" @param direction: 0 for next, 1 for previous
" @param switch: 0 for the same list as before, 1 for the other
let g:jumplist = 'locationlist'
function! JumpThroughList(direction, switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (a:direction == 1)
        if (g:jumplist == 'quickfixlist')
            silent! cprevious
        else
            silent! lprevious
        endif
    else
        if (g:jumplist == 'quickfixlist')
            silent! cnext
        else
            silent! lnext
        endif
    endif
endfunction
nnoremap <silent> <Left>          :call JumpThroughList(1, 0)<CR>
nnoremap <silent> <Right>         :call JumpThroughList(0, 0)<CR>
nnoremap <silent> <Leader><Left>  :call JumpThroughList(1, 1)<CR>
nnoremap <silent> <Leader><Right> :call JumpThroughList(0, 1)<CR>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <Leader>sl :lclose<bar>:cclose<CR>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <Leader>sL :lopen<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS AND WINDOWS {{{


" change or open new buffer by searching for file name
if s:MyMode == 'stripped'
    nnoremap # :buffers<CR>:buffer<Space>
    nnoremap <Leader># :find<Space>
endif

" change to LRU buffer
nnoremap <Space><Space> :buffer #<CR>

" circle through buffers
nnoremap <M-n>  :bnext<CR>
nnoremap <Esc>n :bnext<CR>
nnoremap <M-p>  :bprevious<CR>
nnoremap <Esc>p :bprevious<CR>

" change window
nnoremap <silent> <C-j> :wincmd j<CR>
nnoremap <silent> <C-k> :wincmd k<CR>
nnoremap <silent> <C-h> :wincmd h<CR>
nnoremap <silent> <C-l> :wincmd l<CR>

" move buffer to a new window
nnoremap <silent> <Leader><C-l> :vsplit<CR><C-W>w<CR>:bprevious<CR><C-W>w<CR>
nnoremap <silent> <Leader><C-j>  :split<CR><C-W>w<CR>:bprevious<CR><C-W>w<CR>


" clear windows (close quickfix and location list) and refresh screen
nnoremap <silent> <BS> :lclose <Bar> :cclose <Bar> :redraw! <CR>

" toggle quickfix or location list
nnoremap <silent> <Leader>tq :call ToggleList("Quickfix List", 'c')<CR>
nnoremap <silent> <Leader>tl :call ToggleList("Location List", 'l')<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{

" search the web with selection
vnoremap <Leader>isl :<C-w>!$BROWSER 'https://dict.leo.org/ende/?lang=en&search=<C-R>*'<CR><CR>
vnoremap <Leader>isd :<C-w>!$BROWSER 'https://duckduckgo.com/?q=<C-R>*'<CR><CR>
vnoremap <Leader>isg :<C-w>!$BROWSER 'https://google.com/?q=<C-R>*'<CR><CR>

" shell in working dir or dir of current file
nnoremap <Leader>if :!fish<CR><CR>
nnoremap <Leader>iF :execute '!cd ' . expand('%:p:h') . '; fish'<CR><CR>
nnoremap <Leader>ib :!bash<CR><CR>
nnoremap <Leader>iB :execute '!cd ' . expand('%:p:h') . '; bash'<CR><CR>

" file manager in working dir or dir of current file
"nnoremap <Leader>iR :call SetCwdToFilePath() <bar> :!ranger<CR>
nnoremap <Leader>ir :RangerChooser<CR>
nnoremap <Leader>iR :call SetCwdToFilePath() <bar> RangerChooser<CR>

" git interface in working dir or dir of current file
nnoremap <Leader>it :!tig status <CR> :call GitRedraw()<CR>
nnoremap <Leader>iT :execute '!cd ' . expand('%:p:h') . '; tig status'<CR>
                                    \ :call GitRedraw()<CR>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{


" check for file changes (and 'reload' them or get asked with autoread)
nnoremap <Leader>rl :checktime<CR>


" write changes
nnoremap <Leader>w :update<CR>
nnoremap <Leader>WW :update!<CR>

" quit current buffer
nnoremap q :bdelete<CR>
nnoremap <Leader>qq :bdelete<CR>
nnoremap <Leader>QQ :bdelete!<CR>

" quit all buffers (not vim)
nnoremap <Leader>qa :bufdo bdelete<CR>

" quit current window
nnoremap Q :quit<CR>
" quit all windows but current
nnoremap <Leader>qo :only<CR>

" quit vim (multiple windows)
" (this is how i exit most terminal applications)
nnoremap <C-D> :quitall<CR>
nnoremap <Leader><C-D><C-D> :quitall!<CR>

" remember ZZ and ZQ


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" LOCAL SECTION                                                                "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{

" Check for local vimrc files and source them.
" (project files take precedence over global files)
" (non-hidden files take precedence over hidden files)
" (child directory takes precedence over parent directory)
let vimrcs = []
for vimrc_name in ['vimrc.local', '.vimrc.local']
    let dir = getcwd()
    while dir != '/'
        let vimrc = glob(dir . '/' . vimrc_name)
        if filereadable(vimrc)
            let vimrcs = vimrcs + [vimrc]
        endif
        let dir = fnamemodify(dir . '..', ':h')
    endwhile
endfor
let vimrcs = vimrcs + ['~/.vimrc.local']
for vimrc in reverse(vimrcs)
    if filereadable(vimrc)
        exec 'source ' . vimrc
    endif
endfor


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=80:sw=4:fdm=marker:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
