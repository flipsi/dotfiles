"  Author:  Philipp Moers
"           soziflip@gmail.com
"           http://github.com/sflip/dotfiles
"
"  ~/.vimrc
"
"
"  Configuration file for
"
"  __      _______ __  __
"  \ \    / /_   _|  \/  |
"   \ \  / /  | | | \  / |
"    \ \/ /   | | | |\/| |
"     \  /   _| |_| |  | |
"      \/   |_____|_|  |_|
"
"
"
"  (What vim is? The best reason not to use emacs!)
"
"
"
"
" If you are reading this configuration file on whe web and want use it right
" away, start vim like this:
"
"       bash -c "vim -u <(curl https://raw.githubusercontent.com/sflip/dotfiles/master/vim/vimrc) FILE"
"
"
" In case you open this file in vim and don't know how to use folds:
" - open/close a fold with zo/zc
" - open/close all folds with zR/zM
"
"
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" README                                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{
"
"
" Vim becomes especially powerful with plugins. I use vim-plug to manage them.

" I install vim-plug like this:
"
"       curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"           https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
"
" and don't have ~/.vim/bundle under version control, because this is a bad
" idea. Instead, I use the install.sh script provided in this repository to
" install vim configuration files let vim-plug handle the plugins.
"
"
" I want my vimrc to be sourced without errors out of the box.
" So there are two modes:
"       a mastery of the world mode ('mastery') with all my plugins,
"       a stripped mode ('stripped') without plugins.
" I use the stripped mode on some other systems than home, VMs or as root.
"
"
" This vimrc is divided in several sections.
"
"       a PLUGIN SECTION
"                           where plugins are listed configured.
"                           It can contain settings and keymaps that are
"                           specific to a particular plugin.
"                           It is only executed in mastery mode.
"       an SETTINGS SECTION
"                           that contains some options not specific to a
"                           plugin.
"                           Also, settings that are no options are made here
"                           (e.g. colorscheme)
"                           It is executed in both modes.
"       a FUNCTION SECTION
"                           with some useful functions.
"                           This often is stuff too big for one mapping or the
"                           like and probably I shamelessly copied it.
"                           It is executed in both modes.
"       a COMMAND AND KEYMAP SECTION
"                           where commands are defined and characters are bound.
"                           Command definitions makes it easier to find a
"                           functionality via :FzfCommands when I can't remember
"                           the corresponding mapping.
"                           It is executed in both modes.
"                           Also, it may contain fallback keymaps for plugin
"                           specific things if we are in stripped mode.
"                           It must be executed after the plugin section.
"                           Mappings with the alt key should be done twice:
"                           - with <Esc>* for terminal sequences, and
"                           - with <M-*>  for gvim
"                           Leader key convention:
"                           - general leader is space (' ')
"                           - text edit leader is minus ('-')
"                           - interface leader is space followed by y (' y')
"                           The leader key may set several times in this file
"                           since the execution time of the mapping matters.
"       a LOCAL SECTION
"                           where potential other vimrc files are loaded.
"
"
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" SETUP                                                                        "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" basic setup {{{

" we use vim, not vi
set nocompatible

" execute external commands with bash
" (fish is not posix compatible and makes problems)
"set shell=/usr/bin/bash
let &shell=system('which bash | tr -d "\n"')

" force usage of python3
" https://robertbasic.com/blog/force-python-version-in-vim/
if has('python3')
endif

" always search recursively (e.g. when using :find)
set path+=**

" edit runtimepath
set runtimepath+=~/.vim/syntax


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" my mode {{{

" compute if we should use mastery of the world or stripped mode
function! ComputeMyMode()
    if filereadable(expand("~/.vim/autoload/plug.vim"))
        return 'mastery'
    else
        return 'stripped'
    endif
endfunction
"
" ... and compute this only once
let s:MyMode = ComputeMyMode()

" test which mode will be used
if s:MyMode == 'mastery'
    "echo 'Loading configuration with plugins...'
else
    "echo 'Loading configuration without plugins...'
endif

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" leader key {{{

let mapleader=' '
let maplocalleader=' '

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" automatically source vimrc on save {{{

if !exists("*SourceMYVIMRC")
    function SourceMYVIMRC()
        source $MYVIMRC
        syntax enable
        AirlineRefresh
        FixHighlighting
    endfunction
endif
command! -bang SourceMYVIMRC :call SourceMYVIMRC() " Reload configuration

augroup reload_vimrc
    autocmd!
    autocmd BufWritePost vimrc SourceMYVIMRC
augroup END

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cursor to the last line when reopening a file {{{

augroup line_jump_on_open
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  PLUGIN SECTION                                                              "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


nnoremap <leader>pi :PlugInstall<cr>
nnoremap <leader>pc :PlugClean<cr>
nnoremap <leader>pu :PlugUpdate<cr>
nnoremap <leader>ps :PlugStatus<space>
nnoremap <leader>pd :PlugDiff<space>



if s:MyMode == 'mastery'

    call plug#begin()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim sessions {{{

" make sessions more convenient and automatically updated
Plug 'tpope/vim-obsession'

let g:session_file_name = '.session.vim'

" start session
nnoremap <leader>se :exe 'Obsession' . g:session_file_name<cr>

" automatically load sessions if started without args
autocmd VimEnter * nested
            \ if !argc() && empty(v:this_session) |
            \   if filereadable(g:session_file_name) |
            \     exe 'source' . g:session_file_name |
          " \   elseif |
          " \     exe 'Obsession' . g:session_file_name |
            \   endif |
            \ endif


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" terminal extensions {{{

Plug 'kassio/neoterm'

let g:neoterm_shell = 'fish'
let g:neoterm_default_mod = ':vertical'
let g:neoterm_autoinsert = 1
let g:neoterm_autoscroll = 1

command! -nargs=1 -complete=file RunCommandInTerminal :call RunCommandInTerminal(<q-args>)
function! RunCommandInTerminal(commandline)
    let g:last_terminal_command = a:commandline
    call ExecuteInNeoTerminal('T ' . a:commandline)
endfunction

function! RunLastCommandInTerminal()
    if exists('g:last_terminal_command')
        execute 'RunCommandInTerminal ' . g:last_terminal_command
    else
        echoerr "No last command found!"
    endif
endfunction

" Execute some neoterm terminal command without ending up in insert mode
" (this is necessary due to the 'startinsert' autocmd that I want)
command! -nargs=1 ExecuteInNeoTerminal :call ExecuteInNeoTerminal(<q-args>)
function! ExecuteInNeoTerminal(vimcommand)
    let g:suppress_terminal_autoinsert = 1
    execute a:vimcommand
    sleep 50m
    unlet g:suppress_terminal_autoinsert
endfunction

" Remove stupid default mappings
augroup neoterm_remove_mappings
    au!
    au VimEnter * nunmap ,tt
augroup END

nnoremap <leader>tt     :Topen<cr>
nnoremap <leader>tn     :Tnew<cr>
nnoremap <leader>to     :RunCommandInTerminal<space>
nnoremap <leader>t<bs>  :Tclose<cr>         " only hides buffer, we can still sent commands to it

" nnoremap <leader>tl :Tclear<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tmux integration {{{


" fix FocusLost and FocusGained events in tmux
Plug 'tmux-plugins/vim-tmux-focus-events'


" " don't worry about tmux panes and vim splits
" Plugin 'christoomey/vim-tmux-navigator'
" let g:tmux_navigator_save_on_switch = 1
" let g:tmux_navigator_no_mappings = 1
" nnoremap <silent> {Left-Mapping}     :TmuxNavigateLeft<cr>
" nnoremap <silent> {Down-Mapping}     :TmuxNavigateDown<cr>
" nnoremap <silent> {Up-Mapping}       :TmuxNavigateUp<cr>
" nnoremap <silent> {Right-Mapping}    :TmuxNavigateRight<cr>
" nnoremap <silent> {Previous-Mapping} :TmuxNavigatePrevious<cr>


" run tmux commands from within vim
Plug 'benmills/vimux'
let g:VimuxHeight = "50"
let g:VimuxOrientation = "h"
let VimuxUseNearest = 1



" autocompletion from words visible in tmux panes
Plug 'wellle/tmux-complete.vim'
" <c-x><c-u> and then <c-u> or <c-n> a few times



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow plugins to utilize . command {{{

Plug 'tpope/vim-repeat'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" look and feel {{{

" make gvim colorschemes work in terminal
Plug 'godlygeek/csapprox'


" colorschemes
Plug 'flazz/vim-colorschemes'
Plug 'christophermca/meta5'
Plug 'joshdick/onedark.vim'
Plug 'sjl/badwolf'
Plug 'sonph/onehalf', {'rtp': 'vim/'}
Plug 'ayu-theme/ayu-vim'
Plug 'NLKNguyen/papercolor-theme'



" cycle through colorschemes
Plug 'vim-scripts/ScrollColors'
nnoremap <leader>yo :COLORSCROLL<cr>


" highlight different parentheses pairs with different colors
Plug 'luochen1990/rainbow'
let g:rainbow_active = 1
nnoremap <leader>yb :RainbowToggle<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" distraction free mode {{{

Plug 'junegunn/goyo.vim'

let g:goyo_width="120"
let g:goyo_height="100%"

nnoremap <leader>yy :Goyo<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" status bar {{{

Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'

let g:airline_detect_modified=1
let g:airline_detect_paste=1
let g:airline_inactive_collapse=0

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'unique_tail'

let g:airline_section_b = '%{expand("%:h")}'
let g:airline_section_a = '%{expand("%:t")}'
let g:airline_section_c = '%{airline#util#wrap(airline#extensions#hunks#get_hunks(),100)}%{airline#util#wrap(airline#extensions#branch#get_head(),80)}'

let g:airline_powerline_fonts=0
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''


" " airline extension: show list of buffers (like tabs)
" Plug 'bling/vim-bufferline'
" let g:airline#extensions#bufferline#enabled = 0

" airline extension: show columns of csv files
let g:airline#extensions#csv#enabled = 1

" airline extension: hide fugitive stuff
let g:airline#extensions#fugitiveline#enabled = 1

" airline extension: vim-grepper integration
let g:airline#extensions#grepper#enabled = 1


" simple status bar alternative?
" http://www.blaenkdenum.com/posts/a-simpler-vim-statusline/


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" do some git from within vim {{{

Plug 'tpope/vim-fugitive'

nnoremap <leader>gs  :Gstatus<cr>
nnoremap <leader>gd  :Gdiffsplit<cr>
nnoremap <leader>gmd :Gdiffsplit!<cr>
nnoremap <leader>gU  :Gread<cr>
nnoremap <leader>gw  :Gwrite<cr>
nnoremap <leader>gA  :Gwrite<cr>
nnoremap <leader>gcc :Git commit<cr>
nnoremap <leader>gca :Git commit --amend<cr>
nnoremap <leader>gb  :Git blame<cr>
nnoremap <leader>gpp :Git pull<cr>
nnoremap <leader>gpu :Git push<cr>
nnoremap <leader>gpU :exe ':Git push -u ' . system('git remote \| head -n1 \| tr -d "\\n"') . ' ' . system('git rev-parse --abbrev-ref HEAD \| tr -d "\\n"')<cr>
nnoremap <leader>geb :exe ':Git checkout -b ' . input('Branch name: ')<cr>
nnoremap <leader>geo :GitCheckoutInteractively<cr>


command! GitCheckoutInteractively :call GitCheckoutInteractively() <cr> " checkout git branch chosen with fzf
function! GitCheckoutInteractively()
    let word = expand("<cword>")
    call fzf#run(fzf#wrap({
                \ 'source': 'git branch',
                \ 'sink': function('GitCheckout')
                \ }))
endfunction
function! GitCheckout(ref)
    exe 'Git checkout ' . a:ref
endfunction


" resolve 3-way merge conflicts (diff view)
nnoremap <leader>g<down>    ]c
nnoremap <leader>g<up>      [c
nnoremap <leader>g<left>    :diffget //3<cr>    " get changes from the right
nnoremap <leader>g<right>   :diffget //2<cr>    " get changes from the left

" in Gdiff view, navigate and stage/checkout easily
augroup gitdiff
    au!
    au BufRead fugitive://* nnoremap <buffer> <down>  ]c
    au BufRead fugitive://* nnoremap <buffer> <up>    [c
    au BufRead fugitive://* nnoremap <buffer> <left>  do
    au BufRead fugitive://* nnoremap <buffer> <right> dp
augroup END


" show git status of lines on the left

Plug 'airblade/vim-gitgutter'

let g:gitgutter_max_signs = 4000

" GitGutter styling to use · instead of +/-
let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_modified_removed = '∙'

" do not map ic/ac text objects etc because I decide how I use them
let g:gitgutter_map_keys = 0

omap ih <plug>GitGutterTextObjectInnerPending
omap ah <plug>GitGutterTextObjectOuterPending
xmap ih <plug>GitGutterTextObjectInnerVisual
xmap ah <plug>GitGutterTextObjectOuterVisual

nnoremap <leader>yG   :GitGutterToggle<cr>
nnoremap <leader>yg   :GitGutter<cr> " redraw
nnoremap <leader>gg gg:GitGutterNextHunk<cr>zz9<c-e>zv
nnoremap <leader>gG  G:GitGutterPrevHunk<cr>zz9<c-e>zv
nnoremap <leader>gn   :GitGutterNextHunk<cr>zz9<c-e>zv
nnoremap <leader>gN   :GitGutterPrevHunk<cr>zz9<c-e>zv
nnoremap <down>       :GitGutterNextHunk<cr>zz9<c-e>zv
nnoremap <up>         :GitGutterPrevHunk<cr>zz9<c-e>zv
nnoremap <leader>ga   :GitGutterStageHunk<cr>
nnoremap <leader>gu   :GitGutterUndoHunk<cr>
nnoremap <leader>gi   :GitGutterPreviewHunk<cr>


" Resolve merge conflicts the easy way

Plug 'christoomey/vim-conflicted'

nnoremap <leader>gmt :Conflicted<cr>
nnoremap <leader>gmn :GitNextConflict<cr>

" navigate through hunks with ]c and [c

let g:diffget_local_map = '<left>'
let g:diffget_upstream_map = '<right>'


" show commit messages in a preview window

Plug 'rhysd/git-messenger.vim'

let g:git_messenger_no_default_mappings = v:true

nmap <leader>gB <Plug>(git-messenger)



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle unicode and digraphs easily {{{

Plug 'chrisbra/unicode.vim'

" inspect character under cursor
nnoremap ga :UnicodeName<cr>

" complete unicode with <c-x><c-z>
" complete digraph with <c-x><c-g>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" amazingly move everywhere {{{

Plug 'easymotion/vim-easymotion'

" prefix
map <M-l>  <plug>(easymotion-prefix)
map <esc>l <plug>(easymotion-prefix)
" keys to move to target
let g:EasyMotion_keys = 'asdfgh,.qwertuiocvbnmjkl'



" make f and t clever (i.e. repeatable. ',' and ';' will not be needed anymore.)
" Plug 'rhysd/clever-f.vim'

let g:clever_f_across_no_line = 0
" let g:clever_f_ignore_case = 1
let g:clever_f_smart_case = 1
" let g:clever_f_timeout_ms = 2000
let g:clever_f_fix_key_direction = 0
let g:clever_f_repeat_last_char_inputs = ["\<cr>", "\<tab>"]
let g:clever_f_chars_match_any_signs = '/'



" like f but with two characters
Plug 'justinmk/vim-sneak'

" interactive mode like easymotion
" let g:sneak#label = 1

" movement repeatable with same keystroke like clever-f
" (i don't really like this, as it makes movements unpredictable)
" let g:sneak#s_next = 1

" , always forwards ; always backwards
" let g:sneak#absolute_dir = 1

" use smartcase;
let g:sneak#use_ic_scs = 1

nmap f <plug>Sneak_s
nmap F <plug>Sneak_S

nmap , <plug>Sneak_;
nmap ; <plug>Sneak_,

xmap f :<C-U>call sneak#wrap(visualmode(), 2, 0, 1, 0)<CR>
xmap F :<C-U>call sneak#wrap(visualmode(), 2, 1, 1, 0)<CR>
xmap t :<C-U>call sneak#wrap(visualmode(), 2, 0, 0, 0)<CR>
xmap T :<C-U>call sneak#wrap(visualmode(), 2, 1, 0, 0)<CR>

omap f :<C-U>call sneak#wrap(v:operator,   2, 0, 1, 0)<CR>
omap F :<C-U>call sneak#wrap(v:operator,   2, 1, 1, 0)<CR>
omap t :<C-U>call sneak#wrap(v:operator,   2, 0, 0, 0)<CR>
omap T :<C-U>call sneak#wrap(v:operator,   2, 1, 0, 0)<CR>


" make f only match interesting characters
" Plug 'svermeulen/vim-NotableFt'

" nmap , <plug>NotableFtRepeatSearchForward
" nmap ; <plug>NotableFtRepeatSearchBackward
" nmap f <plug>NotableFtSearchFForward
" nmap s <plug>NotableFtSearchFBackward
" nmap F <plug>NotableFtSearchFBackward
" nmap t <plug>NotableFtSearchTForward
" nmap T <plug>NotableFtSearchTBackward



" highlight characters for f
" Plug 'unblevable/quick-scope'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" movements and text objects for parts of words {{{

" move with ,w in wordsLikeThisWord or words_like_this_word
" Plug 'bkad/CamelCaseMotion'

" call camelcasemotion#CreateMotionMappings(',') " DOES NOT WORK HERE

" also handle dashes with this plugin (hence w should move over them)
" (this breaks toggle_words for many cases)
" set iskeyword+=-


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better and custom text objects {{{

Plug 'wellle/targets.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Plug 'kana/vim-textobj-user'

" lines with the same indent level (ai/ii)
Plug 'kana/vim-textobj-indent'

" quotes (aq/iq)
Plug 'beloglazov/vim-textobj-quotes'

" functions (af/if)
Plug 'kana/vim-textobj-function'
Plug 'thinca/vim-textobj-function-javascript'

" function arguments (aa/ia)
" (somehow required one more keystroke)
Plug 'gaving/vim-textobj-argument'

" lines with ( [ { pairs (ac/ic)
" Plug 'Chun-Yang/vim-textobj-chunk'

" css rules (ac/ic)
Plug 'jasonlong/vim-textobj-css'
" Plug 'stephenway/vim-textobj-css'

" HTML/XML attributes (ax/ix)
Plug 'whatyouhide/vim-textobj-xmlattr'

" PHP Tags (aP/iP)
Plug 'akiyan/vim-textobj-php'

" folds (az/iz)
Plug 'kana/vim-textobj-fold'

" git hunks (ih) (now managed by gitgutter plugin)
" Plug 'gilligan/textobj-gitgutter'
" omap ah <plug>(textobj-gitgutter-i)
" vmap ah <plug>(textobj-gitgutter-i)

" entire buffer / 'all' (aa/ia)
Plug 'kana/vim-textobj-entire'
let g:textobj_entire_no_default_key_mappings = 1
omap aE <plug>(textobj-entire-a)
vmap aE <plug>(textobj-entire-a)
omap iE <plug>(textobj-entire-i)
vmap iE <plug>(textobj-entire-i)
" load dynamically with :TextobjEntireDefaultKeyMappings

" note that vimtex also defines mappings ic/id/ie/i$


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced searching {{{

" Plug 'google/vim-searchindex'
" Plug 'osyo-manga/vim-anzu'


Plug 'haya14busa/incsearch.vim'
let g:incsearch#auto_nohlsearch = 1
let g:incsearch#emacs_like_keymap = 1
let g:incsearch_cli_key_mappings = {
\   "\<c-n>": {
\     'key': '<over>(buffer-complete)',
\     'noremap': 1
\   },
\   "\<c-p>": {
\     'key': '<over>(buffer-complete-prev)',
\     'noremap': 1
\   },
\ }
" TODO: <c-k> and <c-j> to scroll through old searches. use arrows until fix.

" nnoremap /  <plug>(incsearch-forward)
" nnoremap ?  <plug>(incsearch-backward)
nnoremap / :call incsearch#call()<cr>
nnoremap ? :call incsearch#call({'command': '?'})<cr>


" searching in multiple files
" Plug 'mileszs/ack.vim'

" command to execute
let g:ackprg="ag --vimgrep --smart-case"

" " type a search pattern
" nnoremap <leader>ag :let g:jumplist = 'quickfixlist'<cr>
"                  \ :Ack!<space>""<left>

" " search for visual selection
" xnoremap <leader>ag y:let g:jumplist = 'quickfixlist'<cr>
"                  \ :<c-u>Ack! "-Q" "<c-r>""<cr>


" grep in vim like a pro
Plug 'mhinz/vim-grepper'

let g:grepper = {}
" let g:grepper.tools = ['git', 'ag', 'grep', 'rg']
let g:grepper.quickfix = 1
let g:grepper.switch = 0
let g:grepper.jump = 1
let g:grepper.prompt_mapping_side = '<c-l>'
let g:grepper.searchreg = 1

nnoremap <leader>/      :Grepper<cr>

nnoremap g/             :Grepper-side<cr>
nnoremap g*             :Grepper-side -cword -noprompt -tool ag<cr>
xnoremap g/             y:Grepper-side -noprompt -tool ag -query "<c-r>""<cr>
xmap     g*             g/

nnoremap <leader>*      <nop>
nnoremap <leader>**     :Grepper -cword -noprompt -tool ag <cr>
nnoremap <leader>*b     :Grepper -cword -noprompt -tool ag -buffer<cr>
nnoremap <leader>*o     :Grepper -cword -noprompt -tool ag -buffers<cr>
nmap     <leader>*B     <leader>*b
nmap     <leader>*O     <leader>*o

nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)
xmap <leader>* y:Grepper -noprompt -tool ag -query "<c-r>""<cr>

command! TODO Grepper -noprompt -tool git -query -E '(TODO|FIXME|XXX|\?\?\?)'



" % also matches HTML-tags/words etc
Plug 'vim-scripts/matchit.zip'


" hide (fold) everything except search string etc
Plug 'embear/vim-foldsearch'

let g:foldsearch_highlight = 0
let g:foldsearch_disable_mappings = 1

" show last search
nnoremap <leader>zs :Fs<cr>
nnoremap <leader>z/ :Fs<cr>
nnoremap <leader>zz :Fs<cr>

" show word under cursor
nnoremap <leader>z* :Fw<cr>
nnoremap <leader>zw :Fw<cr>

" show visual selection
vnoremap <leader>z y:Fp<space>\V<c-r>"<cr>

" change context size (number of lines around matches)
nnoremap <leader>z+ :Fi<cr>
nnoremap <leader>zi :Fi<cr>
nnoremap <leader>z- :Fd<cr>
nnoremap <leader>zd :Fd<cr>

" restore folds
nnoremap <leader>ze :Fe<cr>
nnoremap <leader>Z  :Fe<cr>

" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fuzzy find files etc (like Sublimes 'Goto Anything') {{{

" Plug 'kien/ctrlp.vim'

" let g:ctrlp_map = '#'
" let g:ctrlp_cmd = 'CtrlPBuffer'
nnoremap <leader>ef :CtrlPRoot<cr>
nnoremap <leader>er :CtrlPMRUFiles<cr>
nnoremap <leader>em :CtrlPMixed<cr>
nnoremap <leader>eo :CtrlPRoot<cr>
nnoremap <leader>eb :CtrlPBuffer<cr>

" ignore some stuff (in addition to 'wildignore')
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\v\.(class)$',
            \ }

" change appearance
"let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:8,results:8'

" custom key bindings when ctrlp prompt is open
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<tab>'],
            \ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<s-tab>'],
            \ 'PrtExpandDir()':       [],
            \ 'AcceptSelection("v")': ['<esc><enter>', '<c-l>', '<c-v>', '<rightmouse>'],
            \ 'ToggleFocus()':        [],
            \ 'ToggleRegex()':        ['<c-r>', '<esc>r'],
            \ 'ToggleType(1)':        ['<right>', '<c-up>'],
            \ 'ToggleType(-1)':       ['<left>', '<c-down>'],
            \ 'PrtCurLeft()':         ['<c-b>', '<c-^>'],
            \ 'PrtCurRight()':        ['<c-f>'],
            \ }

" also find hidden files
let g:ctrlp_show_hidden = 1

" only cache if we're in huge projects
let g:ctrlp_use_caching = 2000


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf - great fuzzy finder {{{
" (makes ctrlp and the ag plugin obsolete)
" (prefixing a word with ' makes it non-fuzzy)

" install 'fzf' package on the system. or:
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }

Plug 'junegunn/fzf.vim'

" prefix all the command names
let g:fzf_command_prefix = 'Fzf'

" layout [ down / up / left / right ]
let g:fzf_layout = { 'down': '~30%' }

" extra interactive key bindings
" (scroll with <c-k> and <c-j>
let g:fzf_action = {
  \ 'ctrl-x': 'split',
  \ 'ctrl-l': 'vsplit',
  \ 'ctrl-v': 'vsplit',
  \ }
" \ 'ctrl-k': 'previous-history',
" \ 'ctrl-j': 'next-history',

" enable per-command history
" (scroll through history with <c-p> and <c-n>)
let g:fzf_history_dir = '~/.local/share/fzf-history'

" override command to only match content (not filenames)
command! -bang -nargs=* FzfAg
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')
  \                         : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:20%:hidden', '?'),
  \                 <bang>0)

" Empty value to disable preview window altogether
let g:fzf_preview_window = ''
" Always enable preview window on the right with 60% width
" let g:fzf_preview_window = 'right:60%'

" open files by name
nnoremap <leader>fl :FzfLocate<space>
nnoremap <leader>fi :FzfFiles<cr>
nnoremap <leader>ef :FzfFiles<cr>
nnoremap <leader>eo :FzfGFiles<cr>
nnoremap <leader>eg :FzfGFiles?<cr>
nnoremap <leader>er :FzfHistory<cr>
nnoremap <leader>eb :FzfBuffers<cr>
nnoremap <leader>ec :FzfBuffers<cr>
nnoremap <leader><leader> :FzfBuffers<cr>

let g:fzf_tags_command = 'ctags -R -f .tags'
nnoremap <leader>et  :FzfTags<cr>
xnoremap <leader>et y:FzfTags <c-r>"<cr>

" type a search pattern
nnoremap <leader>j/         :FzfAg!<cr>
" search for word under cursor
nnoremap <leader>j*         :FzfAg! <c-r><c-w><cr>
nmap     <leader>jj         <leader>j*
" search for visual selection
xnoremap <leader>j*         y:<c-u>FzfAg! <c-r>"<cr>

" fuzzy search commands
nnoremap <leader>:          :FzfCommands<cr>
" fuzzy search command history
nnoremap <leader>h:         :FzfHistory:<cr>
" fuzzy search search history
nnoremap <leader>hs         :FzfHistory/<cr>
" fuzzy search helptags
nnoremap <leader>hh         :FzfHelptags<cr>

" autocomplete lines like a boss, even across multiple files
imap <c-x><c-l> <plug>(fzf-complete-line)


" adjust colors to colorscheme: gruvbox
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }


" Plug 'laher/fuzzymenu.vim'
nmap <leader>; <Plug>Fzm
vmap <leader>; <Plug>FzmVisual


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file searching and much more {{{
" http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/
" TODO CONFIGURE AND TEST

"Plug 'Shougo/vimproc.vim'
"Plug 'Shougo/unite.vim'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tags (variables, functions, ...) {{{

" install 'ctags' package on the system

" generate tag file manually
" (fails with '–exclude=@.gitignore' when the file does not exist!)
nnoremap <leader>eT :!ctags -R -f .tags .<cr>


" generate tag file automagically
Plug 'craigemery/vim-autotag'

let g:autotagTagsFile=".tags"



Plug 'majutsushi/tagbar'

" if I leave tagbar open but unfocused, q closes vim. that not what i want...
" so i autoclose and autofocus tagbar, which is cooler anyway

let g:tagbar_compact = 1
let g:tagbar_autoclose = 1

"let g:tagbar_map_close = 'Q'

noremap <silent> <leader>tb :TagbarToggle<cr>

"autocmd FileType vim nested :TagbarOpen()<cr>



" jump to definitions without relying on tags
" Plug 'misterbuckley/vim-definitive'
Plug 'sflip/vim-definitive'

nnoremap <leader>fd :FindDefinition<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" file management {{{

" sugar for unix shell commands like move/rename/delete/find files etc.
Plug 'tpope/vim-eunuch'

nnoremap <leader>rn :Rename <c-r>=expand("%:t")<cr>
nnoremap <leader>rm
            \ :if confirm("Remove file?", "&Yes\n&No", 2) == 1
            \ <bar> Delete
            \ <bar> endif <cr>

" Plug 'scrooloose/nerdtree'

let NERDTreeWinSize = 50
let NERDTreeQuitOnOpen = 1
let NERDTreeWinPos = 'right'

" show nerdtree from current file
" noremap <silent> <leader>tn :NERDTreeFind<cr>
" show/hide nerdtree
" noremap <silent> <leader>tN :NERDTreeToggle<cr>

" show/hide hidden files
let NERDTreeMapToggleHidden='.'


" pimp netrw
" Plug 'tpope/vim-vinegar'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" close all other buffers {{{

Plug 'vim-scripts/BufOnly.vim'

nmap <leader>qo :BufOnly<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" static code analysis {{{

" Plug 'scrooloose/syntastic'

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": ["ruby", "php"],
            \ "passive_filetypes": ["python", "tex", "scala"] }
" let g:syntastic_cpp_compiler = 'clang++'
" let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_c_cppcheck_args = ' -std=c++11 -stdlib=libc++'

nnoremap <silent> <leader>sc :SyntasticCheck<cr>
nnoremap <silent> <leader>sr :SyntasticReset<cr>
nnoremap <silent> <leader>st :SyntasticToggleMode<cr>
nnoremap <silent> <leader>si :SyntasticInfo<cr>


" install linters on the system:
" - pylint
" - jslint / jshint
" - csslint (but phpcs also can do css)
" - phpcs (https://github.com/squizlabs/PHP_CodeSniffer)
" - fsc
" - scalac
" - shellcheck

let g:syntastic_php_checkers = ['phpcs', 'phplint', 'php']
" let g:syntastic_javascript_checkers = ['eslint', 'jshint', 'jslint']
let g:syntastic_javascript_checkers = ['eslint', 'jshint']
let g:syntastic_scala_checkers = ['fsc']

" ignore these errors/warnings
let g:syntastic_quiet_messages = { "regex": [
            \ '\mMissing file doc comment',
            \ '\mFile is being conditionally included;',
            \ '\mFile is being unconditionally included;',
            \ '\mLine indented incorrectly;.*',
            \ '\mMulti-line IF statement not indented correctly;.*',
            \ '\mEach line in a multi-line IF statement must begin with a boolean operator.*',
            \ '\mSpace after opening parenthesis of function call prohibited.*',
            \ '\mExpected 0 spaces before closing bracket; .* found.*',
            \ '\mExpected \\"foreach (...) {\\n\\"; found \\"foreach(...) {\\n\\".*',
            \ '\mExpected \\"if (...) {\\n\\"; found \\"if(...) {\\n\\".*',
            \ '\mExpected \\"} elseif (...) {\\n\\"; found \\"} elseif(...) {\\n\\".*',
            \ '\mOpening brace should be on a new line.*',
            \ '\mBad line breaking before .+..',
            \ '\mInline control structures are discouraged',
            \ '\mClosing parenthesis of a multi-line IF statement must be on a new line',
            \ '\mLine exceeds 85 characters;.*',
            \ '\mYou must use .* style comments.*',
            \ '\mDon.t use adjoining classes.',
            \ '\mDon.t use IDs in selectors.',
            \ '\mHeading (h.) should not be qualified.',
            \ '\mShort PHP opening tag used;',
            \ '\m.$. was used before it was defined.',
            \ '\mpossible unwanted space at "{"',
            \ '\mFunction name .* is prefixed with a package name but does not begin with a capital letter',
            \ '\m.$. was used before it was defined.'
            \ ] }



" asynchronous alternative to syntastic
Plug 'w0rp/ale'

let g:ale_list_window_size = 5
let g:ale_lint_on_enter = 0
let g:ale_linters = {
\   'javascript': ['eslint'],
\   'typescript': ['tsserver', 'tslint'],
\   'vue': ['eslint']
\}
let g:ale_fixers = {
\    'javascript': ['eslint'],
\    'typescript': ['prettier'],
\    'vue': ['eslint'],
\    'scss': ['prettier'],
\    'html': ['prettier']
\}

let g:ale_python_pylint_options = '--rcfile $HOME/.vim/config/pylint.rc'

nnoremap <silent> <leader>sc :ALELint<cr>
nnoremap <silent> <leader>sn :ALENext<cr>
nnoremap <silent> <leader>sN :ALEPrevious<cr>
nnoremap <silent> <leader>sp :ALEPrevious<cr>
nnoremap <silent> <leader>sr :ALEDisable<cr>
nnoremap <silent> <leader>st :ALEToggle<cr>
nnoremap <silent> <leader>si :ALEInfo<cr>

highlight ALEErrorSign      ctermfg=203
highlight ALEWarningSign    ctermfg=227
highlight ALEInfoSign       ctermfg=227


" evaluate expression live, which is awesome
" Plug 'metakirby5/codi.vim'



" lookup stuff
" Plug 'dbeniamine/cheat.sh-vim'

let g:CheatSheetDefaultMode=0

let g:CheatSheetDoNotMap=1

" use line as query and paste result after line
nnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 3, '!')<cr>
vnoremap <script> <silent> <leader>kp
            \ :call cheat#cheat("", -1, -1, 3, 1, '!')<cr>


"result in buffer
nnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", getcurpos()[1], getcurpos()[1], 0, 0, '!')<cr>
vnoremap <script> <silent> <leader>kb
            \ :call cheat#cheat("", -1, -1, 2, 0, '!')<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" read the docs {{{

" Plug 'thinca/vim-ref'

":Ref STUFF



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" text editing {{{


" replace some motion or text object or selection with current yank
" Plug 'ReplaceWithRegister'
" nmap -rr <plug>ReplaceWithRegisterOperator
" nmap -re <plug>ReplaceWithRegisterLine
" xmap -r  <plug>ReplaceWithRegisterVisual
" I DON'T REALLY USE THIS BUT v3wp or -rw OCCASIONALLY


" preview register contents
Plug 'junegunn/vim-peekaboo'


" make the 0 register a stack (yank/delete multiple things without worrying)
" lightweight alternative to yankring
Plug 'maxbrunsfeld/vim-yankstack'
let g:yankstack_map_keys = 0
nmap <leader>pp <plug>yankstack_substitute_older_paste
nmap <leader>nn <plug>yankstack_substitute_newer_paste
"call yankstack#setup() " DOES NOT WORK HERE


" add and toggle comments with <leader>c<space> etc
Plug 'scrooloose/nerdcommenter'
" use leading space, but delete trailing space
let g:NERDSpaceDelims = 1
let g:NERDTrimTrailingWhitespace = 1
" do not nest by default
let g:NERDDefaultNesting = 1
let g:NERDAltDelims_javascript = 0
" align multiline comments
let g:NERDDefaultAlign = 'left'
" nmap -c <leader>c
" xmap -c <leader>c
" comment text objects and movements
for mov in ['j', 'k', 'gg', 'G', '(', ')', '{', '}', 'as', 'is', 'ap', 'ip']
    exe "nmap \<leader\>c" . mov . " V" . mov . "\<plug\>NERDCommenterInvert"
    exe "nmap -c"          . mov . " V" . mov . "\<plug\>NERDCommenterComment"
endfor
for i in range(1, 50)
    exe "nmap \<leader\>c" . i . "j V" . i . "j\<plug\>NERDCommenterInvert"
    exe "nmap \<leader\>c" . i . "k V" . i . "k\<plug\>NERDCommenterInvert"
    exe "nmap -c"          . i . "j V" . i . "j\<plug\>NERDCommenterComment"
    exe "nmap -c"          . i . "k V" . i . "k\<plug\>NERDCommenterComment"
endfor
" duplicate a line and comment out the first one
nmap <leader>cd <leader>cyp
" do not comment on new lines (except when already in insert mode)
nnoremap o o<esc>S
nnoremap O O<esc>S


" automagically add closing braces etc
Plug 'Raimondi/delimitMate'


" add a ; at the end of a line
"Plug 'lfilho/cosco.vim'
"inoremap <silent> <esc><enter> <esc>:call cosco#commaOrSemiColon()<cr>A<enter>
inoremap <silent> <esc><enter> <esc>A;<esc>^


" add/change/delete quotes/braces/... and more
Plug 'tpope/vim-surround'

" surround consistently in both modes and more comfortably on german keyboard
nmap -s ys
vmap -s S

" surround with quotes/parentheses/brackets quickly
vmap -q S'
vmap -Q S"
nmap -q ysiw'
nmap -Q ysiW'
vmap -b S)
vmap -B S}
nmap -b ysiw)
nmap -B ysiw}
nmap dq ds'
nmap dQ ds"

" toggle quotes {{{
function! ToggleQuotesWithVimSurround()
    let pos_cursor = getpos(".")[2]
    let linepart   = strpart(getline("."), pos_cursor - 1)
    let pos_single = stridx(linepart, "'")
    let pos_double = stridx(linepart, '"')
    if pos_single >= 0 && (pos_double < 0 || pos_single < pos_double)
        normal cs'"
    elseif pos_double >= 0 && (pos_single < 0 || pos_double < pos_single)
        normal cs"'
    endif
endfunction
" }}}
nnoremap <silent> -tq :call ToggleQuotesWithVimSurround()<cr>


" swap ('transpose') two words or arbitrary things
Plug 'tommcdo/vim-exchange'
" swap this word and the word before
nmap <leader>x <plug>(Exchange)
xmap <leader>x <plug>(Exchange)
nmap <leader>xc <plug>(ExchangeClear)
nmap <leader>xl <plug>(ExchangeLine)
nmap <leader>xx <leader>xiw


" " find and replace tool for multiple files (IDE like)
" Plug 'brooth/far.vim'
" nnoremap <leader>SS :Far  **<left><left><left>
" vnoremap <leader>SS :Far *  **<left><left><left>
" nnoremap <leader>SD :Fardo<cr>


" " add "printf" statements with shortcut
" Plug 'bergercookie/vim-debugstring'

" nmap <leader>ad <plug>DumpDebugString



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" multiple cursor like in Sublime {{{

" SEEMS NOT TO WORK PROPERLY FOR ME

" Plug 'terryma/vim-multiple-cursors'

" let g:multi_cursor_use_default_mapping=0

" " (only single keystrokes are possible at the moment)
" let g:multi_cursor_next_key='<c-n>'
" let g:multi_cursor_prev_key='<c-p>'
" let g:multi_cursor_skip_key='<c-x>'
" let g:multi_cursor_quit_key='<esc>'
" nnoremap -<c-c> :call multiple_cursors#quit()<cr>

" let g:multi_cursor_exit_from_visual_mode=1
" let g:multi_cursor_exit_from_insert_mode=0


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better diff {{{

" diff two visually selected blocks of code (in new tab)
Plug 'AndrewRadev/linediff.vim'
vnoremap <leader>dv :Linediff<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" run make or jobs asynchronously {{{

Plug 'tpope/vim-dispatch'



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better quickfix window {{{

" edit quickfix list (make changes directly after global search or linting)
Plug 'Olical/vim-enmasse'


" automatically resize quickfix window
Plug 'blueyed/vim-qf_resize'

let g:qf_resize_min_height = 1
let g:qf_resize_max_height = 8


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" move visual selections around (even blocks) {{{

"Plug 'shinokada/dragvisuals.vim'
"vmap <expr> <c-h>  DVB_Drag('left')
"vmap <expr> <c-l>  DVB_Drag('right')
"vmap <expr> <c-j>  DVB_Drag('down')
"vmap <expr> <c-k>  DVB_Drag('up')


" this is an improved version of dragvisuals
Plug 'zirrostig/vim-schlepp'

vmap <up>    <plug>SchleppUp
vmap <down>  <plug>SchleppDown
vmap <left>  <plug>SchleppLeft
vmap <right> <plug>SchleppRight

" duplicate
" (delete selection with x. by default, x and d do the same)
vmap -u <plug>SchleppDup


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" change 'true' to 'false' etc. in the blink of an eye {{{

Plug 'vim-scripts/toggle_words.vim'

noremap <silent> -tw :ToggleWord<cr>

let g:toggle_words_dict = {
            \ 'css': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['inline', 'block', 'none'],
            \     ['margin', 'padding'],
            \     ['relative', 'absolute', 'fixed', 'static'],
            \ ],
            \ 'html': [
            \     ['div', 'span'],
            \     ['head', 'body'],
            \     ['header', 'footer'],
            \ ],
            \ 'tex': [
            \     ['chapter', 'section', 'subsection']
            \ ],
            \ '*': [
            \     ['0', '1'],
            \     ['add', 'remove'],
            \     ['and', 'or'],
            \     ['ascending', 'descending'],
            \     ['authentication', 'authorization'],
            \     ['ASC', 'DESC'],
            \     ['begin', 'end'],
            \     ['big', 'little'],
            \     ['black', 'white'],
            \     ['clean', 'dirty'],
            \     ['create', 'delete'],
            \     ['dark', 'bright'],
            \     ['deep', 'shallow'],
            \     ['dynamic', 'static'],
            \     ['enable', 'disable'],
            \     ['enabled', 'disabled'],
            \     ['fast', 'slow'],
            \     ['fat', 'thin'],
            \     ['first', 'last'],
            \     ['forward', 'backward'],
            \     ['get', 'set'],
            \     ['good', 'bad'],
            \     ['happy', 'sad'],
            \     ['hard', 'soft'],
            \     ['head', 'tail'],
            \     ['hide', 'show'],
            \     ['high', 'low'],
            \     ['header', 'footer'],
            \     ['in', 'out'],
            \     ['initialize', 'terminate'],
            \     ['initialization', 'termination'],
            \     ['inner', 'outer'],
            \     ['left', 'right'],
            \     ['light', 'dark'],
            \     ['local', 'global'],
            \     ['login', 'logout'],
            \     ['long', 'short'],
            \     ['love', 'hate'],
            \     ['many', 'few'],
            \     ['master', 'slave', 'develop'],
            \     ['min', 'max'],
            \     ['more', 'less'],
            \     ['new', 'old'],
            \     ['next', 'previous'],
            \     ['on', 'off'],
            \     ['online', 'offline'],
            \     ['open', 'close'],
            \     ['public', 'private'],
            \     ['present', 'absent'],
            \     ['question', 'answer'],
            \     ['red','orange','yellow','green','blue','purple'],
            \     ['setup', 'teardown'],
            \     ['single', 'double', 'multi'],
            \     ['start', 'stop'],
            \     ['started', 'stopped'],
            \     ['starting', 'stopping'],
            \     ['strong', 'weak'],
            \     ['testing', 'production'],
            \     ['this', 'that'],
            \     ['top', 'bottom'],
            \     ['true', 'false'],
            \     ['up', 'down'],
            \     ['vertical', 'horizontal'],
            \     ['wide', 'narrow'],
            \     ['width', 'height'],
            \     ['write', 'read'],
            \     ['yes', 'no'],
            \ ],
            \ }


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Snippets {{{

" snippet engine
Plug 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger='<c-k>'
"let g:UltiSnipsListSnippets='<esc>.'
let g:UltiSnipsJumpForwardTrigger='<c-i>'
let g:UltiSnipsJumpBackwardTrigger='<c-o>'
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'sflipsnippets']


" snippet packs
Plug 'honza/vim-snippets'


" make html snippets work in php
" (this is a hack. but the 'ultisnips extends' approach does not work)
" http://stackoverflow.com/questions/12471398/how-to-enable-snippet-for-html-in-php-files
autocmd filetype php set filetype=php.html


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" advanced autocompletion {{{
"
" Plug 'Valloric/YouCompleteMe'
" let g:ycm_server_python_interpreter = '/usr/bin/python3'
" let g:ycm_path_to_python_interpreter = '/usr/bin/python3'
let g:ycm_key_invoke_completion = '<esc>.'
let g:ycm_key_list_select_completion   = ['<c-n>', '<down>', '<tab>', '<enter>']
let g:ycm_key_list_previous_completion = ['<c-p>', '<up>']
" let g:ycm_show_diagnostics_ui = 0


" autocompletion in command mode
Plug 'vim-scripts/CmdlineComplete'
cmap <c-p> <plug>CmdlineCompleteBackward
cmap <c-n> <plug>CmdlineCompleteForward


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" generate docs {{{

" generate javascript docs
" Plug 'heavenshell/vim-jsdoc'
" nnoremap <silent> -adj ?function<cr>:noh<cr><plug>(jsdoc)
nnoremap <silent> -adj :JsDoc<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" align stuff {{{

" show indentation level
Plug 'Yggdroot/indentLine'
let g:indentLine_enabled = 1
" let g:indentLine_char = '┊'
let g:indentLine_char = '|'
nnoremap <leader>yI :IndentLinesToggle<cr>

" Does not work. TODO: Fix it!
augroup indentline_enabled
    au!
    au BufWinEnter */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ IndentLinesDisable
                " \ echo 'jaaa' | IndentLinesDisable
augroup END


" align plugin
Plug 'junegunn/vim-easy-align'

" Start interactive EasyAlign in visual mode (e.g. vip-L=)
xmap -L <plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. -LG=)
nmap -L <plug>(EasyAlign)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto format {{{

" (also remember ==)

Plug 'Chiel92/vim-autoformat'

" install formatters on the system:
" - js-beautify (for HTML, CSS, JavaScript, JSON)
" - prettier (for JavaScript, TypeScript)
" - scalafmt (for scala)

nnoremap -af :Autoformat<cr>:GitGutter<cr>
vnoremap -af :Autoformat<cr>:GitGutter<cr>
nmap <leader>af -af
vmap <leader>af -af

let g:formatdef_php = '" php-cs-fixer.phar fix"'
let g:formatters_php = ['php']

let g:formatdef_scalafmt = '"scalafmt --stdin 2>/dev/null"'
let g:formatters_scala = ['scalafmt']

let g:formatdef_prettier_typescript = '"prettier --parser typescript"'
let g:formatters_typescript = ['prettier_typescript']


" autoformat for json does not work out with the plugin above. do this instead:
augroup json_map_autoformat
    au!
    au FileType json nnoremap -af :%!python -m json.tool<cr>
    au FileType json nmap <leader>af -af
augroup END

" autoformat for sql
augroup sql_map_autoformat
    au!
    au FileType sql nnoremap -af :%!sql-formatter-cli -<cr>
    au FileType sql nmap <leader>af -af
augroup END


" change wrapping of function arguments
Plug 'FooSoft/vim-argwrap'

nnoremap <silent> -tf :ArgWrap<cr>



" coercion:
" - MixedCase (crm),
" - camelCase (crc),
" - snake_case (crs),
" - UPPER_CASE (cru),
" - dash-case (cr-),
" - dot.case (cr.),
" - space case (cr<space>),
" - Title Case (crt)
Plug 'tpope/vim-abolish'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" don't worry about 'shiftwidth' and 'expandtab' etc. {{{

Plug 'tpope/vim-sleuth'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" handle trailing whitespace {{{

Plug 'vim-scripts/ShowTrailingWhiteSpace'
let g:ShowTrailingWhitespace = 1
command! -bar ShowTrailingWhitespaceOn  call ShowTrailingWhitespace#Set(1,1)
command! -bar ShowTrailingWhitespaceOff call ShowTrailingWhitespace#Set(0,1)
command! -bar ShowTrailingWhitespaceToggle call ShowTrailingWhitespace#Toggle(0)
        \ <bar>echo (ShowTrailingWhitespace#IsSet() ?
        \ 'Show trailing whitespace' : 'Not showing trailing whitespace')
nnoremap <silent> <leader>yA  :ShowTrailingWhitespaceToggle<cr>
nnoremap <silent> <leader>yst :ShowTrailingWhitespaceToggle<cr>

" (has a bug)
"Plug 'vim-scripts/JumpToTrailingWhiteSpace'


Plug 'vim-scripts/DeleteTrailingWhiteSpace'

" check for trailing whitespace when writing file
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'ask'

function! DeleteTrailingWhitespaceInGitRepo()
    if IsGitRepository(expand("%:p:h"))
        let b:DeleteTrailingWhitespace_Action = 'delete'
    end
endfunction

augroup delete_trailing_whitespace_in_git_repo
    autocmd!
    autocmd BufRead * call DeleteTrailingWhitespaceInGitRepo()
augroup END

" disable for specific files automatically
augroup delete_trailing_whitespace_disable
    au!
    au FileType mail let b:DeleteTrailingWhitespace = 0
augroup END

" enable/disable plugin
nnoremap <leader>dst :let g:DeleteTrailingWhitespace = 1 - g:DeleteTrailingWhitespace<cr>
            \ :echo g:DeleteTrailingWhitespace == 1 ?
            \ 'DeleteTrailingWhitespace enabled' :
            \ 'DeleteTrailingWhitespace disabled'<cr>
" delete trailing whitespace for selected line
vnoremap <silent> -dst :DeleteTrailingWhitespace<cr>
" delete trailing whitespace for whole buffer
nnoremap <silent> -dst :%DeleteTrailingWhitespace<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" colors (hex codes and such) {{{

" make colors visible (e.g. '#DD8844' will have orange background)
Plug 'ap/vim-css-color'

" convert between color formats (color under cursor or visually selected)
Plug 'amadeus/vim-convert-color-to'
nnoremap -cch :ConvertColorTo hex<cr>
nnoremap -ccr :ConvertColorTo rgb<cr>
nnoremap -cca :ConvertColorTo rgba<cr>

" launch colorpicker and insert color code
Plug 'blindFS/vim-colorpicker'
nnoremap <leader>icp :ColorPicker<cr>

" alternative colorpicker
" (readme is looking good, but throws errors)
"Plug 'KabbAmine/vCoolor.vim'
"nnoremap <leader>cp :VCoolor<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Completion and other smart IDE features via LSP {{{

Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'scalameta/coc-metals', {'do': 'yarn install --frozen-lockfile'}

let g:coc_start_at_startup = 1

" TODO: FIX (This fails with 'E488 Trailing characters')
command! CocToggle :call CocToggle() <cr> " Enable or Disable COC
function! CocToggle()
    if g:coc_enabled == 1
        CocDisable
    else
        CocEnable
    endif
endfunction
" nmap <leader>jot :if g:coc_enabled == 1 <bar> CocDisable <bar> else <bar> CocEnable <bar> endif <cr>
" nmap <leader>jot :if g:coc_enabled == 1 <bar> echo 'jaj' <bar> else <bar> echo 'no' <bar> endif
" nmap <leader>jot :if g:coc_enabled == 1 <bar> echo 'jaj' <bar> endif <cr>
nmap <leader>jot :CocToggle<cr>

nmap <leader>joi :CocInfo<cr>

nmap <leader>ie <Plug>(coc-diagnostic-info)
nmap <leader>i<bs> <Plug>(coc-float-hide)

nmap <leader>in <Plug>(coc-diagnostic-next)
nmap <leader>iN <Plug>(coc-diagnostic-prev)
nmap <leader>jd <Plug>(coc-definition)
nmap <leader>jD <Plug>(coc-declaration)
nmap <leader>ji <Plug>(coc-implementation)

nmap <leader>rf <Plug>(coc-rename)
nmap <leader>i<return> <Plug>(coc-fix-current)



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Language specific stuff {{{


Plug 'sheerun/vim-polyglot'

" helm is disabled so *.tpl files are considered smarty files
let g:polyglot_disabled = ['helm']


" Language: CSV {{{

Plug 'chrisbra/csv.vim'

augroup csv_on_read
    au!
    au FileType csv call SetupCSV()
augroup END

function! SetupCSV()
    nnoremap <silent> <leader>yy :CSVHiColumn <cr>              " highlight current column
    nnoremap <silent> <leader>yY :CSVHiColumn! <cr>             " undo highlight current column
    nnoremap <silent> <leader>yh :CSVHeader <cr>                " add window with header row
    nnoremap <silent> <leader>yH :CSVHeader! <cr>               " close window with header row
    nnoremap <silent> <leader>af :%CSVArrangeColumn <cr>        " align columns by adding spaces
    nnoremap <silent> <leader>AF :%CSVArrangeColumn! <cr>       " align columns by adding spaces recalculating widths
    nnoremap <silent> <leader>au :%CSVUnArrangeColumn <cr>      " undo aligning columns by removing spaces
endfunction
command! SetupCSV :call SetupCSV() <cr> " add mappings for CSV handling


" }}}


" Language: fish {{{

Plug 'dag/vim-fish'


" }}}
" Language: javascript {{{

Plug 'ianks/vim-tsx'

Plug 'Quramy/tsuquyomi'

augroup javascript_on_read
    au!
    au FileType javascript call SetupYarn()
    au FileType javascript call SetupTsuquyomi()
augroup END

augroup typescript_on_read
    au!
    au FileType typescript call SetupYarn()
    au FileType typescript call SetupTsuquyomi()
    au FileType typescript.tsx call SetupYarn()
    au FileType typescript.tsx call SetupTsuquyomi()
    " nnoremap <leader>AF  :call RunCommand("prettier --parser typescript --write **.tsx")<cr>
    nnoremap <leader>AF  :call RunCommand("yarn format")<cr>
augroup END

function! SetupNpm()
    nnoremap <leader>bi  :call RunCommand("npm install")<cr>
    nnoremap <leader>bs  :call RunCommand("npm start")<cr>
    nnoremap <leader>btt :call RunCommand("npm test")<cr>
    nnoremap <leader>btu :call RunCommand("npm test-unit")<cr>
    nnoremap <leader>bti :call RunCommand("npm test-int")<cr>
endfunction
command! -bang SetupNpm :call SetupNpm() <cr> " add mappings for development with NodeJS

function! SetupYarn()
    nnoremap <leader>bi  :call RunCommand("yarn install")<cr>
    nnoremap <leader>bd  :call RunCommand("yarn build")<cr>
    nnoremap <leader>bs  :call RunCommand("yarn start")<cr>
    nnoremap <leader>btt :call RunCommand("yarn test")<cr>
    nnoremap <leader>btu :call RunCommand("yarn test-unit")<cr>
    nnoremap <leader>bti :call RunCommand("yarn test-int")<cr>
endfunction
command! -bang SetupYarn :call SetupYarn() " add mappings for development with yarn

function! SetupTsuquyomi()
    nmap <leader>rf <Plug>(TsuquyomiRenameSymbolC)
    nmap <leader>rF <Plug>(TsuquyomiRenameSymbol)
    nmap <leader>iq : <C-u>echo tsuquyomi#hint()<CR>
endfunction
command! -bang SetupTsuquyomi :call SetupTsuquyomi() " add mappings for development with Tsuquyomi



" }}}
" Language: LaTeX {{{

Plug 'lervag/vimtex'

let g:tex_flavor = 'latex'
let g:vimtex_view_method='zathura'
"let g:vimtex_viewer_general='zathura'
let g:vimtex_quickfix_ignore_all_warnings=1
let g:vimtex_quickfix_mode=0

" YouCompleteMe integration
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
            \ 're!\\[A-Za-z]*(ref|cite)[A-Za-z]*([^]]*])?{([^}]*,?)*',
            \ 're!\\includegraphics([^]]*])?{[^}]*',
            \ 're!\\(include|input){[^}]*'
            \ ]

augroup map_latex
    au!
    au FileType latex nnoremap <leader>bb :VimtexCompileToggle<cr>
augroup END


" }}}
" Language: Markdown {{{

Plug 'shime/vim-livedown'
" requires `npm install -g livedown`

let g:livedown_browser = 'surf'

augroup markdown_on_read
    au!
    au FileType markdown call SetupMarkdown()
augroup END
function! SetupMarkdown()
    nnoremap <buffer> <leader>bs :LivedownPreview<cr>
    nnoremap <buffer> <leader>bx :LivedownKill<cr>
endfunction
command! -bang SetupMarkdown :call SetupMarkdown() " add mappings for development with Markdown


" }}}
" Language: PHP {{{

augroup php_on_read
    au!
    au FileType php call SetupPHP()
augroup END
function! SetupPHP()
    nnoremap <leader>bi  :call RunCommand("composer install")<cr>
    nnoremap <leader>bu  :call RunCommand("composer update")<cr>
    nnoremap <leader>btt :call RunCommand("composer test")<cr>
    nnoremap <leader>btu :call RunCommand("composer test")<cr>
    nnoremap <leader>bto :call RunCommand("composer test " . expand('%p'))<cr>
endfunction


" }}}
" Language: python {{{

augroup python_on_read
    au!
    au FileType python call SetupPython()
augroup END
function! SetupPython()
    nnoremap <leader>bs  :call RunCommand("python " . expand('%'))<cr>
    nnoremap <leader>b2  :call RunCommand("python2 " . expand('%'))<cr>
    nnoremap <leader>b3  :call RunCommand("python3 " . expand('%'))<cr>
endfunction


" }}}
" Language: R {{{

if v:version > 704 || v:version == 704 && has("patch1829")
    Plug 'jalvesaq/Nvim-R'
    " use with tmux
    let R_in_buffer = 0
    let R_applescript = 0
    let R_tmux_split = 1
    let R_vsplit = 1
    let R_rconsole_width = 80
    " custom keybindings
    let R_user_maps_only = 1
    augroup NvimR
        au!
        au FileType r nmap <c-r>s           <plug>RStart
        au FileType r nmap <c-r>q           <plug>RClose
        au FileType r nmap <c-r><c-l>       <plug>RClearConsole
        au FileType r nmap <leader><enter>  <plug>RSendFile
        au FileType r nmap <enter>          <plug>RSendLine
        au FileType r xmap <enter>          <plug>RSendSelection
    augroup END
endif


" }}}
" Language: rust {{{

augroup rust_on_read
    au!
    au FileType rust call SetupRust()
augroup END
function! SetupRust()
    let g:build_shell = 'bash'
    nnoremap <leader>bd  :call RunCommandInBuildShell("cargo build")<cr>
    nnoremap <leader>bD  :call RunCommandInBuildShell("cargo build --release")<cr>
    nnoremap <leader>bs  :call RunCommandInBuildShell("cargo run")<cr>
    nnoremap <leader>btc :call RunCommandInBuildShell("cargo check")<cr>
endfunction
command! -bang SetupRust :call SetupRust() " add mappings for development with Rust


" }}}
" Language: Scala {{{

" Plug 'ervandew/eclim'

" start eclipse
noremap <leader>aea :Start! /usr/lib/eclipse/eclimd<cr>
" test connection to eclipse
noremap <leader>aep :PingEclim<cr>
noremap <leader>aev :EclimValidate<cr>
" shutdown eclipse
noremap <leader>aeo :ShutdownEclim<cr>

" automated imports
noremap <leader>aei :ScalaImport<cr>

" goto definition
noremap <leader>ae<return> :ScalaSearch<cr>



Plug 'derekwyatt/vim-scala'
Plug 'derekwyatt/vim-sbt'

" Plug 'mdreves/vim-scaladoc' " uses python 2 which is ridiculous
" nnoremap <leader>sd :call scaladoc#Search(expand("<cword>"))<cr>

" Plug 'ensime/ensime-sbt', { 'branch': '2.0', 'for': 'scala' }
" Plug 'ensime/ensime-server', { 'branch': '2.0', 'for': 'scala' }
" Plug 'ensime/ensime-vim', { 'for': 'scala' }
" augroup map_scala
    " au!
    " au FileType scala
                " \ nnoremap <leader>9d :EnDeclaration<cr> |
                " \ nnoremap <leader>9D :EnDeclarationSplit v<cr> |
                " \ nnoremap <leader>9x :EnDocBrowse<cr> |
                " \ nnoremap <leader>9t :EnType<cr> |
                " \ " nnoremap <leader>9t :EnInspectType<cr> |
                " \ nnoremap <leader>9T :EnTypeCheck<cr> |
                " \ nnoremap <leader>9/ :EnSearch<space> |
                " \ nnoremap <leader>9r :EnRename<cr> |
                " \ nnoremap <leader>9i :EnOrganizeImports<cr> |
                " \ nnoremap <leader>9I :EnSugestImport<cr> |
                " \ nnoremap <leader>9 <nop>
" augroup END

Plug 'ckipp01/coc-metals'


" scala and ctags:
" https://advancedweb.hu/2017/01/10/vim-scala-ag-ctags/
" plugin that also creates ctags for libaries (can be slow and huge files):
" Plug 'ceedubs/sbt-ctags'

" show sbt errors in the quickfix window
" Plug 'dscleaver/sbt-quickfix'
" (does not work and is not necessary: https://gist.github.com/nkpart/5945278)

" :!sbt -Dsbt.log.noformat=true compile 2>&1 >/tmp/sbt.out
" let g:cfile = system('ag -l "\[(error|warn)\]" target/streams/ | head -n 1')
" let g:cfile_escaped = substitute(g:cfile, "\\$", "\\\\$", "g")

augroup scala_on_read
    au!
    au FileType scala call SetupScala()
augroup END

augroup sbt_on_read
    au!
    au FileType sbt.scala call SetupScala()
augroup END

function! IsScalaProject()
    return filereadable("build.sbt")
endfunction

command! -bang SetupScala :call SetupScala() " add settings and mappings for development with Scala
function! SetupScala()
    let l:sbt_version = system('grep -E "sbt\.version" project/build.properties | sed -E "s/.*=(.*)/\1/"')
    " sbt shows column in compiler errors since version 1.0.0 so there are two " cases for errorformat:
    if l:sbt_version
        set errorformat=
                    \%E\ %#[error]\ %f:%l:%c:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:%c:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    else
        set errorformat=
                    \%E\ %#[error]\ %f:%l:\ %m,%C\ %#[error]\ %p^,%-C%.%#,%Z,
                    \%W\ %#[warn]\ %f:%l:\ %m,%C\ %#[warn]\ %p^,%-C%.%#,%Z,
                    \%-G%.%#
    endif
    " the lines above work for compiler errors
    " the lines below are for testing errors but do not work yet
    " (for example because the file path is not absolute)
    " (also, I'm a noob with the efm matching syntax)
    " TODO: fix
                " \%E\ \%#[info]%.%#was\ not\ equal\ to%.%#(%f:%l),%Z,
                " \%E\ \%#[info]\ %.%#\ was\ not\ equal\ to\ %.%#\ (%f:%l),%Z,
                " \%E\ %#[info]\ %.%#\ ***\ FAILED\ ***,%C\ %#[info]\ %m\ (%f:%l)%Z,
    match ErrorMsg '\*\*\* FAILED \*\*\*'

    " TODO delete supershell escape sequences instead of supressing them
    let g:build_shell = 'sbt --color=true --supershell=false'
    let g:prompt_regex = '^sbt:.*>'

    highlight link SbtPrompt LineNr
    augroup sbt_prompt_highlighting
        au!
        au VimEnter,WinEnter * execute 'match SbtPrompt /' . g:prompt_regex . '/'
    augroup END

    nnoremap <leader>AF     :Terminal scalafmt<cr>

    nnoremap <leader>bd     :call RunCommandInBuildShell("compile")<cr>
    nnoremap <leader>bs     :call RunCommandInBuildShell("run")<cr>
    nnoremap <leader>btt    :call RunCommandInBuildShell("test; it:test")<cr>
    nnoremap <leader>btu    :call RunCommandInBuildShell("test")<cr>
    nnoremap <leader>bti    :call RunCommandInBuildShell("it:test")<cr>
    nnoremap <leader>bto    :call RunCommandInBuildShell(CalculateSbtTestOnlyCommand())<cr>
    nnoremap <leader>ba     :call RunCommandInBuildShell("scapegoat")<cr>
    nnoremap <leader>bx     :call RunCommandInBuildShell("clean")<cr>
    nnoremap <leader>br     :call RunCommandInBuildShell("console")<cr>
    nnoremap <leader>b<f5>  :call RunCommandInBuildShell("reload")<cr>

endfunction

function! CalculateSbtTestOnlyCommand()
    let l:lines_that_match_package = GetMatches('^package.*', 1, line('$'))
    let l:lines_that_match_class   = GetMatches('^\(class\|object\).*', 1, line('$'))
    if len(l:lines_that_match_package) == 0 || len(l:lines_that_match_class) == 0
        throw "Could not find test class name."
    endif
    let l:package  = substitute(l:lines_that_match_package[0], '^package\s\+\(\w\+\)', '\1', '')
    let l:class    = substitute(l:lines_that_match_class[0], '^\(class\|object\)\s\+\(\w\+\).*', '\2', '')
    let l:itPrefix = match(@%, '.*/it/.*') == -1 ? '' : 'it:'
    return l:itPrefix . "testOnly " . l:package . "." . l:class
endfunction

function! IsSbtRunning()
    " This only checks if SBT is running globally, not in the adjacent tmux pane # TODO: improve
    " the space before 'java' is important (to match pure sbt but ignore IntelliJ's sbt)
    call system('ps -ef | grep -v grep | grep " java.*sbt-launch.jar"')
    " call system('ps -ef | grep -v grep | grep sbt-launch.jar')
    return !v:shell_error
endfunction

" augroup scala_on_write
    " au!
    " au BufWritePost *.scala Dispatch! sbt -Dsbt.log.noformat=true parse
" augroup END


" TODO: find fzf scala docs

" }}}
" Language: Smarty {{{

Plug 'vim-scripts/smarty-syntax'

augroup smarty_on_read
    au!
    au BufNewFile,BufReadPost *.tpl set syntax=smarty
augroup END


" }}}
" Language: SQL {{{

augroup sql_on_read
    au!
    au FileType sql if !IsScalaProject() | call SetupSQLVimux() | endif
    au FileType sql if !IsScalaProject() | call SetupSQLDadBod() | endif
augroup END

command! -bang SetupSQL :call SetupSQLDadBod()<bar> call SetupSQLVimux() " add mappings for development with SQL

function! SetupSQLVimux()
    nnoremap <leader>bm  :call RunCommand("\\. " . expand('%:p'))<cr>
    nnoremap <leader>bp  :call RunCommand("\\i " . expand('%:p'))<cr>
endfunction
command! -bang SetupSQLVimux :call SetupSQLVimux() " add mappings for development with SQL (Vimux)


Plug 'tpope/vim-dadbod'

" For database connection, see ':help dadbod-variables'

function! SetupSQLDadBod()

    " sql query text object (aq)
    vnoremap <buffer> aq <esc>:call search(";", "cWz")<cr>:call search(";\\<bar>\\%^", "bsWz")<cr>:call search("\\v\\c^(select<bar>with<bar>insert<bar>update<bar>delete<bar>create)\>", "Wz")<cr>vg`'
    omap     <buffer> aq :normal vaq<cr>

    nnoremap    <leader>bdo :DB<space>
    nnoremap    <leader>bda :%DB<cr>
    xmap <expr> <leader>bd db#op_exec()
    "nmap        <leader>bdq vaq<leader>bd
    nmap        <leader>bdq vap<leader>bd

endfunction
command! -bang SetupSQLDadBod :call SetupSQLDadBod() " add mappings for development with SQL (DadBod)



" Plug 'cosminadrianpopescu/vim-sql-workbench'
" (This plugin sound promising, but is shit)

" let g:sw_config_dir = '/home/sflip/.sqlworkbench'
" let g:sw_exe = '/opt/SQLWorkbench/sqlwbconsole.sh'
" " let g:sw_cache = ''

" augroup sql_on_read_workbench
"     au!
"     au FileType sql call SetupSQLWorkbench()
" augroup END
" function! SetupSQLWorkbench()
"     nnoremap <leader>bs   <nop>
"     nnoremap <leader>bsc  :SWSqlBufferConnect<cr>
"     nnoremap <leader>bse  :SWDbExplorer<space>
"     nnoremap <leader>bsr  :SWSqlExecuteCurrent<cr>
"     vnoremap <leader>bsr  :SWSqlExecuteSelected<cr>
"     nnoremap <leader>bsa  :SWSqlExecuteAll<cr>
" endfunction


" }}}
" Language: (Salesforce) Force/Apex {{{

Plug 'neowit/vim-force.com'


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Graphical undo tree {{{

Plug 'sjl/gundo.vim'

let g:gundo_preview_height = 25
let g:gundo_right = 1
let g:gundo_preview_bottom = 1
let g:gundo_return_on_revert = 0

nnoremap <leader>ut :GundoToggle<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    call plug#end()

    " THE FOLLOWING MUST BE EXECUTED AFTER vim-plugin FINISHED:

    " call camelcasemotion#CreateMotionMappings(',')

    " fix compatibility issues with D mapping
    " (must be executed before the D custom mapping)
    call yankstack#setup()

    " fix s mapping
    " (must be executed after yankstack#setup())
    nmap s <plug>Sneak_S


endif


" disable powerline if it is installed
let g:powerline_loaded = 1


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  SETTINGS SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{

" options {{{


" set timeout for escape sequences
" (so that leaving insert mode does not last that long)
set timeout ttimeoutlen=50
" but mapping delay can be more
set timeoutlen=1200

" always assume modern terminal
set ttyfast
" don't draw everything (e.g. when playing macros)
set ttyfast
set lazyredraw

" allow mouse usage for bad days
if has('mouse')
    set mouse=a
endif

" disable all bells
set noerrorbells
set novisualbell
set t_vb=

" encoding should be utf-8 on every OS
set     encoding=utf-8
set fileencoding=utf-8
" <eol> line ending philosophies to try
" set fileformats=unix,dos,mac

" reload files changed outside vim
" (still have to change buffer or call :checktime)
set autoread

" automatically save buffer when it loses focus
if s:MyMode == 'mastery'
    let g:autosave = 1
else
    let g:autosave = 0
endif
augroup autosave
    au!
    au BufLeave,FocusLost * if (g:autosave && !exists("b:local_autosave"))
                          \ || (g:autosave && exists("b:local_autosave") && b:local_autosave)
                          \ || (!g:autosave && exists("b:local_autosave") && b:local_autosave)
    au BufLeave,FocusLost *     silent! update
    au BufLeave,FocusLost * endif
augroup END

" automatically change working directory to current file
" set autochdir

" command history size
set history=9999

" do not create swap files (they annoy me more than they help)
set noswapfile

" persistent undo over file close
" (the undodir needs to exist!)
if has ('persistent_undo')
    set undofile
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif

" meta files (like tagfiles)
set tags+=.tags

" custom dictionary
" (add words with zg and remove them with zw)
set spellfile=~/.vim/spellfile.utf-8.add,~/.vim/spellfile.local.utf-8.add

" syntax highlighting
syntax enable
let g:synmaxcol=300
exe 'set synmaxcol=' . g:synmaxcol

" highlight matching bracket when typing
" set showmatch
" set matchtime=4

" do not wrap lines until I say so
set nowrap

" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" line numbers
set number
set relativenumber
set numberwidth=6

" highlight current cursor position
let g:cursorposition = 0
if g:cursorposition
    set cursorline cursorcolumn
endif
" ... but not in insert mode or inactive windows
augroup cursorposition
    au!
    au WinLeave,InsertEnter,FocusLost   * set nocursorline nocursorcolumn
    au WinEnter,InsertLeave,FocusGained * if g:cursorposition
    au WinEnter,InsertLeave,FocusGained *     set cursorline cursorcolumn
    au WinEnter,InsertLeave,FocusGained * endif
augroup END

" statusline
set statusline="%f%m%r%h%w [%Y] [0x%02.2B]%< %F%=%4v,%4l %3p%% of %L"
set showcmd
set ruler
set laststatus=2
set noshowmode

" completions behaviour
set wildmode=longest,full
set wildmenu

" ignore some files
set wildignorecase
set wildignore+=*.swp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
set wildignore+=*.o,*.obj,*.pyc,*.class
set wildignore+=*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.odt,*.ods
set wildignore+=*.jpg,*.jpeg,*.png
set wildignore+=*.mp3,*.mp4,*.mpg,*.mpeg,*.flv,*.wav
set wildignore+=*.aux,*.bbl,*.blg,*.fdb_latexmk,*.fls,*.loe,*.lof,*.out,*.toc

" scrolling
" start scrolling when we're 8 lines away from margins
set scrolloff=5
set sidescrolloff=15
set sidescroll=1

" search preferences
set incsearch
set ignorecase
set smartcase
set gdefault
set nohlsearch
set nowrapscan

" allow the cursor to move where there is no character
set virtualedit=block,insert,onemore


" characters to show in list mode
set listchars=nbsp:⦸
" set listchars+=eol:$
set listchars+=extends:❯
set listchars+=precedes:❮
set listchars+=tab:--
if v:version > 704 || v:version == 704 && has("patch711")
    set listchars+=space:·
    " set listchars+=trail:•
endif

" how it looks like if we wrap lines
if v:version > 704 || v:version == 704 && has("patch338")
    set breakindent
endif
set showbreak=↪

" how other stuff looks like
set fillchars+=vert:\ "
set fillchars+=fold:─

" use 4 spaces instead of tabs
" (otherwise handled by sleuth)
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4

" indent after open braces etc
set autoindent
set smartindent
set smarttab

" 1 space, not 2, when joining sentences
set nojoinspaces

" allow <bs> to delete everything
set backspace=indent,eol,start

" when incrementing numbers with leading zeros, don't interpret them as octal
set nrformats-=octal

" allow to :edit multiple files in buffers without writing changes
set hidden

" puts new split windows to the bottom of the current
set splitbelow
" puts new vsplit windows to the right of the current
set splitright

" preview-window (e.g. used by vim-dadbod)
set previewheight=40



" }}}


" colorscheme {{{

let g:light_or_dark_theme = 'dark'


function! FixHighlighting()

    if g:light_or_dark_theme == 'dark'
        let g:indentLine_setColors = 1
        let g:indentLine_color_term = 237
        highlight CursorLine              ctermbg=236 cterm=NONE
        highlight CursorColumn            ctermbg=236
        highlight ColorColumn             ctermbg=237
        highlight DiffAdd                 ctermbg=234
        highlight DiffDelete              ctermbg=234
        highlight DiffChange              ctermbg=234
        highlight DiffText                ctermbg=233
        highlight ShowTrailingWhitespace  ctermbg=235
        highlight VertSplit               ctermfg=238
        highlight Folded                  ctermfg=238 ctermfg=248
        highlight LineNr                  ctermbg=237 ctermfg=243
        " highlight SignColumn              ctermbg=237
        " highlight GitGutterAdd            ctermbg=235
        " highlight GitGutterChange         ctermbg=235
        " highlight GitGutterDelete         ctermbg=235
        " highlight GitGutterChangeDelete   ctermbg=235
        " highlight Conceal                 ctermbg=236
        " highlight Search                  ctermbg=237 ctermfg=white
        highlight Error                   ctermbg=162
        highlight Todo                    ctermfg=132
        highlight Sneak                   ctermfg=72 ctermbg=234
        highlight EasyMotionTarget        ctermfg=72
        highlight EasyMotionTarget2First  ctermfg=72
        highlight EasyMotionTarget2Second ctermfg=108

    elseif g:light_or_dark_theme == 'light'
        let g:indentLine_setColors = 1
        let g:indentLine_color_term = 250
        highlight CursorLine   ctermbg=252
        highlight CursorColumn ctermbg=252
        highlight ColorColumn  ctermbg=250
        highlight ShowTrailingWhitespace ctermbg=250

    else
        echoerr "Unknown value for g:light_or_dark_theme (" . g:light_or_dark_theme . ")"
    endif

endfunction
command! -bang FixHighlighting :call FixHighlighting() " Overwrite some highlight group definitions


highlight PokemonPikachu ctermfg=233 ctermbg=184
match PokemonPikachu /pikachu/


function! SetColorscheme()

    if s:MyMode == 'mastery'

        if g:light_or_dark_theme == 'dark'
            set background=dark

            " dark colorschemes that I like or once liked:
            " ----------------------------------------------
            " apprentice badwolf blackboard blacklight candycode dante desertEx
            " gruvbox iceberg jellybeans luna-term meta5 materialbox molokai
            " onedark pride seoul256 Tomorrow-Night up woju

            colorscheme gruvbox

            " dark airlinethemes that I like or once liked:
            " ----------------------------------------------
            " base16 base16_summerfruit base16_grayscale behelit distinguished
            " kalisi laederon lucius minimalist raven serene tomorrow ubaryd wombat
            " zenburn

            let g:airline_theme='distinguished'

        elseif g:light_or_dark_theme == 'light'
            set background=light

            " light colorschemes that I like or once liked:
            " ----------------------------------------------
            " lucius peaksea seoul256-light Tomorrow-Night

            colorscheme seoul256-light

            " light airlinethemes that I like or once liked:
            " ----------------------------------------------
            " bubblegum lucius sol

            let g:airline_theme='lucius'

        else
            echoerr "Unknown value for g:light_or_dark_theme (" . g:light_or_dark_theme . ")"
        endif

        FixHighlighting

    else

        colorscheme desert " fallback colorscheme

        let g:cursorposition = 0
        set nocursorcolumn nocursorline
        highlight CursorLine   ctermbg=233
        highlight CursorColumn ctermbg=233
        highlight ColorColumn  ctermbg=233

    endif

endfunction

call SetColorscheme()


command! -bang ToggleColorschemeDarkOrLight :call ToggleColorschemeDarkOrLight() " Set colorscheme etc. to dark or light
function! ToggleColorschemeDarkOrLight()
    if g:light_or_dark_theme == 'dark'
        let g:light_or_dark_theme = 'light'
    else
        let g:light_or_dark_theme = 'dark'
    endif
    call SetColorscheme()
endfunction

nnoremap <leader>oC :ToggleColorschemeDarkOrLight<cr>


" }}}




" cursor change in insert mode (from block to i-beam) {{{

" http://stackoverflow.com/questions/6488683/how-do-i-change-the-vim-cursor-in-insert-normal-mode

" escape sequence depends on the terminal ('konsole', 'urxvt')
let terminal='urxvt'



if terminal == 'konsole'
    " (this also resets the terminal font size, which is annoying)
    if exists('$TMUX')
        let &t_SI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=1\x7\<esc>\\"
        let &t_EI = "\<esc>Ptmux;\<esc>\<esc>]50;CursorShape=0\x7\<esc>\\"
    else
        let &t_SI = "\<esc>]50;CursorShape=1\x7"
        let &t_EI = "\<esc>]50;CursorShape=0\x7"
    endif
elseif terminal == 'urxvt'
    let &t_SI = "\e[6 q"
    let &t_EI = "\e[2 q"
endif



" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  FUNCTION SECTION                                                            "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


" Execute a interactive shell command in full screen {{{
command! -nargs=1 -bang Shell :call Shell(<q-args>)
function! Shell(commandline)
    if has('nvim')
        tabnew
        execute 'terminal ' . a:commandline
        startinsert
    else
        execute '!' . a:commandline
    endif
endfunction
" }}}


" URL encode a string. ie. Percent-encode characters as necessary. {{{
function! UrlEncode(string)

    let result = ""

    let characters = split(a:string, '.\zs')
    for character in characters
        if character == " "
            let result = result . "+"
        elseif CharacterRequiresUrlEncoding(character)
            let i = 0
            while i < strlen(character)
                let byte = strpart(character, i, 1)
                let decimal = char2nr(byte)
                let result = result . "%" . printf("%02x", decimal)
                let i += 1
            endwhile
        else
            let result = result . character
        endif
    endfor

    return result

endfunction

" Returns 1 if the given character should be percent-encoded in a URL encoded
" string.
function! CharacterRequiresUrlEncoding(character)

    let ascii_code = char2nr(a:character)
    if ascii_code >= 48 && ascii_code <= 57
        return 0
    elseif ascii_code >= 65 && ascii_code <= 90
        return 0
    elseif ascii_code >= 97 && ascii_code <= 122
        return 0
    elseif a:character == "-" || a:character == "_" || a:character == "." || a:character == "~"
        return 0
    endif

    return 1

endfunction

" }}}


" improved path expansion (prepend './' if necessary)  {{{
function! ExpandPrependThisDir(expr)
    if expand(a:expr . ':h') == '.'
        return './' . expand(a:expr)
    else
        return expand(a:expr)
    endif
endfunction
" }}}


" set cwd to filepath {{{
function! SetCwdToFilePath()
    execute "cd " . expand('%:p:h')
endfunction
" }}}


" determine whether directory (or some parent) is a git repository or not {{{
function! IsGitRepository(dir)
    call system('cd "'.expand(a:dir).'" && git rev-parse --is-inside-work-tree >/dev/null 2>&1')
    return !v:shell_error
endfunction
" }}}


" copy current filename/path/dir (unnamed register/clipboard/fucking everywhere) {{{
function! CopyFileNameOrPathOrDir(modifiers)
    let @" = expand(a:modifiers)
    let @+ = expand(a:modifiers)
    let @* = expand(a:modifiers)
    echo @"
endfunction
" }}}


" toggle syntax highlighting {{{

command! DisableSyntax :syntax off          " Disable syntax highlighting (globally)
command! EnableSyntax  :syntax enable       " Enable syntax highlighting (globally)

command! ToggleSyntax :call ToggleSyntax() " Disable or enable syntax highlighting (globally)
function! ToggleSyntax()
   if exists("g:syntax_on")
       DisableSyntax
   else
       EnableSyntax
   endif
endfunction

command! DisableSyntaxCurrentBuffer :setlocal syntax=OFF " Disable syntax highlighting (current buffer)
command! EnableSyntaxCurrentBuffer  :setlocal syntax=ON  " Enable syntax highlighting (current buffer)

command! ToggleSyntaxCurrentBuffer :call ToggleSyntaxCurrentBuffer() " Disable or enable syntax highlighting (current buffer)
function! ToggleSyntaxCurrentBuffer()
   if &syntax == "OFF"
       EnableSyntaxCurrentBuffer
   else
       DisableSyntaxCurrentBuffer
   endif
endfunction

" }}}


" get a list of buffers {{{
function! GetBufferList()
    silent! redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction
" }}}

" find buffers with a running terminal (returns list of bufnum) {{{
function! GetTerminalBuffers()
    if !has('nvim')
        " TODO: make this work in regular vim
        echoerr "Sorry, this is only implemented in neovim (right now)."
        return
    endif
    " terminals have b:terminal_job_id defined
    let l:terminals = filter(range(1, bufnr('$')), 'bufexists(v:val) && getbufvar(v:val, "terminal_job_id", 0)')
    return l:terminals
endfunction
" }}}

" find bufnum of the first buffer with a running terminal (or 0) {{{
function! GetTerminalBuffer()
    let l:terminals = GetTerminalBuffers()
    if len(l:terminals) == 0
        return 0
    else
        return l:terminals[0]
    endif
endfunction
" }}}



" toggle quickfix or location list {{{
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}


" return 1 iff the active window contains a quickfix buffer and there are no other windows with normal buffers. {{{
function! IsOrphanQuickfixList()
    let winnr = winnr("$")
    while winnr >= 1
        if getbufvar(winbufnr(winnr), "&buftype") == ""
            return 0
        endif
        let winnr -=1
    endwhile
    return getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"
endfunction
" improve quickfix/location list
augroup quickfix
    au!
    " automatically close quickfix/location list when alone
    au BufEnter * if IsOrphanQuickfixList()
    au BufEnter *     bdelete
    au BufEnter * endif
augroup END
" }}}



" make columns after &textwidth visible or invisible {{{
function! SetColorColumn(mode)
    let col = &textwidth
    let expr = join(range(col + 1, 255), ',')
    if (&colorcolumn == "" || &colorcolumn != expr) && a:mode == 'toggle' || a:mode == "on"
       execute "set colorcolumn=" . expr
    else
       execute "set colorcolumn="
    endif
endfunction
" }}}

"... and call this function when &textwidth is changed
if v:version > 704 || v:version == 704 && has("patch786") " if has ('patch-7.4.786')
    augroup colorcolumn
        au!
        au OptionSet textwidth if &textwidth != 0
        au OptionSet textwidth      call SetColorColumn('on')
        au OptionSet textwidth else
        au OptionSet textwidth      set colorcolumn=
        au OptionSet textwidth endif
    augroup END
endif


" Return list of matches for given pattern in given range.
" This only works for matches within a single line.
" Empty hits are skipped so search for '\d*\ze,' is not stuck in '123,456'.
" If omit match() 'count' argument, pattern '^.' matches every character.
" Using count=1 causes text before the 'start' argument to be considered.
function! GetMatches(pattern, line1, line2)
  let hits = []
  for line in range(a:line1, a:line2)
    let text = getline(line)
    let from = 0
    while 1
      let next = match(text, a:pattern, from, 1)
      if next < 0
        break
      endif
      let from = matchend(text, a:pattern, from, 1)
      if from > next
        call add(hits, strpart(text, next, from - next))
      else
        let char = matchstr(text, '.', next)
        if empty(char)
          break
        endif
        let from = next + strlen(char)
      endif
    endwhile
  endfor
  return hits
endfunction


" Search across newlines {{{
" separated with whitespace (if no '!'),
" or with non-word characters (if '!' added to command).
" http://vim.wikia.com/wiki/Search_across_multiple_lines
function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag SearchMultiLine call SearchMultiLine(<bang>0, <f-args>)|normal! /<c-r>/<cr>

" }}}



" Search for current word and replace with given text for files in arglist. {{{
" http://vim.wikia.com/wiki/Search_and_replace_in_multiple_buffers
function! Replace(bang, replace)
    " (we use 'gdefault')
    " let flag = 'ge'
    let flag = 'gge'
    if !a:bang
        let flag .= 'c'
    endif
    let search = '\<' . escape(expand('<cword>'), '/\.*$^~[') . '\>'
    let replace = escape(a:replace, '/\&~')
    execute 'argdo %s/' . search . '/' . replace . '/' . flag
endfunction
command! -nargs=1 -bang Replace :call Replace(<bang>0, <q-args>)

" }}}


" comment the current line / visual selection with html syntax {{{
function! ToggleHTMLComment(mode)

    " visual mode
    if a:mode == "v"
        let lineFrom = getpos("'<")[1]
        let lineTo   = getpos("'>")[1]
        let range    = lineFrom . "," . lineTo
        let text     = join(getline(lineFrom, lineTo))

    " normal mode
    elseif a:mode == "n"
        let range = "."
        let text = getline(".")

    endif

    " do the toggle
    if matchstr(text, '\V<!--') == ""
        " comment
        " .substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:
        " execute range . escape("substitute:\v^(\s*)(.*)$:\1<!-- \2 -->:", '\')
        execute range . "substitute:\\v^(\\s*)(.*)$:\\1<!-- \\2 -->:"
    else
        " uncomment
        " .substitute:\v\<!--\s*(.*\s)\s*--\>:\1:
        " execute range . escape("substitute:\v\<!--\s*(.*\s)\s*--\>:\1:", '\')
        execute range . "substitute:\\v\\<!--\\s*(.*\\s)\\s*--\\>:\\1:"
    endif

endfunction
" }}}


" insert a line some characters below {{{
function! InsertCharLine(char, num)
    let char = a:char
    let num = a:num
    let linenumber = line(".")
    call append(linenumber, repeat(char, num))
endfunction
" }}}


" insert a box of characters around the word in the current line {{{
function! InsertCharBox(char)
    let char = a:char
    let linenumber = line(".")
    let line = getline(".")
    let len = strlen(line) + 2 + 2
    let borderline = repeat(char, len)
    execute '.substitute/^/' . char . ' /'
    execute '.substitute/$/ ' . char . '/'
    call append(linenumber, repeat(char, len))
    call append(linenumber-1, repeat(char, len))
endfunction
" }}}


" poor-man's (fake IDE) auto-import {{{
" searches for import statement for word under cursor and adds it to buffer
nnoremap <leader>io :call AutoImportFake()<cr>
command! -bar AutoImportFake call AutoImportFake()
function! AutoImportFake()
    let word = expand("<cword>")
    call fzf#run(fzf#wrap({
                \ 'source': 'git grep -h "import.*' . word . '" | sort | uniq',
                \ 'sink': function('AddImportStatement')
                \ }))
endfunction
function! AddImportStatement(statement)
    normal gg
    let linenumber = search('import')
    put =a:statement
endfunction
" }}}




" ranger as a file chooser {{{
function! RangerChooser(starting_dir)
    let temp = tempname()

    " in vim, this is blocking, in neovim it's not
    call Shell('ranger --choosefiles=' . shellescape(temp) . ' --cmd="set viewmode multipane" ' . a:starting_dir)

    if has('nvim')
        " TODO: make this work, because in neovim Shell/:terminal is non-blocking, but we need a blocking ranger instance
        " https://vi.stackexchange.com/questions/10292/how-to-close-and-and-delete-terminal-buffer-if-programs-exited
        echoerr "Sorry, file choosing via Ranger is (yet) working in Neovim."
    else
        if !filereadable(temp)
            redraw!
            return
        endif
        let names = readfile(temp)
        if empty(names)
            redraw!
            return
        endif
        " Edit the first item.
        exec 'edit ' . fnameescape(names[0])
        " Add any remaning items to the arg list/buffer list.
        for name in names[1:]
            exec 'argadd ' . fnameescape(name)
        endfor
    endif

    redraw!
endfunction
command! -bar RangerChooser call RangerChooser(getcwd())
command! -bar RangerChooserFromCurrentFile :call RangerChooser(expand('%:p:h'))
" }}}



" change search mode (what happens when hitting n) {{{
" http://vim.wikia.com/wiki/Make_search_results_appear_in_the_middle_of_the_screen
" TODO: make it easy to change default
function! s:SearchMode()
  if !exists('s:searchmode') || s:searchmode == 0
    echo 'Search next: scroll as few times as possible (smart)'
    nnoremap <silent> n n:call <sid>MaybeScroll()<cr>zv
    nnoremap <silent> N N:call <sid>MaybeScroll()<cr>zv
    let s:searchmode = 1
  elseif s:searchmode == 1
    echo 'Search next: scroll hit to middle'
    nnoremap n nzzzv
    nnoremap N Nzzzv
    let s:searchmode = 2
  else
    echo 'Search next: normal'
    " nunmap n
    " nunmap N
    nnoremap n nzv
    nnoremap N Nzv
    let s:searchmode = 0
  endif
endfunction
" If cursor is on top, scroll to bottom, if it is on bottom, scroll to top
function! s:MaybeScroll()
  if winline() == &scrolloff + 1
    normal! zb
  elseif winline() == winheight(0) - &scrolloff
    normal! zt
  endif
endfunction

" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" send buffer via slack {{{
function! SendBufferViaSlack(channel)
    let l:channel = substitute(a:channel, '\[.*\] \[.*\]\s\+', '', '')
    exec "write !slackcat --channel '" . l:channel . "' --filename " . expand("%:t")
endfunction
" }}}


" send buffer via slack after choosing channel interactively {{{
function! SendBufferViaSlackChooseChannel()
    " let content = system("slackcat --list")
    " echo content
    " let choice = input("Which channel: ")
    " call SendBufferViaSlack(choice)
    call fzf#run({
                \ 'source': 'slackcat --list',
                \ 'sink': function('SendBufferViaSlack')
                \ })
endfunction
nnoremap <leader>iS :call SendBufferViaSlackChooseChannel()<cr>
" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.
" Now you can use ToggleHighlightInterestingWord(n) where n is a number from 1-9
" to highlight the current word in a specific color.

let g:match_id_base = 86750

function! ToggleHighlightInterestingWord(n)
    normal! mZ
    let match_id = g:match_id_base + a:n
    silent! windo let new_match = matchdelete(match_id)
    if new_match
        normal! "zyiw
        let pattern = '\V\<' . escape(@z, '\') . '\>'
        windo call matchadd("InterestingWord" . a:n, pattern, 1, match_id)
    endif
    normal! `Z
endfunction

function! RemoveAllInterestingWordHighlights()
    silent! windo call matchdelete(g:match_id_base + 1)<bar>
    silent! windo call matchdelete(g:match_id_base + 2)<bar>
    silent! windo call matchdelete(g:match_id_base + 3)<bar>
    silent! windo call matchdelete(g:match_id_base + 4)<bar>
    silent! windo call matchdelete(g:match_id_base + 5)<bar>
    silent! windo call matchdelete(g:match_id_base + 6)<cr>
    silent! windo call matchdelete(g:match_id_base + 7)<cr>
    silent! windo call matchdelete(g:match_id_base + 8)<cr>
    silent! windo call matchdelete(g:match_id_base + 9)<cr>
endfunction

" Mappings
nnoremap <silent> <leader>1 :call ToggleHighlightInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call ToggleHighlightInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call ToggleHighlightInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call ToggleHighlightInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call ToggleHighlightInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call ToggleHighlightInterestingWord(6)<cr>
nnoremap <silent> <leader>7 :call ToggleHighlightInterestingWord(7)<cr>
nnoremap <silent> <leader>8 :call ToggleHighlightInterestingWord(8)<cr>
nnoremap <silent> <leader>9 :call ToggleHighlightInterestingWord(9)<cr>
nnoremap <silent> <leader>0 :call RemoveAllInterestingWordHighlights()<cr>

" Highlights (color definitions)
hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#086A7E ctermbg=33
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#08471D ctermbg=28
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#C71640 ctermbg=200
hi def InterestingWord7 guifg=#000000 ctermfg=16 guibg=#5B0F74 ctermbg=57
hi def InterestingWord8 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord9 guifg=#000000 ctermfg=16 guibg=#553E26 ctermbg=220


" }}}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" handle binary documents {{{

augroup read_special_files
    au!
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}
                \ call s:filter_special_files()
augroup END

fu! s:filter_special_files() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif
    let fname = shellescape(expand('%:p'), 1)
    let ext = expand('%:e')
    let ext2cmd = {
    \               'doc' : '%!antiword '.fname,
    \               'docx': '%!pandoc -f docx -t markdown '.fname,
    \               'epub': '%!pandoc -f epub -t markdown '.fname,
    \               'odp' : '%!odt2txt '.fname,
    \               'odt' : '%!odt2txt '.fname,
    \               'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
    \               'rtf' : '%!unrtf --text',
    \             }
    if has_key(ext2cmd, ext)
        setl ma noro
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl noma ro nomod
    endif
endfu

" }}}



" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
"  COMMAND AND KEYMAP SECTION                                                  "
"  (not plugin specific)                                                       "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" {{{


let mapleader=' '


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FIX AND SPEEDUP MY TYPING {{{

iabbrev dpr         deprecated
iabbrev todo        TODO:
iabbrev todod       TODO: delete this debugging statement
iabbrev todof       TODO: FIX

" password store
augroup abbreviations_password_store
    autocmd!
    autocmd BufRead /dev/shm/pass.* iabbrev auto autotype: email :tab pass :enter
augroup END


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" GENERAL {{{


" refresh screen the phat way
" TODO make it work
"if s:MyMode == 'stripped'
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<cr>
"else
     "command! MyRefresh :nohlsearch<bar>
                    "\   :diffupdate<bar>
                    "\   :syntax sync fromstart <bar>
                    "\   :redraw!<bar>
                    "\   :AirlineRefresh<cr>
"endif
"nnoremap <leader><f5> :MyRefresh<cr>

" ignore typos with text edit leader
nnoremap - <nop>

" show absolute path of current file (':help filename-modifiers')
nnoremap <leader><c-g> :echo expand("%:~")<cr>


" copy current filename/path/dir (unnamed register/clipboard/fucking everywhere) {{{
command! CopyFileName                   :call CopyFileNameOrPathOrDir("%:t")    " Copy name of current file
command! CopyFileNameWithoutExtension   :call CopyFileNameOrPathOrDir("%:t:r")  " Copy name of current file (without extension)
command! CopyFilePath                   :call CopyFileNameOrPathOrDir("%")      " Copy relative path to current file
command! CopyFilePathAbsolute           :call CopyFileNameOrPathOrDir("%:p")    " Copy absolute path to current file
command! CopyFileDirectory              :call CopyFileNameOrPathOrDir("%:p:h")  " Copy directory of current file
nnoremap <leader>yf :CopyFileName<cr>
nnoremap <leader>ye :CopyFileNameExpand<cr>
nnoremap <leader>yp :CopyFilePath<cr>
nnoremap <leader>yP :CopyFilePathAbsolute<cr>
nnoremap <leader>yd :CopyFileDirectory<cr>
" }}}

" open all files that are dirty according to git
command! EditGitDirtyFiles :call EditGitDirtyFiles() " open all files that are dirty according to git
function! EditGitDirtyFiles()
    let numberOfGitDirtyFiles = system("git status --porcelain 2>/dev/null \| egrep '^(M\| M)' \| wc -l")
    if numberOfGitDirtyFiles != 0
        silent! args `git diff --name-only`
        " if vim was just started, let's get rid of the first unnamed buffer:
        if empty(getbufinfo()[0]['name'])
            bd 1
        endif
        " TODO: avoid error with already openend windows
    else
        echo 'Working directory clean'
    endif
endfunction
" nnoremap <leader>eG :silent! args `git diff --name-only`<cr>:bd#<cr>
nnoremap <leader>eG :call EditGitDirtyFiles()<cr>

" open config file
"nnoremap <leader>ev :edit ~/dotfiles/vim/vimrc<cr>
nnoremap <leader>ev :execute 'edit ' . resolve(expand($MYVIMRC))<cr>
nnoremap <leader>e3 :execute 'edit ' . resolve(expand('~/.i3/config'))<cr>

" reload config file
nnoremap <leader>sv :SourceMYVIMRC<cr>
nmap <f5> <leader>sv


" to follow links in help and jump to definition (ctags)
nnoremap <m-enter>    <c-]>
nnoremap <esc><enter> <c-]>
augroup map_enter_help
    au!
    au BufReadPost */vim/*/doc/*,*/\.vim/bundle/*doc/*
                \ nnoremap <buffer> <enter> <c-]>
augroup END
nnoremap <leader><down> :tn<cr>
nnoremap <leader><up>   :tp<cr>


" visual block mode is more useful than visual mode
nnoremap v <c-v>
nnoremap <c-v> v

" alternative for visual line mode
nnoremap vv V

" leave visual mode quickly
vnoremap v <c-c>


" copy to clipboard / primary selection
nnoremap         <c-c>            "+y
nnoremap    <c-c><c-c>      V"*ygv"+y
nnoremap <leader><c-c>  mzggVG"*ygv"+y`z
vnoremap         <c-c>        "*ygv"+y

" paste from clipboard / primary selection {{{
function! PasteFromGUI()
    let clipbrd = @+
    let primary = @*
    if len(primary) == 0
        normal "+Pl
    elseif len(clipbrd) == 0
        normal "*Pl
    elseif primary == clipbrd
        normal "*Pl
    else
        ec "Paste (c)lipboard (default)    " . strtrans(strpart(clipbrd, 0, 50))
        ec "or    (p)rimary selection?     " . strtrans(strpart(primary, 0, 50))
        let c = getchar()
        if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
            redraw
        elseif nr2char(c) == 'c' || nr2char(c) == '+' || c == 13 || c == 22
            normal "+Pl
            redraw
        elseif nr2char(c) == 'p' || nr2char(c) == 's' || nr2char(c) == '*'
            normal "*Pl
            redraw
        endif
    endif
endfunction
" }}}
noremap <silent> <c-v><c-v> :call PasteFromGUI()<cr>
imap <c-v><c-v> <c-o><c-v><c-v>
noremap <silent> <c-v>j o<esc>:call PasteFromGUI()<cr>
noremap <silent> <c-v>k O<esc>:call PasteFromGUI()<cr>


" Convert Unix timestamp to datetime
function! UnixTimestampAsDateTime(timestamp)
    return system('date --iso-8601=seconds -d @' . a:timestamp . ' | tr -d "\n"')
endfunction

" Replace Unix timestamp with datetimes
function! ReplaceUnixTimestampWithDateTime(rangeString)
    "" in current line:
    " .substitute:\v(\d{9,15}):\='"' . UnixTimestampAsDateTime(submatch(1)) . '"':
    "" with range:
    exe a:rangeString . 'substitute:\v(\d{9,15}):\= ''"''. UnixTimestampAsDateTime(submatch(1)) . ''"'':'
endfunction

" Replace Unix timestamp with datetime in current line
command! ReplaceUnixTimestampWithDateTimeInCurrentLine :call ReplaceUnixTimestampWithDateTime('.') " Replace Unix timestamps with datetimes in current line
nnoremap -iu :call ReplaceUnixTimestampWithDateTime('.')<cr>

" Replace Unix timestamps with datetimes in buffer
command! ReplaceUnixTimestampWithDateTimeInBuffer :call ReplaceUnixTimestampWithDateTime('%') " Replace Unix timestamps with datetimes in buffer
nnoremap -iU :call ReplaceUnixTimestampWithDateTime('%')<cr>

" Show Unix timestamp under cursor as datetime
command! UnixTimestampAsDateTime :echo UnixTimestampAsDateTime(expand("<cword>"))
nnoremap <leader>iu :echo UnixTimestampAsDateTime(expand("<cword>"))<cr>


" macro ('complex repeat') without worrying about registers
" record macro (start and stop) with <leader>Q
" replay macro with <leader>q
" nnoremap @{ :nmap <leader<left><right>>Q @}<cr>qq
" nnoremap @} q:nmap <leader<left><right>>Q @{<cr>:echo ''<cr>
" nmap     <leader>Q @{
" nnoremap <leader>q @q

" macro ('complex repeat') with registers
" (remapping q is bad, because it is used to close stuff like plugin windows)
nnoremap Q @
nnoremap QQ @@



" alternative way to go back to normal mode
inoremap jk <esc>
cnoremap jk <c-c>
cnoremap <c-g> <c-c>

" change to insert mode from visual mode
" (this disables text objects)
"vnoremap i vi

" scroll with arrow keys if i lay back
"nnoremap <down> <c-e>
"nnoremap <up>   <c-y>

" scroll a little smoother (but still without plugin)
" (this actually is suggested in :help scroll-smooth)
noremap <m-j>  <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <esc>j <c-e><c-e><c-e><c-e><c-e><c-e><c-e><c-e>
noremap <m-k>  <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>
noremap <esc>k <c-y><c-y><c-y><c-y><c-y><c-y><c-y><c-y>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TERMINAL {{{

" nnoremap <leader>tt :Terminal! fish<cr>
" nnoremap <leader>to :Terminal<space>
" nnoremap <leader>tO :Terminal!<space>

" run a given (interactive) commandline in the builtin terminal in a vertical split (also see :Shell)
command! -nargs=1 -bang Terminal :call Terminal(<bang>0, <q-args>)
" with bang == 0: keep terminal open after exit
" with bang == 1: close terminal automatically after exit
" TODO: argument for keeping focus on current window
function! Terminal(bang, commandline)
    if !has('nvim')
        let l:open_or_close = a:bang ? "++close " : "++open "
        execute 'vertical terminal ' . l:open_or_close . a:commandline
    else
        let g:terminal_close_after_exit = a:bang
        execute 'vsplit | terminal ' . a:commandline
    endif
endfunction

if has('nvim')

    let g:terminal_close_after_exit = 0

    augroup terminal_autocommands
        au!

        " start terminal in insert mode, not normal mode
        " (in neoterm we have g:neoterm_autoinsert)
        " autocmd TermOpen * startinsert

        " enter insert mode when switching to terminal
        " autocmd BufEnter term://* startinsert
        autocmd BufEnter term://* if !exists('g:suppress_terminal_autoinsert') | startinsert | endif

        " don't show line numbers
        autocmd TermOpen * setlocal nonumber
        autocmd TermOpen * setlocal norelativenumber

        " close terminal buffer automatically (https://www.reddit.com/r/neovim/comments/7xonzm/how_to_close_a_terminal_buffer_automatically_if/)
        autocmd TermClose * silent call s:OnTermClose()

    augroup END

    function! s:OnTermClose()
        if g:terminal_close_after_exit
            call s:PressKeyToCloseTerminal()
        endif
    endfunction

    function! s:PressKeyToCloseTerminal()
        " Try to move the cursor to the last line containing text
        try
            $;?.
        catch
            " The buffer is empty here. This shouldn't ever happen
            return
        endtry
        " Is the last line an error message?
        if match(getline('.'), 'make: \*\*\* \[[^\]]\+] Error ') == -1
            call feedkeys('<cr>')
        endif
    endfunction

endif

" leave terminal insert mode
" (this is a bad idea if terminal applications use <esc> as well)
" tnoremap <esc> <c-\><c-n>
" tnoremap <expr> <esc> &filetype == 'fzf' ? "\<esc>" : "\<c-\>\<c-n>"

" leave terminal insert mode and scroll up
tnoremap <c-b> <c-\><c-n><c-b>

" leave terminal insert mode and move to window on the left
tnoremap <c-h> <c-\><c-n><c-w>h

" TODO: checkout debugging feature (see :help terminal-debug)


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAKE THE COMMAND MODE A LITTLE NICER {{{
" (there may be other command mode things elsewhere that are more general)

" nnoremap ; : " don't know what to do with sneak then
" nnoremap : ;

" open help in vertical window
cnoreabbrev <expr> h ((getcmdtype() is# ':' && getcmdline() is# 'h')
            \ ?('vertical help'):('h'))
autocmd FileType help wincmd L

" write changes with root permissions
cnoremap w!! w !sudo tee % >/dev/null
"cnoreabbrev w!! w !sudo tee % >/dev/null

" have the up/down search functionality without reaching to the arrow keys
cnoremap <c-j> <down>
cnoremap <c-k> <up>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE SETTINGS/OPTIONS {{{

" change undofile settings
command! DisableUndoFile :setlocal noundofile " don't persist undo history
command! EnableUndoFile  :setlocal undofile   " persist undo history
nnoremap <leader>ou :setlocal undofile! <bar> :setlocal undofile?<cr>

" change text width
command! -nargs=1 SetTextWidth  :set textwidth=<args> " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthDisable    :set textwidth=0      " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo50       :set textwidth=50     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo78       :set textwidth=78     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo80       :set textwidth=80     " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo100      :set textwidth=100    " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
command! SetTextWidthTo120      :set textwidth=120    " Maximum width of text that is being inserted. A longer line will be broken after white space to get this width.
nnoremap <leader>ow0            :set textwidth=0<cr>
nnoremap <leader>ow5            :set textwidth=50<cr>
nnoremap <leader>ow7            :set textwidth=78<cr>
nnoremap <leader>ow8            :set textwidth=80<cr>
nnoremap <leader>ow1            :set textwidth=100<cr>
nnoremap <leader>ow2            :set textwidth=120<cr>

" change tab width (soft)
command! SetTabWidthTo2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2 " How many spaces a tab should be considered
command! SetTabWidthTo4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4 " How many spaces a tab should be considered
command! SetTabWidthTo8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4 " How many spaces a tab should be considered
nnoremap <leader>ot2 :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<cr>
nnoremap <leader>ot4 :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<cr>
nnoremap <leader>ot8 :set expandtab tabstop=8 shiftwidth=4 softtabstop=4<cr>

" toggle paste mode
nnoremap <leader>op :set paste! <bar> :set paste?<cr>

" autosave (aka 'autowrite')
command! DisableAutoSave        :let g:autosave = 0         " Don't save file autosave on focus lost (globally)
command! EnableAutoSave         :let g:autosave = 1         " Save file autosave on focus lost (globally)
command! DisableAutoSaveForFile :let b:local_autosave = 0   " Don't save file autosave on focus lost (only current file)
command! EnableAutoSaveForFile  :let b:local_autosave = 1   " Save file autosave on focus lost (only current file)

" toggle autosave
nnoremap <silent> <leader>oWW
            \ :if !exists("b:local_autosave") <bar> let b:local_autosave = 0 <bar> endif <cr>
            \ :let b:local_autosave = 1 - b:local_autosave <cr>
            \ :echo b:local_autosave == 1 ?
            \ 'autosave enabled for local buffer' :
            \ 'autosave disabled for local buffer'<cr>
nnoremap <silent> <leader>oWA
            \ :let g:autosave = 1 - g:autosave <cr>
            \ :echo g:autosave == 1 ?
            \ 'autosave enabled' :
            \ 'autosave disabled'<cr>

" toggle search preferences
command! EnableHighlightSearch  :set hlsearch       " When there is a previous search pattern, highlight all its matches.
command! DisableHighlightSearch :set nohlsearch     " When there is a previous search pattern, don't highlight all its matches.
command! EnableWrapSearch       :set wrapscan       " Searches wrap around the end of the file.
command! DisableWrapSearch      :set nowrapscan     " Searches don't wrap around the end of the file.
nnoremap <leader>os :set hlsearch! <bar> :set hlsearch?<cr>
nnoremap <leader>oS :set wrapscan! <bar> :set wrapscan?<cr>

" ... but ignore typos
nnoremap <leader>o <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CHANGE VISUAL THINGS {{{


" toggle syntax highlighting
nmap <silent> <leader>syn :ToggleSyntaxCurrentBuffer<cr>

" toggle syntax highlighting after g:synmaxcol characters
command! ToggleSyntaxLongLines :let &synmaxcol = g:synmaxcol - &synmaxcol " Disable or enable syntax highlighting (long lines)
nmap <silent> <leader>sym :ToggleSyntaxLongLines

" toggle line numbers
command! ToggleLineNumbers          :set number! <bar> :set relativenumber! " Disable or enable line numbers
command! ToggleRelativeLineNumbers  :set relativenumber!                    " Disable or enable relative line numbers
nnoremap <silent> <leader>yL :ToggleLineNumbers <cr>
nnoremap <silent> <leader>yl :ToggleRelativeLineNumbers <cr>

" toggle word wrap
command! ToggleWordWrap :setlocal wrap! <bar> :set wrap? " This option changes how text is displayed. It doesn't change the text in the buffer, see 'textwidth' for that.
nnoremap <silent> <leader>yw :ToggleWordWrap <cr>

" toggle vertical ruler
command! ToggleRuler :call SetColorColumn('toggle') " toggle vertical ruler
nnoremap <silent> <leader>yr :ToggleRuler <cr>
" (quickfix ruler highlighting)
nnoremap <silent> <leader>yR :highlight ColorColumn ctermbg=235
              \ <bar> highlight clear BGdd8844
              \ <bar> highlight clear BG000000
              \ <bar> highlight clear BGffa724
              \ <bar> highlight clear BGaeee00
              \ <bar> highlight clear BG8cffba
              \ <bar> highlight clear BGb88853
              \ <bar> highlight clear BGff9eb8
              \ <bar> highlight clear BGff2c4b
              \ <cr>


" toggle highlight current cursor position
command! ToggleCursor :let g:cursorposition = 1 - g:cursorposition | normal i<esc> " toggle highlight current cursor position
nnoremap <silent> <leader>yc :ToggleCursor <cr>

" toggle show listchars (like whitespace)
command! ToggleListChars :set list! " toggle show listchars (like whitespace)
nnoremap <silent> <leader>ya :ToggleListChars <cr>


" spell checking {{{
command! ChangeSpellChecking :call ChangeSpellChecking() " Disable, enable or change spell checking
function! ChangeSpellChecking()
ec "<space>  Toggle spell checking"
ec "<e>      Set language to 'en'"
ec "<d>      Set language to 'de'"
ec ""
let c = getchar()
if nr2char(c) == 'q' || c == 27 || c == 3 || c == 7
    redraw
elseif nr2char(c) == ' ' || nr2char(c) == 'p'
    redraw
    set spell!
    redraw
elseif nr2char(c) == 'e'
    set spelllang=en
    redraw
elseif nr2char(c) == 'd'
    set spelllang=de
    redraw
endif
set spell?
endfunction
" }}}
nnoremap <leader>ysp :ChangeSpellChecking <cr>

" ... but ignore typos
nnoremap <leader>y <nop>
nnoremap <leader>ys <nop>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MOVEMENT {{{


" move intuitively when text is wrapped
nnoremap j gj
nnoremap k gk

" move faster
nnoremap gj 8j
nnoremap gk 8k
vnoremap gj 8j
vnoremap gk 8k


" move with emacs-keys like in most shells
" (noremap! with the '!' is for insert and ex mode)
" ... by characters
noremap! <c-b>  <left>
noremap! <c-f>  <right>
noremap! <c-d>  <delete>
" ... by words
noremap! <m-b>  <s-left>
noremap! <m-f>  <s-right>
cnoremap <esc>b <s-left>
cnoremap <esc>f <s-right>


" move to BOL (beginning of line)
nnoremap <c-a> ^
cnoremap <c-a> ^

" TODO: FIX
" smart BOL: the cursor moves to the first nonblank character on the line,
"            or, if already at that position, to the very start of the line.
"            (http://vim.wikia.com/wiki/Smart_home)
noremap <expr> <silent> <home>
            \ col('.') == match(getline('.'),'\S')+0 ? '0' : '^'
imap <silent> <home> <c-o><home>

" move to EOL
nnoremap <c-e> $
vnoremap <c-e> $
onoremap <c-e> $
inoremap <c-e> <end>
" move to EOL with l instead of $
onoremap l $

" ... but current character movement is useful sometimes
nnoremap ch cl
nnoremap yh yl
nnoremap <c-c>h v"*ygv"+y

" swap g, and g; (jump through changelist)
nnoremap g, g;
nnoremap g; g,

" swap ` and ' (jump to markers)
" (by default, ' marked line, ` marked line and column)
nnoremap ' `
nnoremap ` '

" goto last edit
nnoremap <leader>. `.zzzv

" center line when jumping around
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SEARCHING AND FINDING {{{


" restart search from BOF/EOF
" (is useful when 'nowrapscan' is set)
" nmap gt 1Gn
nmap g? G$N
" nmap gt :keepjumps normal 1G<cr>n " does not work
" nmap g? :keepjumps normal G$<cr>N " does not work
nmap <silent> gt :ijump! 1    /<c-r>/<cr>zv
" nmap g? :ijump! 9999 /<c-r>/<cr> " does not work


" number of occurrences
nnoremap <leader>n* *<c-o>:%s///ngg<cr>
nnoremap <leader>n/  :%s:<c-r>/::ngg<cr>
xnoremap <leader>n/ y:%s:\V<c-r>"::ngg<cr>



" search in multiple files
if s:MyMode == 'stripped'
    nnoremap <leader>/
            \ :call ToggleList("Quickfix List", 'c')<cr>
            \ :vimgrep // **/*<left><left><left><left><left><left>
endif



" find next and previous occurence like usual when we searched backwards
" TODO: make this work with SearchMode()
" nnoremap <expr> n  'Nn'[v:searchforward]
" nnoremap <expr> N  'nN'[v:searchforward]

" keep search matches in the middle of the window and open folds
" nnoremap n nzzzv
" nnoremap N Nzzzv
silent call <sid>SearchMode()
nnoremap <silent> <leader>on :call <sid>SearchMode()<cr>


" 'goto definition' with viewport adjustments
nmap gd gdztzv
nmap gD gDztzv


" search across newlines
nnoremap <leader>fn :SearchMultiLine<space>


" find word under cursor
nnoremap *  *zv
nnoremap +  #zv
nnoremap g+ #gg/<c-p><cr>zv

" find visual selection
" (i use this instead of g* and g# anyway)
xnoremap *  y/\V<c-r>"<cr>zv
xnoremap +  y?\V<c-r>"<cr>zv
xnoremap g+ ygg/\V<c-r>"<cr>zv


" find lines that are too long
nnoremap <leader>fw :exec '/\v^.{' . &textwidth . '}.'<cr>

" find trailing whitespace
nnoremap <leader>fst /\v\s+$<cr>

" find matching element (brackets/braces/parentheses)
nnoremap <leader>fb %
" extended find matching element (e.g. HTML-tags with matchit plugin)
nmap <leader>f<leader> %

" find all lines with keyword under cursor and ask which one to jump to
nmap <leader>fj [I:let nr = input("Which one: ")
            \   <bar> exe "normal " . nr ."[\t"<cr>

" find git merge conflict markers
nnoremap <leader>fc /\v^[<\|=>]{7}( .*\|$)<cr>

" find errors and stuff
nnoremap <leader>fe /\v(error\|fail)<cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TEXT EDITING {{{


" text edit leader is minus ('-')


" yank/delete line without line break (in difference to yy/dd)
nnoremap Y ^y$
nnoremap D 0d$j

" select last pasted/edited text
nnoremap gV `[v`]

" change case of word under cursor
nnoremap cC viw~

" autocompletion
inoremap <m-.>  <c-n>
inoremap <esc>. <c-n>
inoremap <m-:>  <c-p>
inoremap <esc>: <c-p>

" toggle complex completions (sometimes they are too slow)
nnoremap <leader>oc :if &complete =~ 't' <bar> set complete-=t,i <bar> else <bar> set complete+=t,i <bar> endif <bar> set complete? <cr>

" increment/decrement number
nnoremap -i <c-a>
nnoremap -- <c-x>


" indent lines
vnoremap < <gv
vnoremap > >gv

" change tab width (hard)
nnoremap -rt2 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=2 <bar> :retab <cr>
nnoremap -rt4 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=4 <bar> :retab <cr>
nnoremap -rt8 :set noexpandtab <bar> :retab! <bar>
            \ :set expandtab tabstop=8 <bar> :retab <cr>

" yank line with Enter (i do that so often)
" CANNOT MAP THIS BECAUSE OF SPECIAL PLUGIN BUFFERS AND STUFF
" nnoremap <enter> yy

" " autoformat with enter in normal buffers
" augroup map_enter_autoformat
"     au!
"     au BufReadPost *
"                 \ if ! strchars(&buftype) |
"                 \   nnoremap <buffer> <enter> gqap |
"                 \   vnoremap <buffer> <enter> gq |
"                 \ endif
" augroup END

" move line up or down
" (:m closes folds https://groups.google.com/forum/#!topic/vim_dev/QGgbjv4uyZc)
nnoremap <silent> -k :set fdm=manual<cr>:m .-2<cr>:set fdm=marker<cr>
nnoremap <silent> -j :set fdm=manual<cr>:m .+1<cr>:set fdm=marker<cr>
vnoremap <silent> -j <esc>:set fdm=manual<cr>gv:m '>+1<cr>gv=gv:set fdm=marker<cr>
vnoremap <silent> -k <esc>:set fdm=manual<cr>gv:m '<-2<cr>gv=gv:set fdm=marker<cr>

" join line
nnoremap -lj J

" join line above (instead of below)
nnoremap -lk kddpkJ

" split line (opposite of join line)
" (regular 'S' can be done with 'cc' instead)
nnoremap <leader><cr> i<cr><esc>
            \ ^mq
            \ :let searchregister=@/<cr>
            \ :silent! .-1s/\v +$//<cr>:nohlsearch<cr>
            \ :let @/=searchregister<cr>
            \ `q

" duplicate code
nnoremap -uu yyp
nnoremap -ul yyp
nnoremap -up yap<s-}>p
vnoremap -u yP

" add new lines above or below
"(this works without mappings, except that we arein insert mode afterwards)
"noremap <m-o>  <esc>o<esc>k
"noremap <esc>o <esc>o<esc>k
"noremap <m-o>  <esc>O<esc>j
"noremap <esc>O <esc>O<esc>j
" nnoremap <somekey> :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[j
nnoremap K :<c-u>put =repeat(nr2char(10), v:count1)<cr>k

" align next column in duplicated line when i don't use replace mode
" (very bad implementation)
nnoremap -li kWjdwgE

" add space (a few newlines) below
"nnoremap <enter> :.+1insert \n\n\n<cr>
nnoremap -as mno<esc>o<esc>o<esc>o<esc>`n

" add a line of characters
nnoremap -al :call InsertCharLine(input("Insert character: "), 80)<cr>
" add a box of characters ('comment box')
nnoremap -ab :call InsertCharBox(input("Insert character: "))<cr>
" add a line of characters below, just as long as the current line
nnoremap -au- yyp^v$r-
nnoremap -au= yyp^v$r=
nnoremap -au# yyp^v$r#

" enter substitution mode quickly
nnoremap <c-s><c-s> :%s::<left>


" in visual mode, use 's' for substitution
" (to change only a single occurence, use 'c'. by default they are the same)

" substitute occurrences of selection in this buffer
vnoremap <c-s>         yms:%s:\V\C<c-r>":<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap <leader><c-s> yms:%s:\V\C\<<c-r>"\>:<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>

" substitute occurrences of selection in this buffer from current line and below
vnoremap s             yms:,$s:\V\C<c-r>":<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>
" the same, but with keyword matching
vnoremap <leader>s     yms:,$s:\V\C\<<c-r>"\>:<c-r>":c<bar>norm!`s
    \ <left><left><left><left><left><left><left><left><left><left><left>

" " (these are actually two substitutions, so that we start at the current line
" " but continue from the first. source: http://stackoverflow.com/a/7608016)
" vnoremap s             yms:,$s:\V\C<c-r>":<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>
" " the same, but with keyword matching
" vnoremap <leader>s     yms:,$s:\V\C\<<c-r>"\>:<c-r>":c<bar>1,''-&&<bar>norm!`s
    " \ <left><left><left><left><left><left><left><left><left>
    " \ <left><left><left><left><left><left><left><left><left><left><left>

" substitute motions
for mov in ['e', 'E', 'b', 'B']
    exe "nmap \<c-s>" . mov . " v" . mov . "\<c-s>"
endfor
" substitute text objects
nmap <c-s>iw viw<leader><c-s>
nmap <c-s>iW viW<c-s>
"substitute word under cursor
nmap <c-s>w viw<leader><c-s>
nmap <c-s>W viW<c-s>

" substitute word under cursor in multiple files (add them with ':arg **' before)
" (instead of using the far plugin)
nnoremap <c-s>a :call Replace(0, input('Replace '.expand('<cword>').' with: '))<cr>
" ... and then ':wa'

" substitute last search
nmap <c-s>/ gggn<c-s>


" replace something with yank
nnoremap -rw viwp
nnoremap -rW viWp
nnoremap -rl v$hp


" sort lines
nnoremap -o vip:sort<cr>
vnoremap -o :sort<cr>


" correct typos like 'DAmnitypefast' to titlecase ('Damnitypefast')
nnoremap -tu blguee
inoremap -tu <esc>blgueea


if s:MyMode == 'stripped'
    " delete trailing whitespace for selected line
    vnoremap <silent> -dst <esc>:.s:\v\s+$::<cr>
    " delete trailing whitespace for whole buffer
    nnoremap <silent> -dst :%s:\v\s+$::<cr>
endif

" delete leading whitespace (can be prefixed with a count)
nnoremap <silent> -dsl :s:^\s\+::<cr>
" replace double/multiple spaces with one space
" TODO: make this repeatable with .
nnoremap <silent> -dsd :.s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> -dsD :%s:\v(\S) {2}(\S):\1 \2:<cr>
nnoremap <silent> -dsm :.s:\v(\S) {2,}(\S):\1 \2:<cr>
nnoremap <silent> -dsM :.s:\v(\S) {2,}(\S):\1 \2:<cr>


" convert a vim plugin github url into appropriate format for vim-plug
nnoremap -pi :.s:\m.*http.*github\.com/\([^/]*/[^/]*\).*:Plug '\1':<cr>


" add/remove an html comment
" (this is useful when syntax is set to php and nerdcommenter fucks up)
nnoremap <silent> <leader>ch :call ToggleHTMLComment("n")<cr>
vnoremap <silent> <leader>ch :call ToggleHTMLComment("v")<cr>

" duplicate a line and comment out the first one
if s:MyMode == 'stripped'
    nnoremap <leader>cd yyI#<esc>p
endif


" undo and redo
" (in difference to :undo and :redo, :earlier and :later also make changes
" reachable if we branch, i.e. go back in history and make other changes)
noremap <m-u>   :earlier<cr>
noremap <esc>u  :earlier<cr>
noremap <m-s-u> :later<cr>
noremap <esc>U  :later<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DIFF AND MERGE {{{


" jump to next/previous change
nnoremap dn ]c
nnoremap dN [c

" remember do and dp


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUILDING, MAKING AND DEBUGGING {{{

nnoremap <leader>bm :make<cr>

if has('nvim')
    let g:run_command_method = "terminal"
else
    let g:run_command_method = "vimux"
endif

function! GetBuildOutputFilename()
    if !empty(v:servername)
        let l:project_name = tolower(v:servername)
    else
        let l:project_name = system('basename "$(pwd)" | tr -d "\n"')
    endif
    let l:project_name = tolower(substitute(l:project_name, "[ /]", "_", "g"))
    " let l:git_branch_name = system('git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d "\n" || echo -n ""')
    " let l:git_branch_name_escaped = substitute(UrlEncode(l:git_branch_name), '%..', '-', 'g')
    let l:build_output_file = '/tmp/vim.' . l:project_name . '.make.out'
    return l:build_output_file
endfunction

function! IsBuildShellRunning()
    if g:run_command_method == "terminal"
        let l:terminal_bufnum = GetTerminalBuffer()
        return l:terminal_bufnum > 0
    elseif g:run_command_method == "vimux"
        " TODO: make this work for other shells
        return exists('g:build_shell') && match(g:build_shell, 'sbt') == 0
                    \ && IsSbtRunning()
    else
        return 0
    endif
endfunction

" open up build shell if not already opened before executing commandline
command! -nargs=1 RunCommandInBuildShell :call RunCommandInBuildShell(<q-args>)
function! RunCommandInBuildShell(commandline)
    if !IsBuildShellRunning() && exists('g:build_shell')
        let l:build_output_file = GetBuildOutputFilename()
        let l:neoterm_autoinsert = g:neoterm_autoinsert
        let g:neoterm_autoinsert = 0
        let l:shell_cmd = g:build_shell . " | tee (tty) > " . l:build_output_file
        call RunCommand(l:shell_cmd)
        let g:neoterm_autoinsert = l:neoterm_autoinsert
    endif
    call RunCommand(a:commandline)
endfunction

command! -nargs=1 RunCommand :call RunCommand(<q-args>)
function! RunCommand(command)
    if g:run_command_method == "terminal"
        call RunCommandInTerminal(a:command)
    elseif g:run_command_method == "vimux"
        call VimuxRunCommand(a:command)
    else
      echoerr "Unknown g:run_command_method (" . g:run_command_method . ")"
    endif
endfunction

nnoremap <leader>bC :call RunCommand(getline('.'))<cr>
vnoremap <leader>bC y:call RunCommand(@*)<cr>
nnoremap <silent> <leader>be :OpenBuildErrorsInQuickfixList<cr><esc>hj
nnoremap <silent> <leader>bE :OpenBuildErrorsInBuffer<cr><esc>hj

if g:run_command_method == "terminal"
    nnoremap <leader>bo         :RunCommandInBuildShell<space>
    nnoremap <leader>bf         :execute 'RunCommandInBuildShell  ' . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
    nnoremap <leader>bF         :execute 'RunCommandInBuildShell ' . ExpandPrependThisDir('%') . ' '<left>
    nnoremap <leader>bb         :update<cr> :call RunLastCommandInTerminal()<cr>
    nnoremap <leader>bl         :ExecuteInNeoTerminal Tclear<cr>
    nnoremap <leader>bc         :ExecuteInNeoTerminal Tkill<cr>
    nnoremap <leader>b<c-c>     :ExecuteInNeoTerminal Tkill<cr>
    nnoremap <leader>b<bs>      :Tclose<cr>         " only hides buffer, we can still sent commands to it
elseif g:run_command_method == "vimux"
    nnoremap <leader>bo         :VimuxRunCommand ""<left>
    nnoremap <leader>bf         :VimuxRunCommand " " . expand('%')<left><left><left><left><left><left><left><left><left><left><left><left><left><left><left><left>
    nnoremap <leader>bF         :VimuxRunCommand ExpandPrependThisDir('%') . " "<left>
    nnoremap <leader>bb         :update<cr>:VimuxRunLastCommand<cr>
    nnoremap <silent> <leader>bl :VimuxClearTerminalScreen<cr>
    nnoremap <leader>bq         :VimuxCloseRunner<cr>
    nnoremap <leader>b<bs>      :VimuxCloseRunner<cr>
    nnoremap <leader>bz         :call VimuxZoomRunner()<cr>
    nnoremap <leader>bc         :VimuxInterruptRunner<cr>
    nnoremap <leader>b<c-c>     :VimuxInterruptRunner<cr>
    nnoremap <leader>b<c-d>     :call VimuxSendKeys("C-d")<cr>
    nnoremap <leader>b<c-b>     :VimuxInspectRunner<cr>
    nnoremap <leader><c-b><c-b> :VimuxInspectRunner<cr>
else
    echoerr "Unknown g:run_command_method (" . g:run_command_method . ")"
endif

function! RemoveEscapeSequencesFromFile(filename)
    " color escape sequences
    exec ':silent !sed -i -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" ' . a:filename
    exec ':silent !sed -i -r "s/\\x1b\\[[0-9;]*[a-zA-Z]//g" ' . a:filename
    " magic control sequences
    exec ':silent !sed -i -r "s/[\\x01-\\x1F\\x7F]//g" ' . a:filename
    exec ':silent !sed -i -r "s/[\\x?1-\\x1F\\x7F]//g" ' . a:filename
    " weird sbt shell sequences
    exec ':silent !sed -i -r "s/\[\?1h=\[\?2004h//g" ' . a:filename
endfunction

" open quickfix list with build errors from the terminal
command! OpenBuildErrorsInQuickfixList :call OpenBuildErrorsInQuickfixList()
function! OpenBuildErrorsInQuickfixList()
    " let l:terminal_bufnum = GetTerminalBuffer()
    " if l:terminal_bufnum == 0
    "     echoerr 'No terminal buffer found.'
    "     return
    " let l:lines = getbufline(l:terminal_bufnum, 1, '$')
    "
    " " Unfortunately, the terminal (or more specifically libvterm) inserts hard
    " " linebreaks when the width of the terminal window is reached, so it's
    " " hardly usable for parsing build output.
    " " See https://github.com/neovim/neovim/issues/2514
    " " So I use the tee to build output file solution instead:
    "
    let l:build_output_file = GetBuildOutputFilename()
    let l:lines = readfile(l:build_output_file)

    let l:errorfile = '/tmp/vim.errorfile.txt'
    call writefile(l:lines, l:errorfile)
    call RemoveEscapeSequencesFromFile(l:errorfile)
    let l:lines = readfile(l:errorfile)

    let l:last_prompt_line = 1
    if exists('g:prompt_regex')
        for i in range (len(l:lines) - 2 , 1, -1)
            if match(l:lines[i], g:prompt_regex) == 0
                let l:last_prompt_line = i
                break
            endif
        endfor
    endif
    if l:last_prompt_line != 1
        call writefile(l:lines[l:last_prompt_line:], l:errorfile)
    endif

    cclose
    exe 'cfile' . l:errorfile
    if len(getqflist()) > 0
        let g:jumplist = 'quickfixlist'
        copen
        cfirst
    else
        echomsg "No build errors."
    endif
endfunction

command! OpenBuildErrorsInBuffer :call OpenBuildErrorsInBuffer()
function! OpenBuildErrorsInBuffer()
    let l:build_output_file = GetBuildOutputFilename()
    call RemoveEscapeSequencesFromFile(l:build_output_file)
    execute "edit " . l:build_output_file
endfunction



" execute shell script
command! ExecuteShellscript :call ExecuteShellscript() " Execute shellscript (current file) in a new tmux pane
function! ExecuteShellscript()
    call system('test -x ' . expand('%'))
    if v:shell_error
        call system('chmod +x ' . expand('%'))
    endif
    if s:MyMode == 'mastery'
        call RunCommand(ExpandPrependThisDir("%"))
    else
        exec '!' . ExpandPrependThisDir('%')
    endif
endfunction
augroup shellscript_on_read
    au!
    au FileType sh      call SetupShellscript()
    au FileType fish    call SetupShellscript()
augroup END
function! SetupShellscript()
    nnoremap <leader>bs :call ExecuteShellscript()<cr>
endfunction


" jump to (syntastic) errors
command! JumpToFirstSyntaxError :lfirst
command! JumpToLastSyntaxError  :llast
nnoremap <leader>sg :lfirst<cr>
nnoremap <leader>sG :llast<cr>
" nnoremap <leader>sn :lnext<cr>
" nnoremap <leader>sN :lprevious<cr>

" jump through both, quickfix and location list, with the same keys
" @param direction: 0 for next, 1 for previous
" @param perFile: 0 for jumping per occurence, 1 for jumping per file
" @param switch: 0 for the same list as before, 1 for the other
let g:jumplist = 'quickfixlist'
function! JumpThroughList(direction, perFile, switch)
    if (a:switch == 1)
        if (g:jumplist == 'quickfixlist')
            let g:jumplist = 'locationlist'
        else
            let g:jumplist = 'quickfixlist'
        endif
    endif
    if (g:jumplist == 'locationlist')
        if (a:perFile == 0)
            if (a:direction == 0)
                silent! lnext
            else
                silent! lprevious
            endif
        else
            if (a:direction == 0)
                silent! lnfile
            else
                silent! lpfile
            endif
        endif
    else
        if (a:perFile == 0)
            if (a:direction == 0)
                silent! cnext
            else
                silent! cprevious
            endif
        else
            if (a:direction == 0)
                silent! cnfile
            else
                silent! cpfile
            endif
        endif
    endif
endfunction

nnoremap <silent> <left>          :call JumpThroughList(1, 0, 0)<cr>
nnoremap <silent> <right>         :call JumpThroughList(0, 0, 0)<cr>
nnoremap <silent> g<left>         :call JumpThroughList(1, 1, 0)<cr>
nnoremap <silent> g<right>        :call JumpThroughList(0, 1, 0)<cr>
nnoremap <silent> <leader><left>  :call JumpThroughList(1, 0, 1)<cr>
nnoremap <silent> <leader><right> :call JumpThroughList(0, 0, 1)<cr>


" close location list (which contains syntastic errors) and quickfix window
nnoremap <silent> <leader>sl :lclose<bar>:cclose<cr>
" reopen location list (which contains syntastic errors)
nnoremap <silent> <leader>sL :lopen<cr>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BUFFERS AND WINDOWS {{{


" change or open new buffer by searching for file name
if s:MyMode == 'stripped'
    nnoremap <space><space> :buffers<cr>:buffer<space>
    nnoremap <leader>fi :find<space>
endif

" change to LRU buffer
nnoremap <leader>e<leader> :buffer #<cr>
nnoremap <leader><tab>     :buffer #<cr>

" navigate through buffers
nnoremap <m-n>  :bnext<cr>
nnoremap <esc>n :bnext<cr>
nnoremap <m-p>  :bprevious<cr>
nnoremap <esc>p :bprevious<cr>

" change window
nnoremap <silent> <c-j> :wincmd j<cr>
nnoremap <silent> <c-k> :wincmd k<cr>
nnoremap <silent> <c-h> :wincmd h<cr>
nnoremap <silent> <c-l> :wincmd l<cr>

" move buffer to a new window
nnoremap <silent> <leader><c-l> :vsplit<cr><c-w>w:bprevious<cr><c-w>w<cr>
nnoremap <silent> <leader><c-j> :vertical split<cr>

" swap/rotate windows
nnoremap <silent> <c-w>> <c-w>r
nnoremap <silent> <c-w>< <c-w>R

" resize window mode
nnoremap <silent> <c-w>r     :ResizeWindows<cr>
nnoremap <silent> <c-w><c-r> :ResizeWindows<cr>
command! ResizeWindows  :call ResizeWindows('enter') " Open a mode to resize windows with h,j,k,l
function! ResizeWindows(enter_or_leave)
    " TODO: save and restore existing mappings (j,k)
    if a:enter_or_leave == "enter"
        nnoremap <return> :call ResizeWindows('leave')<cr>
        nnoremap <silent> j :resize -2<cr>
        nnoremap <silent> k :resize +2<cr>
        nnoremap <silent> h 2<c-w>>
        nnoremap <silent> l 2<c-w><
        echo "[RESIZE MODE] (press h,j,k,l to resize and <enter> to leave move)"
    else
        nnoremap j gj
        nnoremap k gk
        nunmap   h
        nunmap   l
        nunmap   <return>
        echo "Windows resized."
    endif
endfunction

" navigate through tabs
nnoremap <leader><m-n>  :tabnext<cr>
nnoremap <leader><esc>n :tabnext<cr>
nnoremap <leader><m-p>  :tabprevious<cr>
nnoremap <leader><esc>p :tabprevious<cr>


" clear windows (close quickfix and location list) and refresh screen
nnoremap <silent> <bs> :nohlsearch \| :lclose \| :cclose \| :redraw! <cr> :<c-c>
xmap <silent> <bs> <bs>gv

" toggle quickfix or location list
nnoremap <silent> <leader>tq :call ToggleList("Quickfix List", 'c')<cr>
nnoremap <silent> <leader>tl :call ToggleList("Location List", 'l')<cr>

" TODO:
" Normally the quickfix window is at the bottom of the screen.  If there are
" vertical splits, it's at the bottom of the rightmost column of windows.  To
" make it always occupy the full width: >
" :botright cwindow



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" builtin file explorer (netrw) {{{
" (who needs NERDTree anyway)

let g:netrw_liststyle = 3
let g:netrw_winsize = 20
let g:netrw_banner = 0
let g:netrw_browse_split = 4


function! ToggleNetRW(from_current_file)
    if exists("g:netrw_buffer") && bufexists(g:netrw_buffer)
        exe "bd".g:netrw_buffer | unlet g:netrw_buffer
    else
        if (a:from_current_file == 1)
            exe 'Lexplore ' . expand('%:p:h') | let g:netrw_buffer=bufnr("%")
        else
            Lexplore | let g:netrw_buffer=bufnr("%")
        endif
    endif
endfunction

command! ToggleFileBrowserFromCurrentFile :call ToggleNetRW(1) " Open (or close) netrw in side bar (current file)
command! ToggleFileBrowserFromProjectDir  :call ToggleNetRW(0) " Open (or close) netrw in side bar (project root)
nnoremap <silent> <leader>te :ToggleFileBrowserFromCurrentFile<cr>
nnoremap <silent> <leader>tE :ToggleFileBrowserFromProjectDir<cr>


augroup netrw_autocmds
    autocmd!
    autocmd filetype netrw call NetrwMappings()
    autocmd filetype netrw setlocal bufhidden=wipe
augroup END

function! NetrwMappings()
    silent! nunmap <buffer> qL
    silent! nunmap <buffer> qF
    silent! nunmap <buffer> qf
    silent! nunmap <buffer> qb
    silent! nunmap <buffer> q
    silent! nunmap <buffer> <c-l>
    nnoremap <buffer> q   :bd<cr>
    nnoremap <buffer> h   :help netrw-quickmap<cr>
    nmap     <buffer> .   gh
    nmap     <buffer> u   -
    " TODO: nnoremap u or locally unmap all - bindings to prevent odd bugs
    nmap     <buffer> af  %
    nmap     <buffer> ad  d
endfunction



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTERNAL TOOLS {{{

" search the web with selection
vnoremap <leader>isl :<c-w>!$BROWSER 'https://dict.leo.org/ende/?lang=en&search=<c-r>*'<cr><cr>
vnoremap <leader>isd :<c-w>!$BROWSER 'https://duckduckgo.com/?q=<c-r>*'<cr><cr>
vnoremap <leader>isg :<c-w>!$BROWSER 'https://google.com/?q=<c-r>*'<cr><cr>

" shell in working dir or dir of current file
nnoremap <leader>if :Shell fish<cr>
nnoremap <leader>iF :call Shell('cd ' . expand('%:p:h') . '; fish')<cr>
nnoremap <leader>ib :Shell bash<cr>
nnoremap <leader>iB :call Shell('cd ' . expand('%:p:h') . '; bash')<cr>

" file manager in working dir or dir of current file
" nnoremap <leader>ir :call RunCommand("ranger")<cr>
" nnoremap <leader>ir :exe "!ranger " . shellescape(expand("%p:h"))
nnoremap <leader>ir :RangerChooserFromCurrentFile<cr><cr>
nnoremap <leader>iR :RangerChooser<cr><cr>

" tig - an ncurses git interface
function! Tig(from_current_file)
    if (a:from_current_file)
        let l:command = 'cd "' . expand('%:p:h') . '"; tig status'
        execute 'Shell fish -c ''' . l:command . ''''
    else
        Shell tig status
    endif
    redraw!
endfunction
command! TigFromWorkingDir  :call Tig(0) " Interactive Git interface (from working directory)
command! TigFromCurrentFile :call Tig(1) " Interactive Git interface (from current file)
nnoremap <leader>it :TigFromWorkingDir<cr>
nnoremap <leader>iT :TigFromCurrentFile<cr>

" insert google contacts with name and mail addresses (with goobook)
" TODO: fix
command! -nargs=1 InsertGoogleContact :r!goobook-query-mail.sh <args> " Interactively search for Google contacts and insert name and email
" nnoremap <leader>igm :InsertGoogleContact
nnoremap <leader>igm         :r!goobook-query-mail.sh<space>
" inoremap <leader>igm <esc>diw:r!goobook-query-mail.sh<space><c-r>"<cr><cr>



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SAVING AND CLOSING {{{

function! MkdirIfNotExists(dir)
    if !isdirectory(a:dir)
        silent! call system('mkdir -p "' . a:dir . '"')
    endif
endfunction

silent! function! Save(force)
    call MkdirIfNotExists(expand("%:h"))
    if (a:force)
        if !exists('b:DeleteTrailingWhitespace_Action') || b:DeleteTrailingWhitespace_Action == 'ask'
            update!
        else
            silent update!
            GitGutter
            echo '"' . expand("%") . '" ✔'
        end
    else
        if !exists('b:DeleteTrailingWhitespace_Action') || b:DeleteTrailingWhitespace_Action == 'ask'
            update
        else
            silent update
            GitGutter
            echo '"' . expand("%") . '" ✔'
        end
    endif
endfunction

command! NewTab             :tabnew                 " Create a new tab
command! ReloadBuffer       :checktime              " Check for file changes (and 'reload' them or get asked with autoread)
command! Reset              :e!                     " Discard changes in buffer
command! Save               :call Save(0)           " Write buffer changes to file
command! SaveForce          :call Save(1)           " Write buffer changes to file ignoring 'readonly' etc.
command! SaveAndClose       :wq                     " Write buffer changes to file and close window
command! CloseBuffer        :bn | :bd#              " Close current buffer (without closing window)
command! CloseBufferForce   :bdelete!               " Close current buffer discarding changes
command! CloseAllBuffers    :silent bufdo bdelete   " Close all buffers (not vim)
command! CloseWindow        :quit                   " Close current window (not buffer)
command! CloseOtherWindows  :only                   " Close all but current window (not buffers)
command! CloseTab           :tabclose               " Close current tab (not buffer)
command! QuitVim            :quitall                " Quit Vim (closing all windows)
command! QuitVimForce       :quitall!               " Quit Vim (closing all windows) discarding changes

nnoremap <leader>rl         :ReloadBuffer<cr>
nnoremap <leader>rs         :Reset<cr>
nnoremap <leader>w          :Save<cr>
nnoremap <leader>WW         :SaveForce<cr>
nnoremap <leader>qq         :SaveAndClose<cr>
nnoremap <leader>qa         :CloseAllBuffers<cr>
nnoremap <leader><bs>       :CloseBuffer<cr>
nnoremap <leader>QQ         :CloseBufferForce<cr>
nnoremap <leader>qW         :CloseWindow<cr>
nnoremap <leader>qw         :CloseOtherWindows<cr>
nnoremap <leader><c-n>      :NewTab<cr>
nnoremap <leader><c-w>      :CloseTab<cr>
nnoremap <c-d>              :QuitVim<cr> " this is how i exit most terminal applications
nnoremap <leader><c-d><c-d> :QuitVimForce<cr>

augroup map_q_in_read_only_buffers
    au!
    au BufReadPost * if &readonly
    au BufReadPost *   nnoremap <buffer> q :bd<cr>
    au BufReadPost * endif
    au BufReadPost fugitive://*     nnoremap <buffer> q :bd<cr>
    au BufReadPost output://*       nnoremap <buffer> q :bd<cr>
augroup END

" ... but ignore typos
nnoremap <leader>q <nop>
nnoremap <leader>Q <nop>


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILETYPE SPECIFIC SETTINGS {{{


augroup SET_FILETYPE
    au!
    au BufNewFile,BufReadPost *.conf set ft=conf
augroup END


augroup FILETYPE_SPECIFIC_SETTINGS_QUICKFIX
    autocmd!
    autocmd filetype qf setlocal norelativenumber
    autocmd filetype qf setlocal colorcolumn=
augroup END


augroup FILETYPE_SPECIFIC_SETTINGS_GITCOMMIT
    autocmd!
    autocmd filetype gitcommit setlocal nonumber norelativenumber
    autocmd filetype gitcommit let b:local_autosave = 0
    autocmd filetype gitcommit let b:DeleteTrailingWhitespace_Action = 'delete'
    autocmd filetype gitcommit normal gg
    autocmd filetype gitcommit call InsertTicketNumberFromBranchIfAny()
augroup END

command! InsertTicketNumberFromBranchIfAny :call InsertTicketNumberFromBranchIfAny()
function! InsertTicketNumberFromBranchIfAny()
    if empty(getline('.'))
        let l:branch_name = system('git rev-parse --abbrev-ref HEAD')
        let l:ticket_number_pattern = '.*/\zs...-\d\+\ze/.*'
        let l:ticket_number = matchstr(l:branch_name, l:ticket_number_pattern)
        call setline(1, l:ticket_number)
        normal $l
    endif
endfunction


augroup FILETYPE_SPECIFIC_SETTINGS_JSON
    autocmd!
    autocmd! FileType json setlocal conceallevel=0 foldmethod=syntax foldlevel=999
    autocmd! FileType json syntax match Comment +\/\/.\+$+
augroup END


" default textwidth
augroup auto_textwidth
    autocmd!
    autocmd FileType dockerfile      set textwidth=100 | call SetColorColumn('on')
    autocmd FileType gitcommit       set textwidth=50  | call SetColorColumn('on')
    autocmd FileType markdown        set textwidth=100 | call SetColorColumn('on')
    autocmd FileType php             set textwidth=120 | call SetColorColumn('on')
    autocmd FileType scala           set textwidth=120 | call SetColorColumn('on')
    autocmd FileType sh              set textwidth=100 | call SetColorColumn('on')
    autocmd FileType sql             set textwidth=80  | call SetColorColumn('on')
augroup END



" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" }}}



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                                                              "
" LOCAL SECTION                                                                "
"                                                                              "
"                                                                              "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" {{{

" Check for local vimrc files and source them.
" (project files take precedence over global files)
" (non-hidden files take precedence over hidden files)
" (child directory takes precedence over parent directory)
let vimrcs = []
for vimrc_name in ['vimrc.local', '.vimrc.local']
    let dir = getcwd()
    while dir != '/'
        let vimrc = glob(dir . '/' . vimrc_name)
        if filereadable(vimrc)
            let vimrcs = vimrcs + [vimrc]
        endif
        let dir = fnamemodify(dir . '..', ':h')
    endwhile
endfor
let vimrcs = vimrcs + ['~/.vimrc.local']
for vimrc in reverse(vimrcs)
    if filereadable(vimrc)
        exec 'source ' . vimrc
    endif
endfor


" }}}
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=0:ts=4:sts=4:sw=4:fdm=marker:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
